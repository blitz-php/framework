{"service_name":"travis-ci","service_job_id":null,"repo_token":null,"run_at":"2022-06-21 17:56:39 +0000","source_files":[{"name":"src\\Cache\\Cache.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Cache;\n\nuse BlitzPHP\\Cache\\Handlers\\BaseHandler;\nuse BlitzPHP\\Cache\\Handlers\\Dummy;\nuse DateInterval;\nuse RuntimeException;\n\n\/**\n * Cache fournit une interface coh\u00e9rente \u00e0 la mise en cache dans votre application. Il vous permet\n * d'utiliser plusieurs moteurs de Cache diff\u00e9rents, sans coupler votre application \u00e0 un moteur sp\u00e9cifique\n * la mise en oeuvre. Il vous permet \u00e9galement de modifier le stockage ou la configuration du cache sans affecter\n * le reste de votre candidature.\n *\n * Cela configurerait un moteur de cache APCu sur l'alias \"shared\". Vous pourrez alors lire et \u00e9crire\n * \u00e0 cet alias de cache en l'utilisant pour le param\u00e8tre `$config` dans les diff\u00e9rentes m\u00e9thodes Cache.\n *\n * En g\u00e9n\u00e9ral, toutes les op\u00e9rations de cache sont prises en charge par tous les moteurs de cache.\n * Cependant, Cache::increment() et Cache::decrement() ne sont pas pris en charge par la mise en cache des fichiers.\n *\n * Il existe 7 moteurs de mise en cache int\u00e9gr\u00e9s :\n *\n * - `Apcu` - Utilise le cache d'objets APCu, l'un des moteurs de mise en cache les plus rapides.\n * - `Array` - Utilise uniquement la m\u00e9moire pour stocker toutes les donn\u00e9es, pas r\u00e9ellement un moteur persistant.\n * \t\t\tPeut \u00eatre utile dans un environnement de test ou CLI.\n * - `File` - Utilise des fichiers simples pour stocker le contenu. Mauvaises performances, mais bonnes pour\n * \t\t\tstocker de gros objets ou des choses qui ne sont pas sensibles aux E\/S. Bien adapt\u00e9 au d\u00e9veloppement\n * \t\t\tcar il s'agit d'un cache facile \u00e0 inspecter et \u00e0 vider manuellement.\n * - `Memcache` - Utilise l'extension PECL::Memcache et Memcached pour le stockage.\n * \t\t\tLectures\/\u00e9critures rapides et avantages de la distribution de Memcache.\n * - `Redis` - Utilise l'extension redis et php-redis pour stocker les donn\u00e9es de cache.\n * - `Wincache` - Utilise l'extension de cache Windows pour PHP. Prend en charge Wincache 1.1.0 et sup\u00e9rieur.\n * \t\t\tCe moteur est recommand\u00e9 aux personnes d\u00e9ployant sur Windows avec IIS.\n * - `Xcache` - Utilise l'extension Xcache, une alternative \u00e0 APCu.\n *\n * Voir la documentation du moteur de cache pour les cl\u00e9s de configuration attendues.\n *\/\nclass Cache implements CacheInterface\n{\n    \/**\n     * Un tableau mappant les sch\u00e9mas d'URL aux noms de classe de moteur de mise en cache complets.\n     *\n     * @var array<string, string>\n     * @psalm-var array<string, class-string>\n     *\/\n    protected static $validHandlers = [\n        'dummy' => Handlers\\Dummy::class,\n        'file'  => Handlers\\File::class,\n    ];\n\n    \/**\n     * Flag for tracking whether caching is enabled.\n     *\n     * @var bool\n     *\/\n    protected static $_enabled = true;\n\n    \/**\n     * Configuration des caches\n     *\n     * @var array\n     *\/\n    protected $config = [];\n\n    \/**\n     * @var ?CacheInterface\n     *\/\n    private $adapter;\n\n    \/**\n     * Constructeur\n     *\/\n    public function __construct(array $config = [])\n    {\n        $this->setConfig($config);\n    }\n\n    \/**\n     * Modifie les configuration du cache pour la fabrique actuelle\n     *\/\n    public function setConfig(array $config): self\n    {\n        $this->config  = $config;\n        $this->adapter = null;\n\n        return $this;\n    }\n\n    \/**\n     * Tente de cr\u00e9er le gestionnaire de cache souhait\u00e9\n     *\/\n    protected function factory(): CacheInterface\n    {\n        if (! static::$_enabled) {\n            return new Dummy();\n        }\n        if (! empty($this->adapter)) {\n            return $this->adapter;\n        }\n\n        $validHandlers = $this->config['valid_handlers'] ?? self::$validHandlers;\n\n        if (empty($validHandlers) || ! is_array($validHandlers)) {\n            throw new InvalidArgumentException('Cache config must have an array of $valid_handlers.');\n        }\n\n        $handler  = $this->config['handler'] ?? null;\n        $fallback = $this->config['fallback_handler'] ?? null;\n\n        if (empty($handler)) {\n            throw new InvalidArgumentException('Cache config must have a handler set.');\n        }\n\n        if (! array_key_exists($handler, $validHandlers)) {\n            throw new InvalidArgumentException('Cache config has an invalid handler specified.');\n        }\n\n        $adapter = new $validHandlers[$handler]();\n        if (! ($adapter instanceof BaseHandler)) {\n            if (empty($fallback)) {\n                $adapter = new Dummy();\n            } elseif (! array_key_exists($fallback, $validHandlers)) {\n                throw new InvalidArgumentException('Cache config has an invalid fallback handler specified.');\n            } else {\n                $adapter = new $validHandlers[$fallback]();\n            }\n        }\n\n        if (! ($adapter instanceof BaseHandler)) {\n            throw new InvalidArgumentException(\n                'Cache handler must use BlitzPHP\\Cache\\Handlers\\BaseHandler as a base class.'\n            );\n        }\n\n        if (! $adapter->init($this->config)) {\n            throw new RuntimeException(\n                sprintf(\n                    'Cache engine %s is not properly configured. Check error log for additional information.',\n                    get_class($adapter)\n                )\n            );\n        }\n\n        return $this->adapter = $adapter;\n    }\n\n    \/**\n     * \u00c9crivez les donn\u00e9es de la cl\u00e9 dans le cache.\n     *\n     * ### Utilisation :\n     *\n     * \u00c9criture dans la configuration de cache active :\n     *\n     * ```\n     * $cache->write('cached_data', $data);\n     * ```\n     *\n     * @param mixed                 $value Donn\u00e9es \u00e0 mettre en cache - tout sauf une ressource\n     * @param DateInterval|int|null $ttl   Facultatif. La valeur TTL de cet \u00e9l\u00e9ment. Si aucune valeur n'est envoy\u00e9e et\n     *                                     le pilote prend en charge TTL, la biblioth\u00e8que peut d\u00e9finir une valeur par d\u00e9faut\n     *                                     pour cela ou laissez le conducteur s'en occuper.\n     *\n     * @return bool Vrai si les donn\u00e9es ont \u00e9t\u00e9 mises en cache avec succ\u00e8s, faux en cas d'\u00e9chec\n     *\/\n    public function write(string $key, $value, $ttl = null): bool\n    {\n        if (is_resource($value)) {\n            return false;\n        }\n\n        $backend = $this->factory();\n        $success = $backend->set($key, $value, $ttl);\n        if ($success === false && $value !== '') {\n            trigger_error(\n                sprintf(\n                    \"Unable to write '%s' to %s cache\",\n                    $key,\n                    get_class($backend)\n                ),\n                E_USER_WARNING\n            );\n        }\n\n        return $success;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function set($key, $value, $ttl = null): bool\n    {\n        return $this->write($key, $value, $ttl);\n    }\n\n    \/**\n     * \u00c9crire des donn\u00e9es pour de nombreuses cl\u00e9s dans le cache.\n     *\n     * ### Utilisation :\n     *\n     * \u00c9criture dans la configuration de cache active :\n     *\n     * ```\n     * $cache->writeMany(['cached_data_1' => 'data 1', 'cached_data_2' => 'data 2']);\n     * ```\n     *\n     * @param iterable              $data Un tableau ou Traversable de donn\u00e9es \u00e0 stocker dans le cache\n     * @param DateInterval|int|null $ttl  Facultatif. La valeur TTL de cet \u00e9l\u00e9ment. Si aucune valeur n'est envoy\u00e9e et\n     *                                    le pilote prend en charge TTL, la biblioth\u00e8que peut d\u00e9finir une valeur par d\u00e9faut\n     *                                    pour cela ou laissez le conducteur s'en occuper.\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return bool Vrai en cas de succ\u00e8s, faux en cas d'\u00e9chec\n     *\/\n    public function writeMany(iterable $data, $ttl = null): bool\n    {\n        return $this->factory()->setMultiple($data, $ttl);\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function setMultiple($values, $ttl = null)\n    {\n        return $this->writeMany($values, $ttl);\n    }\n\n    \/**\n     * Lire une cl\u00e9 du cache.\n     *\n     * ### Utilisation :\n     *\n     * Lecture \u00e0 partir de la configuration du cache actif.\n     *\n     * ```\n     * $cache->read('my_data');\n     *\n     * @param mixed|null $default\n     *\/\n    public function read(string $key, $default = null)\n    {\n        return $this->factory()->get($key, $default);\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function get($key, $default = null)\n    {\n        return $this->read($key, $default);\n    }\n\n    \/**\n     * Lire plusieurs cl\u00e9s du cache.\n     *\n     * ### Utilisation :\n     *\n     * Lecture de plusieurs cl\u00e9s \u00e0 partir de la configuration de cache active.\n     *\n     * ```\n     * $cache->readMany(['my_data_1', 'my_data_2]);\n     *\n     * @param mixed|null $default\n     *\/\n    public function readMany(iterable $keys, $default = null): iterable\n    {\n        return $this->factory()->getMultiple($keys, $default);\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getMultiple($keys, $default = null)\n    {\n        return $this->readMany($keys, $default);\n    }\n\n    \/**\n     * Incr\u00e9mente un nombre sous la cl\u00e9 et renvoie la valeur incr\u00e9ment\u00e9e.\n     *\n     * @param int $offset Combien ajouter\n     *\n     * @throws InvalidArgumentException Lorsque d\u00e9calage < 0\n     *\n     * @return false|int Nouvelle valeur, ou false si la donn\u00e9e n'existe pas, n'est pas un entier,\n     *                   ou si une erreur s'est produite lors de sa r\u00e9cup\u00e9ration.\n     *\/\n    public function increment(string $key, int $offset = 1)\n    {\n        if ($offset < 0) {\n            throw new InvalidArgumentException('Offset cannot be less than 0.');\n        }\n\n        return $this->factory()->increment($key, $offset);\n    }\n\n    \/**\n     * D\u00e9cr\u00e9menter un nombre sous la cl\u00e9 et renvoyer la valeur d\u00e9cr\u00e9ment\u00e9e.\n     *\n     * @param int $offset Combien soustraire\n     *\n     * @throws InvalidArgumentException lorsque d\u00e9calage < 0\n     *\n     * @return false|int Nouvelle valeur, ou false si la donn\u00e9e n'existe pas, n'est pas un entier,\n     *                   ou s'il y a eu une erreur lors de sa r\u00e9cup\u00e9ration\n     *\/\n    public function decrement(string $key, int $offset = 1)\n    {\n        if ($offset < 0) {\n            throw new InvalidArgumentException('Offset cannot be less than 0.');\n        }\n\n        return $this->factory()->decrement($key, $offset);\n    }\n\n    \/**\n     * Supprimer une cl\u00e9 du cache.\n     *\n     * ### Utilisation :\n     *\n     * Suppression de la configuration du cache actif.\n     *\n     * ```\n     * $cache->delete('my_data');\n     * ```\n     *\n     * @param mixed $key\n     *\/\n    public function delete($key): bool\n    {\n        return $this->factory()->delete($key);\n    }\n\n    \/**\n     * Supprimez de nombreuses cl\u00e9s du cache.\n     *\n     * ### Utilisation :\n     *\n     * Suppression de plusieurs cl\u00e9s de la configuration du cache actif.\n     *\n     * ```\n     * $cache->deleteMany(['my_data_1', 'my_data_2']);\n     * ```\n     *\n     * @param iterable $keys Array ou Traversable de cl\u00e9s de cache \u00e0 supprimer\n     *\n     * @throws InvalidArgumentException\n     *\/\n    public function deleteMany(iterable $keys): bool\n    {\n        return $this->factory()->deleteMultiple($keys);\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function deleteMultiple($keys)\n    {\n        return $this->deleteMany($keys);\n    }\n\n    \/**\n     * Supprimez toutes les cl\u00e9s du cache.\n     *\/\n    public function clear(): bool\n    {\n        return $this->factory()->clear();\n    }\n\n    \/**\n     * Supprimez toutes les cl\u00e9s du cache appartenant au m\u00eame groupe.\n     *\/\n    public function clearGroup(string $group): bool\n    {\n        return $this->factory()->clearGroup($group);\n    }\n\n    \/**\n     * R\u00e9activez la mise en cache.\n     *\n     * Si la mise en cache a \u00e9t\u00e9 d\u00e9sactiv\u00e9e avec Cache::disable() cette m\u00e9thode inversera cet effet.\n     *\/\n    public static function enable(): void\n    {\n        static::$_enabled = true;\n    }\n\n    \/**\n     * D\u00e9sactivez la mise en cache.\n     *\n     * Lorsqu'il est d\u00e9sactiv\u00e9, toutes les op\u00e9rations de cache renverront null.\n     *\/\n    public static function disable(): void\n    {\n        static::$_enabled = false;\n    }\n\n    \/**\n     * V\u00e9rifiez si la mise en cache est activ\u00e9e.\n     *\/\n    public static function enabled(): bool\n    {\n        return static::$_enabled;\n    }\n\n    \/**\n     * Fournit la possibilit\u00e9 de faire facilement la mise en cache de lecture.\n     *\n     * Lorsqu'elle est appel\u00e9e si la cl\u00e9 $ n'est pas d\u00e9finie dans $config, la fonction $callable\n     * sera invoqu\u00e9. Les r\u00e9sultats seront ensuite stock\u00e9s dans la configuration du cache\n     * \u00e0 la cl\u00e9.\n     *\n     * Exemples:\n     *\n     * En utilisant une Closure pour fournir des donn\u00e9es, supposez que `$this` est un objet Table :\n     *\n     * ```\n     * $resultats = $cache->remember('all_articles', function() {\n     * \t\treturn $this->find('all')->toArray();\n     * });\n     * ```\n     *\n     * @param string   $key      La cl\u00e9 de cache sur laquelle lire\/stocker les donn\u00e9es.\n     * @param callable $callable Le callback qui fournit des donn\u00e9es dans le cas o\u00f9\n     *                           la cl\u00e9 de cache est vide. Peut \u00eatre n'importe quel type appelable pris en charge par votre PHP.\n     *\n     * @return mixed Si la cl\u00e9 est trouv\u00e9e : les donn\u00e9es en cache.\n     *               Si la cl\u00e9 n'est pas trouv\u00e9e, la valeur renvoy\u00e9e par le callable.\n     *\/\n    public function remember(string $key, callable $callable)\n    {\n        $existing = $this->read($key);\n        if ($existing !== null) {\n            return $existing;\n        }\n        $results = $callable();\n        $this->write($key, $results);\n\n        return $results;\n    }\n\n    \/**\n     * \u00c9crivez les donn\u00e9es de la cl\u00e9 dans un moteur de cache si elles n'existent pas d\u00e9j\u00e0.\n     *\n     * ### Utilisation :\n     *\n     * \u00c9criture dans la configuration de cache active :\n     *\n     * ```\n     * $cache->add('cached_data', $data);\n     * ```\n     *\n     * @param mixed $value Donn\u00e9es \u00e0 mettre en cache - tout sauf une ressource.\n     *\/\n    public function add(string $key, $value): bool\n    {\n        if (is_resource($value)) {\n            return false;\n        }\n\n        return $this->factory()->add($key, $value);\n    }\n\n    \/**\n     * D\u00e9termine si un \u00e9l\u00e9ment est pr\u00e9sent dans le cache.\n     *\n     * REMARQUE : Il est recommand\u00e9 que has() ne soit utilis\u00e9 qu'\u00e0 des fins de type r\u00e9chauffement du cache\n     * et \u00e0 ne pas utiliser dans vos op\u00e9rations d'applications en direct pour get\/set, car cette m\u00e9thode\n     * est soumis \u00e0 une condition de concurrence o\u00f9 votre has() renverra vrai et imm\u00e9diatement apr\u00e8s,\n     * un autre script peut le supprimer, rendant l'\u00e9tat de votre application obsol\u00e8te.\n     *\n     * @param string $key La cl\u00e9 de l'\u00e9l\u00e9ment de cache.\n     *\n     * @throws \\Psr\\SimpleCache\\InvalidArgumentException DOIT \u00eatre lanc\u00e9 si la cha\u00eene $key n'est pas une valeur l\u00e9gale.\n     *\n     * @return bool\n     *\/\n    public function has($key)\n    {\n        return $this->factory()->has($key);\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,0,null,null,0,null,null,null,0,null,null,0,null,null,0,null,0,null,0,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null]},{"name":"src\\Cache\\Handlers\\BaseHandler.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Cache\\Handlers;\n\nuse BlitzPHP\\Cache\\CacheInterface;\nuse BlitzPHP\\Cache\\InvalidArgumentException;\nuse BlitzPHP\\Traits\\InstanceConfigTrait;\nuse BlitzPHP\\Utilities\\Helpers;\nuse Closure;\nuse DateInterval;\nuse Exception;\n\nabstract class BaseHandler implements CacheInterface\n{\n    use InstanceConfigTrait;\n\n    \/**\n     * @var string\n     *\/\n    protected const CHECK_KEY = 'key';\n\n    \/**\n     * @var string\n     *\/\n    protected const CHECK_VALUE = 'value';\n\n    \/**\n     * Caract\u00e8res r\u00e9serv\u00e9s qui ne peuvent pas \u00eatre utilis\u00e9s dans une cl\u00e9 ou une \u00e9tiquette. Peut \u00eatre remplac\u00e9 par le fichier config.\n     * From https:\/\/github.com\/symfony\/cache-contracts\/blob\/c0446463729b89dd4fa62e9aeecc80287323615d\/ItemInterface.php#L43\n     *\n     * @var string\n     *\/\n    protected static $reservedCharacters = '{}()\/\\@:';\n\n    \/**\n     * Pr\u00e9fixe \u00e0 appliquer aux cl\u00e9s de cache.\n     * Ne peut pas \u00eatre utilis\u00e9 par tous les gestionnaires.\n     *\n     * @var string\n     *\/\n    protected $prefix;\n\n    \/**\n     * La configuration de cache par d\u00e9faut est remplac\u00e9e dans la plupart des adaptateurs de cache. Ceux-ci sont\n     * les cl\u00e9s communes \u00e0 tous les adaptateurs. Si elle est remplac\u00e9e, cette propri\u00e9t\u00e9 n'est pas utilis\u00e9e.\n     *\n     * - `duration` Sp\u00e9cifiez combien de temps durent les \u00e9l\u00e9ments de cette configuration de cache.\n     * - `groups` Liste des groupes ou 'tags' associ\u00e9s \u00e0 chaque cl\u00e9 stock\u00e9e dans cette configuration.\n     * \t\t\tpratique pour supprimer un groupe complet du cache.\n     * - `prefix` Pr\u00e9fixe ajout\u00e9 \u00e0 toutes les entr\u00e9es. Bon pour quand vous avez besoin de partager un keyspace\n     * \t\t\tavec une autre configuration de cache ou une autre application.\n     * - `warnOnWriteFailures` Certains moteurs, tels que ApcuEngine, peuvent d\u00e9clencher des avertissements en cas d'\u00e9checs d'\u00e9criture.\n     *\n     * @var array<string, mixed>\n     *\/\n    protected $_defaultConfig = [\n        'duration'            => 3600,\n        'groups'              => [],\n        'prefix'              => 'blitz_',\n        'warnOnWriteFailures' => true,\n    ];\n\n    \/**\n     * Contient la cha\u00eene compil\u00e9e avec tous les groupes\n     * pr\u00e9fixes \u00e0 ajouter \u00e0 chaque cl\u00e9 dans ce moteur de cache\n     *\n     * @var string\n     *\/\n    protected $_groupPrefix = '';\n\n    \/**\n     * Initialiser le moteur de cache\n     *\n     * Appel\u00e9 automatiquement par le frontal du cache. Fusionner la configuration d'ex\u00e9cution avec les valeurs par d\u00e9faut\n     * Avant utilisation.\n     *\n     * @param array<string, mixed> $config Tableau associatif de param\u00e8tres pour le moteur\n     *\n     * @return bool Vrai si le moteur a \u00e9t\u00e9 initialis\u00e9 avec succ\u00e8s, faux sinon\n     *\/\n    public function init(array $config = []): bool\n    {\n        $this->setConfig($config);\n\n        if (! empty($this->_config['groups'])) {\n            sort($this->_config['groups']);\n            $this->_groupPrefix = str_repeat('%s_', count($this->_config['groups']));\n        }\n        if (! is_numeric($this->_config['duration'])) {\n            $this->_config['duration'] = strtotime($this->_config['duration']) - time();\n        }\n\n        return true;\n    }\n\n    \/**\n     * Modifie les caract\u00e8res reserv\u00e9s\n     *\/\n    public function setReservedCharacters(string $reservedCharacters)\n    {\n        self::$reservedCharacters = $reservedCharacters;\n    }\n\n    \/**\n     * Assurez-vous de la validit\u00e9 de la cl\u00e9 de cache donn\u00e9e.\n     *\n     * @throws InvalidArgumentException Quand la cl\u00e9 n'est pas valide\n     *\/\n    public function ensureValidKey(string $key): void\n    {\n        if (! is_string($key) || $key === '') {\n            throw new InvalidArgumentException('A cache key must be a non-empty string.');\n        }\n\n        $reserved = self::$reservedCharacters;\n        if ($reserved && strpbrk($key, $reserved) !== false) {\n            throw new InvalidArgumentException('Cache key contains reserved characters ' . $reserved);\n        }\n    }\n\n    \/**\n     * Assurez-vous de la validit\u00e9 du type d'argument et des cl\u00e9s de cache.\n     *\n     * @param iterable $iterable L'it\u00e9rable \u00e0 v\u00e9rifier.\n     * @param string   $check    Indique s'il faut v\u00e9rifier les cl\u00e9s ou les valeurs.\n     *\n     * @throws InvalidArgumentException\n     *\/\n    protected function ensureValidType($iterable, string $check = self::CHECK_VALUE): void\n    {\n        if (! is_iterable($iterable)) {\n            throw new InvalidArgumentException(sprintf(\n                'A cache %s must be either an array or a Traversable.',\n                $check === self::CHECK_VALUE ? 'key set' : 'set'\n            ));\n        }\n\n        foreach ($iterable as $key => $value) {\n            if ($check === self::CHECK_VALUE) {\n                $this->ensureValidKey($value);\n            } else {\n                $this->ensureValidKey($key);\n            }\n        }\n    }\n\n    \/**\n     * Obtenez un \u00e9l\u00e9ment du cache ou ex\u00e9cutez la fermeture donn\u00e9e et stockez le r\u00e9sultat.\n     *\n     * @param Closure $callback Valeur de retour du rappel\n     *\/\n    public function remember(string $key, int $ttl, Closure $callback)\n    {\n        $value = $this->get($key);\n\n        if ($value !== null) {\n            return $value;\n        }\n\n        $this->set($key, $value = $callback(), $ttl);\n\n        return $value;\n    }\n\n    \/**\n     * Supprime les \u00e9l\u00e9ments du magasin de cache correspondant \u00e0 un mod\u00e8le donn\u00e9.\n     *\n     * @param string $pattern Mod\u00e8le de style global des \u00e9l\u00e9ments du cache\n     *\n     * @throws Exception\n     *\/\n    public function deleteMatching(string $pattern)\n    {\n        throw new Exception('The deleteMatching method is not implemented.');\n    }\n\n    \/**\n     * Obtient plusieurs \u00e9l\u00e9ments de cache par leurs cl\u00e9s uniques.\n     *\n     * @param iterable $keys    Une liste de cl\u00e9s pouvant \u00eatre obtenues en une seule op\u00e9ration.\n     * @param mixed    $default Valeur par d\u00e9faut \u00e0 renvoyer pour les cl\u00e9s qui n'existent pas.\n     *\n     * @throws InvalidArgumentException Si $keys n'est ni un tableau ni un Traversable,\n     *                                  ou si l'une des cl\u00e9s n'a pas de valeur l\u00e9gale.\n     *\n     * @return iterable Une liste de paires cl\u00e9-valeur. Les cl\u00e9s de cache qui n'existent pas ou qui sont obsol\u00e8tes auront $default comme valeur.\n     *\/\n    public function getMultiple($keys, $default = null): iterable\n    {\n        $this->ensureValidType($keys);\n\n        $results = [];\n\n        foreach ($keys as $key) {\n            $results[$key] = $this->get($key, $default);\n        }\n\n        return $results;\n    }\n\n    \/**\n     * Persiste un ensemble de paires cl\u00e9 => valeur dans le cache, avec un TTL facultatif.\n     *\n     * @param iterable              $values Une liste de paires cl\u00e9 => valeur pour une op\u00e9ration sur plusieurs ensembles.\n     * @param DateInterval|int|null $ttl    Facultatif. La valeur TTL de cet \u00e9l\u00e9ment. Si aucune valeur n'est envoy\u00e9e et\n     *                                      le pilote prend en charge TTL, la biblioth\u00e8que peut d\u00e9finir une valeur par d\u00e9faut\n     *                                      pour cela ou laissez le conducteur s'en occuper.\n     *\n     * @throws InvalidArgumentException Si $values n'est ni un tableau ni un Traversable,\n     *                                  ou si l'une des valeurs $ n'est pas une valeur l\u00e9gale.\n     *\n     * @return bool Vrai en cas de succ\u00e8s et faux en cas d'\u00e9chec.\n     *\/\n    public function setMultiple($values, $ttl = null): bool\n    {\n        $this->ensureValidType($values, self::CHECK_KEY);\n\n        if ($ttl !== null) {\n            $restore = $this->getConfig('duration');\n            $this->setConfig('duration', $ttl);\n        }\n\n        try {\n            foreach ($values as $key => $value) {\n                $success = $this->set($key, $value);\n                if ($success === false) {\n                    return false;\n                }\n            }\n\n            return true;\n        } finally {\n            if (isset($restore)) {\n                $this->setConfig('duration', $restore);\n            }\n        }\n    }\n\n    \/**\n     * Supprime plusieurs \u00e9l\u00e9ments du cache sous forme de liste\n     *\n     * Il s'agit d'une tentative de meilleur effort. Si la suppression d'un \u00e9l\u00e9ment\n     * cr\u00e9er une erreur, elle sera ignor\u00e9e et tous les \u00e9l\u00e9ments seront\n     * \u00eatre tent\u00e9.\n     *\n     * @param iterable $keys Une liste de cl\u00e9s bas\u00e9es sur des cha\u00eenes \u00e0 supprimer.\n     *\n     * @throws InvalidArgumentException Si $keys n'est ni un tableau ni un Traversable,\n     *                                  ou si l'une des cl\u00e9s $ n'a pas de valeur l\u00e9gale.\n     *\n     * @return bool Vrai si les \u00e9l\u00e9ments ont \u00e9t\u00e9 supprim\u00e9s avec succ\u00e8s. Faux s'il y a eu une erreur.\n     *\/\n    public function deleteMultiple($keys): bool\n    {\n        $this->ensureValidType($keys);\n\n        $result = true;\n\n        foreach ($keys as $key) {\n            if (! $this->delete($key)) {\n                $result = false;\n            }\n        }\n\n        return $result;\n    }\n\n    \/**\n     * D\u00e9termine si un \u00e9l\u00e9ment est pr\u00e9sent dans le cache.\n     *\n     * REMARQUE : Il est recommand\u00e9 que has() ne soit utilis\u00e9 qu'\u00e0 des fins de type r\u00e9chauffement du cache\n     * et \u00e0 ne pas utiliser dans vos op\u00e9rations d'applications en direct pour get\/set, car cette m\u00e9thode\n     * est soumis \u00e0 une condition de concurrence o\u00f9 votre has() renverra vrai et imm\u00e9diatement apr\u00e8s,\n     * un autre script peut le supprimer, rendant l'\u00e9tat de votre application obsol\u00e8te.\n     *\n     * @param mixed $key\n     *\n     * @throws InvalidArgumentException Si la cha\u00eene $key n'est pas une valeur l\u00e9gale.\n     *\/\n    public function has($key): bool\n    {\n        return $this->get($key) !== null;\n    }\n\n    \/**\n     * R\u00e9cup\u00e8re la valeur d'une cl\u00e9 donn\u00e9e dans le cache.\n     *\n     * @param mixed      $key\n     * @param mixed|null $default\n     *\/\n    abstract public function get($key, $default = null);\n\n    \/**\n     * Persiste les donn\u00e9es dans le cache, r\u00e9f\u00e9renc\u00e9es de mani\u00e8re unique par la cl\u00e9 donn\u00e9e avec un temps TTL d'expiration facultatif.\n     *\n     * @param DateInterval|int|null $ttl   Facultatif. La valeur TTL de cet \u00e9l\u00e9ment. Si aucune valeur n'est envoy\u00e9e et\n     *                                     le pilote prend en charge TTL, la biblioth\u00e8que peut d\u00e9finir une valeur par d\u00e9faut\n     *                                     pour cela ou laissez le conducteur s'en occuper.\n     * @param mixed                 $key\n     * @param mixed                 $value\n     *\n     * @return bool Vrai en cas de succ\u00e8s et faux en cas d'\u00e9chec.\n     *\/\n    abstract public function set($key, $value, $ttl = null): bool;\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    abstract public function increment(string $key, int $offset = 1);\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    abstract public function decrement(string $key, int $offset = 1);\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    abstract public function delete($key): bool;\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    abstract public function clear(): bool;\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function add(string $key, $value): bool\n    {\n        $cachedValue = $this->get($key);\n        if ($cachedValue === null) {\n            return $this->set($key, $value);\n        }\n\n        return false;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    abstract public function clearGroup(string $group): bool;\n\n    \/**\n     * Effectue toute initialisation pour chaque groupe est n\u00e9cessaire\n     * et renvoie la \"valeur du groupe\" pour chacun d'eux, c'est\n     * le jeton repr\u00e9sentant chaque groupe dans la cl\u00e9 de cache\n     *\n     * @return string[]\n     *\/\n    public function groups(): array\n    {\n        return $this->_config['groups'];\n    }\n\n    \/**\n     * G\u00e9n\u00e8re une cl\u00e9 pour l'utilisation du backend du cache.\n     *\n     * Si la cl\u00e9 demand\u00e9e est valide, la valeur du pr\u00e9fixe de groupe et le pr\u00e9fixe du moteur sont appliqu\u00e9s.\n     * Les espaces blancs dans les cl\u00e9s seront remplac\u00e9s.\n     *\n     * @param string $key la cl\u00e9 transmise\n     *\n     * @throws InvalidArgumentException Si la valeur de la cl\u00e9 n'est pas valide.\n     *\n     * @return string Cl\u00e9 pr\u00e9fix\u00e9e avec des caract\u00e8res potentiellement dangereux remplac\u00e9s.\n     *\/\n    protected function _key($key): string\n    {\n        $this->ensureValidKey($key);\n\n        $prefix = '';\n        if ($this->_groupPrefix) {\n            $prefix = md5(implode('_', $this->groups()));\n        }\n        $key = preg_replace('\/[\\s]+\/', '_', $key);\n\n        return $this->_config['prefix'] . $prefix . $key;\n    }\n\n    \/**\n     * Les moteurs de cache peuvent d\u00e9clencher des avertissements s'ils rencontrent des pannes pendant le fonctionnement,\n     * si l'option warnOnWriteFailures est d\u00e9finie sur true.\n     *\/\n    protected function warning(string $message): void\n    {\n        if ($this->getConfig('warnOnWriteFailures') !== true) {\n            return;\n        }\n\n        Helpers::triggerWarning($message);\n    }\n\n    \/**\n     * Convertir les diff\u00e9rentes expressions d'une valeur TTL en dur\u00e9e en secondes\n     *\n     * @param DateInterval|int|null $ttl La valeur TTL de cet \u00e9l\u00e9ment. Si null est envoy\u00e9,\n     *                                   La dur\u00e9e par d\u00e9faut du conducteur sera utilis\u00e9e.\n     *\/\n    protected function duration($ttl): int\n    {\n        if ($ttl === null) {\n            return $this->_config['duration'];\n        }\n        if (is_int($ttl)) {\n            return $ttl;\n        }\n        if ($ttl instanceof DateInterval) {\n            return (int) $ttl->format('%s');\n        }\n\n        throw new InvalidArgumentException('TTL values must be one of null, int, \\DateInterval');\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,0,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,0,null,null,null,null,0,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null]},{"name":"src\\Cache\\Handlers\\Dummy.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Cache\\Handlers;\n\n\/**\n * Moteur de cache nul, toutes les op\u00e9rations semblent fonctionner, mais ne font rien.\n *\n * Ceci est utilis\u00e9 en interne lorsque Cache::disable() a \u00e9t\u00e9 appel\u00e9.\n *\/\nclass Dummy extends BaseHandler\n{\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function isSupported(): bool\n    {\n        return true;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function init(array $config = []): bool\n    {\n        return true;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function set($key, $value, $ttl = null): bool\n    {\n        return true;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function setMultiple($values, $ttl = null): bool\n    {\n        return true;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function get($key, $default = null)\n    {\n        return $default;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getMultiple($keys, $default = null): iterable\n    {\n        return [];\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function increment(string $key, int $offset = 1)\n    {\n        return 1;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function decrement(string $key, int $offset = 1)\n    {\n        return 0;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function delete($key): bool\n    {\n        return true;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function deleteMultiple($keys): bool\n    {\n        return true;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function clear(): bool\n    {\n        return true;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function clearGroup(string $group): bool\n    {\n        return true;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null]},{"name":"src\\Cache\\Handlers\\File.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Cache\\Handlers;\n\nuse BlitzPHP\\Cache\\InvalidArgumentException;\nuse CallbackFilterIterator;\nuse Exception;\nuse FilesystemIterator;\nuse LogicException;\nuse RecursiveDirectoryIterator;\nuse RecursiveIteratorIterator;\nuse SplFileInfo;\nuse SplFileObject;\n\nclass File extends BaseHandler\n{\n    \/**\n     * Instance de la classe SplFileObject\n     *\n     * @var SplFileObject|null\n     *\/\n    protected $_File;\n\n    \/**\n     * La configuration par d\u00e9faut utilis\u00e9e sauf si elle est remplac\u00e9e par la configuration d'ex\u00e9cution\n     *\n     * - `duration` Sp\u00e9cifiez combien de temps durent les \u00e9l\u00e9ments de cette configuration de cache.\n     * - `groups` Liste des groupes ou 'tags' associ\u00e9s \u00e0 chaque cl\u00e9 stock\u00e9e dans cette configuration.\n     * \t\t\tpratique pour supprimer un groupe complet du cache.\n     * - `lock` Utilis\u00e9 par FileCache. Les fichiers doivent-ils \u00eatre verrouill\u00e9s avant d'y \u00e9crire ?\n     * - `mask` Le masque utilis\u00e9 pour les fichiers cr\u00e9\u00e9s\n     * - `path` Chemin d'acc\u00e8s o\u00f9 les fichiers cache doivent \u00eatre enregistr\u00e9s. Par d\u00e9faut, le r\u00e9pertoire temporaire du syst\u00e8me.\n     * - `prefix` Pr\u00e9fix\u00e9 \u00e0 toutes les entr\u00e9es. Bon pour quand vous avez besoin de partager un keyspace\n     * \t\t\tavec une autre configuration de cache ou une autre application. cache::gc d'\u00eatre appel\u00e9 automatiquement.\n     * - `serialize` Les objets du cache doivent-ils \u00eatre s\u00e9rialis\u00e9s en premier.\n     *\n     * @var array<string, mixed>\n     *\/\n    protected $_defaultConfig = [\n        'duration'  => 3600,\n        'groups'    => [],\n        'lock'      => true,\n        'mask'      => 0664,\n        'path'      => null,\n        'prefix'    => 'blitz_',\n        'serialize' => true,\n    ];\n\n    \/**\n     * Vrai sauf si FileEngine :: __active(); \u00e9choue\n     *\n     * @var bool\n     *\/\n    protected $_init = true;\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function init(array $config = []): bool\n    {\n        parent::init($config);\n\n        if ($this->_config['path'] === null) {\n            $this->_config['path'] = sys_get_temp_dir() . DIRECTORY_SEPARATOR . 'blitz_cache' . DIRECTORY_SEPARATOR;\n        }\n        if (substr($this->_config['path'], -1) !== DIRECTORY_SEPARATOR) {\n            $this->_config['path'] .= DIRECTORY_SEPARATOR;\n        }\n        if ($this->_groupPrefix) {\n            $this->_groupPrefix = str_replace('_', DIRECTORY_SEPARATOR, $this->_groupPrefix);\n        }\n\n        return $this->_active();\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function set($key, $value, $ttl = null): bool\n    {\n        if ($value === '' || ! $this->_init) {\n            return false;\n        }\n\n        $key = $this->_key($key);\n\n        if ($this->_setKey($key, true) === false) {\n            return false;\n        }\n\n        if (! empty($this->_config['serialize'])) {\n            $value = serialize($value);\n        }\n\n        $expires  = time() + $this->duration($ttl);\n        $contents = implode('', [$expires, PHP_EOL, $value, PHP_EOL]);\n\n        if ($this->_config['lock']) {\n            \/** @psalm-suppress PossiblyNullReference *\/\n            $this->_File->flock(LOCK_EX);\n        }\n\n        \/** @psalm-suppress PossiblyNullReference *\/\n        $this->_File->rewind();\n        $success = $this->_File->ftruncate(0)\n            && $this->_File->fwrite($contents)\n            && $this->_File->fflush();\n\n        if ($this->_config['lock']) {\n            $this->_File->flock(LOCK_UN);\n        }\n        $this->_File = null;\n\n        return $success;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function get($key, $default = null)\n    {\n        $key = $this->_key($key);\n\n        if (! $this->_init || $this->_setKey($key) === false) {\n            return $default;\n        }\n\n        if ($this->_config['lock']) {\n            \/** @psalm-suppress PossiblyNullReference *\/\n            $this->_File->flock(LOCK_SH);\n        }\n\n        \/** @psalm-suppress PossiblyNullReference *\/\n        $this->_File->rewind();\n        $time      = time();\n        $cachetime = (int) $this->_File->current();\n\n        if ($cachetime < $time) {\n            if ($this->_config['lock']) {\n                $this->_File->flock(LOCK_UN);\n            }\n\n            return $default;\n        }\n\n        $data = '';\n        $this->_File->next();\n\n        while ($this->_File->valid()) {\n            \/** @psalm-suppress PossiblyInvalidOperand *\/\n            $data .= $this->_File->current();\n            $this->_File->next();\n        }\n\n        if ($this->_config['lock']) {\n            $this->_File->flock(LOCK_UN);\n        }\n\n        $data = trim($data);\n\n        if ($data !== '' && ! empty($this->_config['serialize'])) {\n            $data = unserialize($data);\n        }\n\n        return $data;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function delete($key): bool\n    {\n        $key = $this->_key($key);\n\n        if ($this->_setKey($key) === false || ! $this->_init) {\n            return false;\n        }\n\n        \/** @psalm-suppress PossiblyNullReference *\/\n        $path        = $this->_File->getRealPath();\n        $this->_File = null;\n\n        if ($path === false) {\n            return false;\n        }\n\n        \/\/ phpcs:disable\n        return @unlink($path);\n        \/\/ phpcs:enable\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function clear(): bool\n    {\n        if (! $this->_init) {\n            return false;\n        }\n        $this->_File = null;\n\n        $this->_clearDirectory($this->_config['path']);\n\n        $directory = new RecursiveDirectoryIterator(\n            $this->_config['path'],\n            FilesystemIterator::SKIP_DOTS\n        );\n        $contents = new RecursiveIteratorIterator(\n            $directory,\n            RecursiveIteratorIterator::SELF_FIRST\n        );\n        $cleared = [];\n        \/** @var SplFileInfo $fileInfo *\/\n        foreach ($contents as $fileInfo) {\n            if ($fileInfo->isFile()) {\n                unset($fileInfo);\n\n                continue;\n            }\n\n            $realPath = $fileInfo->getRealPath();\n            if (! $realPath) {\n                unset($fileInfo);\n\n                continue;\n            }\n\n            $path = $realPath . DIRECTORY_SEPARATOR;\n            if (! in_array($path, $cleared, true)) {\n                $this->_clearDirectory($path);\n                $cleared[] = $path;\n            }\n\n            \/\/ les it\u00e9rateurs internes possibles doivent \u00e9galement \u00eatre d\u00e9sactiv\u00e9s pour que les verrous sur les parents soient lib\u00e9r\u00e9s\n            unset($fileInfo);\n        }\n\n        \/\/ la d\u00e9sactivation des it\u00e9rateurs aide \u00e0 lib\u00e9rer les verrous possibles dans certains environnements,\n        \/\/ ce qui pourrait sinon faire \u00e9chouer `rmdir()`\n        unset($directory, $contents);\n\n        return true;\n    }\n\n    \/**\n     * Utilis\u00e9 pour effacer un r\u00e9pertoire de fichiers correspondants.\n     *\/\n    protected function _clearDirectory(string $path): void\n    {\n        if (! is_dir($path)) {\n            return;\n        }\n\n        $dir = dir($path);\n        if (! $dir) {\n            return;\n        }\n\n        $prefixLength = strlen($this->_config['prefix']);\n\n        while (($entry = $dir->read()) !== false) {\n            if (substr($entry, 0, $prefixLength) !== $this->_config['prefix']) {\n                continue;\n            }\n\n            try {\n                $file = new SplFileObject($path . $entry, 'r');\n            } catch (Exception $e) {\n                continue;\n            }\n\n            if ($file->isFile()) {\n                $filePath = $file->getRealPath();\n                unset($file);\n\n                \/\/ phpcs:disable\n                @unlink($filePath);\n                \/\/ phpcs:enable\n            }\n        }\n\n        $dir->close();\n    }\n\n    \/**\n     * Pas implement\u00e9\n     *\n     * @throws LogicException\n     *\/\n    public function decrement(string $key, int $offset = 1)\n    {\n        throw new LogicException('Files cannot be atomically decremented.');\n    }\n\n    \/**\n     * Pas implement\u00e9\n     *\n     * @throws LogicException\n     *\/\n    public function increment(string $key, int $offset = 1)\n    {\n        throw new LogicException('Files cannot be atomically incremented.');\n    }\n\n    \/**\n     * D\u00e9finit la cl\u00e9 de cache actuelle que cette classe g\u00e8re et cr\u00e9e un SplFileObject inscriptible\n     * pour le fichier cache auquel la cl\u00e9 fait r\u00e9f\u00e9rence.\n     *\n     * @param bool $createKey Whether the key should be created if it doesn't exists, or not\n     *\n     * @return bool true if the cache key could be set, false otherwise\n     *\/\n    protected function _setKey(string $key, bool $createKey = false): bool\n    {\n        $groups = null;\n        if ($this->_groupPrefix) {\n            $groups = vsprintf($this->_groupPrefix, $this->groups());\n        }\n        $dir = $this->_config['path'] . $groups;\n\n        if (! is_dir($dir)) {\n            mkdir($dir, 0775, true);\n        }\n\n        $path = new SplFileInfo($dir . $key);\n\n        if (! $createKey && ! $path->isFile()) {\n            return false;\n        }\n        if (\n            empty($this->_File)\n            || $this->_File->getBasename() !== $key\n            || $this->_File->valid() === false\n        ) {\n            $exists = is_file($path->getPathname());\n\n            try {\n                $this->_File = $path->openFile('c+');\n            } catch (Exception $e) {\n                trigger_error($e->getMessage(), E_USER_WARNING);\n\n                return false;\n            }\n            unset($path);\n\n            if (! $exists && ! chmod($this->_File->getPathname(), (int) $this->_config['mask'])) {\n                trigger_error(sprintf(\n                    'Could not apply permission mask \"%s\" on cache file \"%s\"',\n                    $this->_File->getPathname(),\n                    $this->_config['mask']\n                ), E_USER_WARNING);\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * D\u00e9terminer si le r\u00e9pertoire de cache est accessible en \u00e9criture\n     *\/\n    protected function _active(): bool\n    {\n        $dir     = new SplFileInfo($this->_config['path']);\n        $path    = $dir->getPathname();\n        $success = true;\n        if (! is_dir($path)) {\n            \/\/ phpcs:disable\n            $success = @mkdir($path, 0775, true);\n            \/\/ phpcs:enable\n        }\n\n        $isWritableDir = ($dir->isDir() && $dir->isWritable());\n        if (! $success || ($this->_init && ! $isWritableDir)) {\n            $this->_init = false;\n            trigger_error(sprintf(\n                '%s is not writable',\n                $this->_config['path']\n            ), E_USER_WARNING);\n        }\n\n        return $success;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    protected function _key($key): string\n    {\n        $key = parent::_key($key);\n\n        if (preg_match('\/[\\\/\\\\<>?:|*\"]\/', $key)) {\n            throw new InvalidArgumentException(\n                \"Cache key `{$key}` contains invalid characters. \" .\n                'You cannot use \/, \\\\, <, >, ?, :, |, *, or \" in cache keys.'\n            );\n        }\n\n        return $key;\n    }\n\n    \/**\n     * Supprime r\u00e9cursivement tous les fichiers sous n'importe quel r\u00e9pertoire nomm\u00e9 $group\n     *\/\n    public function clearGroup(string $group): bool\n    {\n        $this->_File = null;\n\n        $prefix = (string) $this->_config['prefix'];\n\n        $directoryIterator = new RecursiveDirectoryIterator($this->_config['path']);\n        $contents          = new RecursiveIteratorIterator(\n            $directoryIterator,\n            RecursiveIteratorIterator::CHILD_FIRST\n        );\n        $filtered = new CallbackFilterIterator(\n            $contents,\n            static function (SplFileInfo $current) use ($group, $prefix) {\n                if (! $current->isFile()) {\n                    return false;\n                }\n\n                $hasPrefix = $prefix === ''\n                    || strpos($current->getBasename(), $prefix) === 0;\n                if ($hasPrefix === false) {\n                    return false;\n                }\n\n                $pos = strpos(\n                    $current->getPathname(),\n                    DIRECTORY_SEPARATOR . $group . DIRECTORY_SEPARATOR\n                );\n\n                return $pos !== false;\n            }\n        );\n\n        foreach ($filtered as $object) {\n            $path = $object->getPathname();\n            unset($object);\n            \/\/ phpcs:ignore\n            @unlink($path);\n        }\n\n        \/\/ unsetting iterators helps releasing possible locks in certain environments,\n        \/\/ which could otherwise make `rmdir()` fail\n        unset($directoryIterator, $contents, $filtered);\n\n        return true;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,0,null,null,0,0,null,null,null,0,null,null,null,0,null,null,0,null,null,0,null,0,null,0,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,0,null,null,null,0,0,0,null,null,null,0,null,null,0,null,null,0,0,null,null,null,0,0,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,0,null,null,null,0,0,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,0,null,null,null,0,0,null,null,null,0,null,0,null,null,0,null,0,null,0,null,null,0,null,0,0,null,null,null,0,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,null,0,null,null,null,0,null,null,null,0,null,0,null,null,null,0,0,null,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,0,null,null,0,null,0,null,0,null,0,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,0,0,0,null,null,0,null,null,null,0,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,0,null,null,null,null,0,null,null,null,0,null,0,null,null,null,null,null,0,null,0,null,0,null,null,0,0,null,0,null,null,null,null,0,null,0,null,null,null]},{"name":"src\\Config\\Config.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Config;\n\nuse BlitzPHP\\Exceptions\\ConfigException;\nuse BlitzPHP\\Traits\\SingletonTrait;\nuse BlitzPHP\\Utilities\\Helpers;\nuse InvalidArgumentException;\nuse Nette\\Schema\\Expect;\nuse Nette\\Schema\\Schema;\n\nclass Config\n{\n    use SingletonTrait;\n\n    \/**\n     * @var Configurator\n     *\/\n    private $configurator;\n\n    \/**\n     * Fichier de configuration d\u00e9j\u00e0 charg\u00e9\n     *\n     * @var array\n     *\/\n    private static $loaded = [];\n\n    protected function __construct()\n    {\n        $this->configurator = new Configurator();\n    }\n\n    \/**\n     * Renvoyer une configuration de l'application\n     *\n     * @return mixed\n     *\/\n    public static function get(string $key)\n    {\n        $configurator = self::instance()->configurator;\n\n        if ($configurator->exists($key)) {\n            return $configurator->get($key);\n        }\n\n        $config = explode('.', $key);\n        self::load($config[0]);\n\n        return self::instance()->configurator->get(implode('.', $config));\n    }\n\n    \/**\n     * D\u00e9finir une configuration de l'application\n     *\n     * @param mixed $value\n     *\/\n    public static function set(string $key, $value)\n    {\n        self::instance()->configurator->set($key, $value);\n    }\n\n    \/**\n     * Config constructor.\n     *\/\n    public static function init()\n    {\n        self::load(['app']);\n\n        self::instance()->initialize();\n    }\n\n    \/**\n     * Charger la configuration sp\u00e9cifique dans le scoope\n     *\n     * @param string|string[] $config\n     *\/\n    public static function load($config, ?string $file = null, ?Schema $schema = null)\n    {\n        if (is_array($config)) {\n            foreach ($config as $key => $value) {\n                if (! is_string($value) || empty($value)) {\n                    continue;\n                }\n                if (is_string($key)) {\n                    $file = $value;\n                    $conf = $key;\n                } else {\n                    $file = null;\n                    $conf = $value;\n                }\n                self::load($conf, $file);\n            }\n        } elseif (is_string($config) && ! isset(self::$loaded[$config])) {\n            if (empty($file)) {\n                $file = self::path($config);\n            }\n\n            $configurations = [];\n            if (file_exists($file) && ! in_array($file, get_included_files(), true)) {\n                $configurations = (array) require $file;\n            }\n\n            if (empty($schema)) {\n                $schema = self::schema($config);\n            }\n\n            self::instance()->configurator->addSchema($config, $schema, false);\n            self::instance()->configurator->merge([$config => (array) $configurations]);\n\n            self::$loaded[$config] = $file;\n        }\n    }\n\n    \/**\n     * Affiche l'exception d\u00fb \u00e0 la mauvaise definition d'une configuration\n     *\n     * @param array|string $accepts_values\n     * @param string       $group          (app, data, database, etc.)\n     *\/\n    public static function exceptBadConfigValue(string $config_key, $accepts_values, string $group)\n    {\n        if (is_array($accepts_values)) {\n            $accepts_values = '(Accept values: ' . implode('\/', $accepts_values) . ')';\n        } elseif (! is_string($accepts_values)) {\n            throw new InvalidArgumentException('Misuse of the method ' . __METHOD__);\n        }\n\n        throw new ConfigException(\"The '{$group}.{$config_key} configuration is not set correctly. {$accepts_values} \\n Please edit '{\" . self::path($group) . \"}' file to correct it\");\n    }\n\n    \/**\n     * Recherche l'URL de base de l'application independamment de la configuration de l'utilisateur\n     *\/\n    public static function findBaseUrl(): string\n    {\n        if (isset($_SERVER['SERVER_ADDR'])) {\n            $server_addr = $_SERVER['HTTP_HOST'] ?? ((strpos($_SERVER['SERVER_ADDR'], ':') !== false) ? '[' . $_SERVER['SERVER_ADDR'] . ']' : $_SERVER['SERVER_ADDR']);\n\n            if (isset($_SERVER['SERVER_PORT'])) {\n                $server_addr .= ':' . ((! preg_match('#:' . $_SERVER['SERVER_PORT'] . '$#', $server_addr)) ? $_SERVER['SERVER_PORT'] : '80');\n            }\n\n            if (\n                (! empty($_SERVER['HTTPS']) && strtolower($_SERVER['HTTPS']) !== 'off')\n                || (isset($_SERVER['HTTP_X_FORWARDED_PROTO']) && strtolower($_SERVER['HTTP_X_FORWARDED_PROTO']) === 'https')\n                || (! empty($_SERVER['HTTP_FRONT_END_HTTPS']) && strtolower($_SERVER['HTTP_FRONT_END_HTTPS']) !== 'off')\n            ) {\n                $base_url = 'https';\n            } else {\n                $base_url = 'http';\n            }\n\n            $base_url .= ':\/\/' . $server_addr . dirname(substr($_SERVER['SCRIPT_NAME'], 0, strpos($_SERVER['SCRIPT_NAME'], basename($_SERVER['SCRIPT_FILENAME']))));\n        } else {\n            $base_url = 'http:\/\/localhost:' . ($_SERVER['SERVER_PORT'] ?? '80');\n        }\n\n        return $base_url;\n    }\n\n    \/**\n     * Renvoie le chemin du fichier d'un groupe de configuration donn\u00e9\n     *\/\n    public static function path(string $path): string\n    {\n        $_config_file = [\n            'app'      => CONFIG_PATH . 'app.php',\n            'autoload' => CONFIG_PATH . 'autoload.php',\n            'data'     => CONFIG_PATH . 'data.php',\n            'database' => CONFIG_PATH . 'database.php',\n            'layout'   => CONFIG_PATH . 'layout.php',\n\n            'email' => CONFIG_PATH . 'email.php',\n            'rest'  => CONFIG_PATH . 'rest.php',\n        ];\n        $path = preg_replace('#\\.php$#', '', $path);\n\n        if (isset($_config_file[$path])) {\n            return $_config_file[$path];\n        }\n\n        return CONFIG_PATH . $path . '.php';\n    }\n\n    \/**\n     * Retrouve le schema de configuration d'un groupe\n     *\/\n    public static function schema(string $key): Schema\n    {\n        $file        = 'schemas' . DS . Helpers::ensureExt($key . '.config', 'php');\n        $syst_schema = SYST_PATH . 'Constants' . DS . $file;\n        $app_schema  = CONFIG_PATH . $file;\n\n        if (file_exists($syst_schema)) {\n            $schema = require $syst_schema;\n        } elseif (file_exists($app_schema)) {\n            $schema = require $app_schema;\n        }\n\n        if (empty($schema) || ! ($schema instanceof Schema)) {\n            $schema = Expect::mixed();\n        }\n\n        return $schema;\n    }\n\n    \/**\n     * Initialiser la configuration du syst\u00e8me avec les donn\u00e9es des fichier de configuration\n     *\/\n    private function initialize()\n    {\n        ini_set('log_errors', 1);\n        ini_set('error_log', LOG_PATH . 'blitz-logs');\n\n        $this->initializeURL();\n        $this->initializeEnvironment();\n        $this->initializeDebugbar();\n    }\n\n    \/**\n     * Initialise l'URL\n     *\/\n    private function initializeURL()\n    {\n        if (! $this->configurator->exists('app.base_url')) {\n            $config = 'auto';\n        } else {\n            $config = $this->configurator->get('app.base_url');\n        }\n\n        if ($config === 'auto' || empty($config)) {\n            $config = rtrim(str_replace('\\\\', '\/', self::findBaseUrl()), '\/');\n        }\n\n        $this->configurator->set('app.base_url', $config);\n    }\n\n    \/**\n     * Initialise l'environnement d'execution de l'application\n     *\/\n    private function initializeEnvironment()\n    {\n        $environment = $config = $this->configurator->get('app.environment');\n\n        if ($config === 'auto') {\n            $config = is_online() ? 'production' : 'development';\n        } elseif ($config === 'dev') {\n            $config = 'development';\n        } elseif ($config === 'prod') {\n            $config = 'production';\n        }\n\n        if ($config !== $environment) {\n            $this->configurator->set('app.environment', $config);\n        }\n\n        switch ($config) {\n            case 'development':\n                error_reporting(-1);\n                ini_set('display_errors', 1);\n                break;\n\n            case 'test':\n            case 'production':\n                ini_set('display_errors', 0);\n                error_reporting(E_ALL & ~E_NOTICE & ~E_DEPRECATED & ~E_STRICT & ~E_USER_NOTICE & ~E_USER_DEPRECATED);\n                break;\n\n            default:\n                self::exceptBadConfigValue('environment', ['development', 'production', 'test', 'auto'], 'app');\n        }\n    }\n\n    \/**\n     * Initialise les param\u00e8tres de la bar de debug\n     *\/\n    private function initializeDebugbar()\n    {\n        if (! $this->configurator->exists('app.show_debugbar')) {\n            $config = 'auto';\n        } else {\n            $config = $this->configurator->get('app.show_debugbar');\n        }\n\n        if (! in_array($config, ['auto', true, false], true)) {\n            self::exceptBadConfigValue('show_debugbar', ['auto', true, false], 'app');\n        }\n        if ($config === 'auto') {\n            $this->configurator->set('app.show_debugbar', ! is_online());\n        }\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,2,null,null,2,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,0,null,0,0,null,0,null,null,null,0,null,null,0,null,0,null,null,null,0,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,0,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,null,null,0,null,null,null,null,null,null,null,0,0,0,null,null,0,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,0,null,0,0,0,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,0,null,0,null,0,null,null,null,0,null,null,null,null,0,0,0,null,null,null,0,0,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,null,0,null,null,null,null]},{"name":"src\\Config\\Configurator.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Config;\n\nuse BlitzPHP\\Exceptions\\ConfigException;\nuse Dflydev\\DotAccessData\\Data;\nuse Dflydev\\DotAccessData\\Exception\\DataException;\nuse Dflydev\\DotAccessData\\Exception\\InvalidPathException;\nuse Dflydev\\DotAccessData\\Exception\\MissingPathException;\nuse Nette\\Schema\\Expect;\nuse Nette\\Schema\\Processor;\nuse Nette\\Schema\\Schema;\nuse Nette\\Schema\\ValidationException;\nuse stdClass;\n\n\/**\n * @credit league\/config (c) Colin O'Dell <colinodell@gmail.com>\n *\/\nfinal class Configurator\n{\n    \/**\n     * @psalm-readonly\n     *\/\n    private Data $userConfig;\n\n    \/**\n     * @var array<string, Schema>\n     *\n     * @psalm-allow-private-mutation\n     *\/\n    private array $configSchemas = [];\n\n    \/**\n     * @psalm-allow-private-mutation\n     *\/\n    private ?Data $finalConfig = null;\n\n    \/**\n     * @var array<string, mixed>\n     *\n     * @psalm-allow-private-mutation\n     *\/\n    private array $cache = [];\n\n    \/**\n     * @param array<string, Schema> $baseSchemas\n     *\/\n    public function __construct(array $baseSchemas = [])\n    {\n        $this->configSchemas = $baseSchemas;\n        $this->userConfig    = new Data();\n    }\n\n    \/**\n     * Enregistre un nouveau sch\u00e9ma de configuration \u00e0 la cl\u00e9 de niveau sup\u00e9rieur donn\u00e9e\n     *\n     * @psalm-allow-private-mutation\n     *\/\n    public function addSchema(string $key, Schema $schema, bool $overwrite = true): void\n    {\n        $this->invalidate();\n\n        if ($overwrite || ! isset($this->configSchemas[$key])) {\n            $this->configSchemas[$key] = $schema;\n        }\n    }\n\n    \/**\n     * @psalm-allow-private-mutation\n     *\/\n    public function merge(array $config = []): void\n    {\n        $this->invalidate();\n\n        $this->userConfig->import($config, Data::REPLACE);\n    }\n\n    \/**\n     * @psalm-allow-private-mutation\n     *\n     * @param mixed $value\n     *\/\n    public function set(string $key, $value): void\n    {\n        $this->invalidate();\n\n        try {\n            $this->userConfig->set($key, $value);\n        } catch (DataException $ex) {\n            throw new UnknownOptionException($ex->getMessage(), $key, (int) $ex->getCode(), $ex);\n        }\n    }\n\n    \/**\n     * @psalm-external-mutation-free\n     *\/\n    public function get(string $key)\n    {\n        if ($this->finalConfig === null) {\n            $this->finalConfig = $this->build();\n        } elseif (\\array_key_exists($key, $this->cache)) {\n            return $this->cache[$key];\n        }\n\n        try {\n            return $this->cache[$key] = $this->finalConfig->get($key);\n        } catch (InvalidPathException|MissingPathException $ex) {\n            throw new UnknownOptionException($ex->getMessage(), $key, (int) $ex->getCode(), $ex);\n        }\n    }\n\n    \/**\n     * @psalm-external-mutation-free\n     *\/\n    public function exists(string $key): bool\n    {\n        if ($this->finalConfig === null) {\n            $this->finalConfig = $this->build();\n        } elseif (\\array_key_exists($key, $this->cache)) {\n            return true;\n        }\n\n        try {\n            return $this->finalConfig->has($key);\n        } catch (InvalidPathException $ex) {\n            return false;\n        }\n    }\n\n    \/**\n     * @psalm-external-mutation-free\n     *\/\n    private function invalidate(): void\n    {\n        $this->cache       = [];\n        $this->finalConfig = null;\n    }\n\n    \/**\n     * Applique le sch\u00e9ma \u00e0 la configuration pour renvoyer la configuration finale\n     *\n     * @throws ValidationException\n     *\n     * @psalm-allow-private-mutation\n     *\/\n    private function build(): Data\n    {\n        try {\n            $schema    = Expect::structure($this->configSchemas);\n            $processor = new Processor();\n            $processed = $processor->process($schema, $this->userConfig->export());\n\n            $this->raiseAnyDeprecationNotices($processor->getWarnings());\n\n            return $this->finalConfig = new Data(self::convertStdClassesToArrays($processed));\n        } catch (ValidationException $ex) {\n            throw new ConfigException($ex->getMessage(), $ex->getCode());\n        }\n    }\n\n    \/**\n     * Convertit r\u00e9cursivement les instances stdClass en tableaux\n     *\n     * @param mixed $data\n     *\n     * @return mixed\n     *\n     * @psalm-pure\n     *\/\n    private static function convertStdClassesToArrays($data)\n    {\n        if ($data instanceof stdClass) {\n            $data = (array) $data;\n        }\n\n        if (\\is_array($data)) {\n            foreach ($data as $k => $v) {\n                $data[$k] = self::convertStdClassesToArrays($v);\n            }\n        }\n\n        return $data;\n    }\n\n    \/**\n     * @param string[] $warnings\n     *\/\n    private function raiseAnyDeprecationNotices(array $warnings): void\n    {\n        foreach ($warnings as $warning) {\n            @\\trigger_error($warning, \\E_USER_DEPRECATED);\n        }\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,2,null,0,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,2,null,0,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null]},{"name":"src\\Config\\UnknownOptionException.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Config;\n\nuse InvalidArgumentException;\nuse Throwable;\n\n\/**\n * @credit league\/config (c) Colin O'Dell <colinodell@gmail.com>\n *\/\nfinal class UnknownOptionException extends InvalidArgumentException\n{\n    private string $path;\n\n    public function __construct(string $message, string $path, int $code = 0, ?Throwable $previous = null)\n    {\n        parent::__construct($message, $code, $previous);\n\n        $this->path = $path;\n    }\n\n    public function getPath(): string\n    {\n        return $this->path;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,0,null,null,null]},{"name":"src\\Constants\\constants.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\ndefine('BASEPATH', dirname(COMPOSER_PATH) . DS);\n\ndefine('ROOTPATH', dirname(WEBROOT) . DS);\n\ndefined('DS') || define('DS', DIRECTORY_SEPARATOR);\n\n\/**\n * Chemin  vers le dossier des configurations\n *\/\ndefined('CONFIG_PATH') || define('CONFIG_PATH', APP_PATH . 'Config' . DS);\n\n\/**\n * Chemin  vers le dossier des controllers\n *\/\ndefined('CONTROLLER_PATH') || define('CONTROLLER_PATH', APP_PATH . 'Controllers' . DS);\n\n\/**\n * Chemin  vers le dossier des entit\u00e9s\n *\/\ndefined('ENTITY_PATH') || define('ENTITY_PATH', APP_PATH . 'Entities' . DS);\n\n\/**\n * Chemin vers le dossier des helpers de l'application\n *\/\ndefined('HELPER_PATH') || define('HELPER_PATH', APP_PATH . 'Helpers' . DS);\n\n\/**\n * Chemin vers le dossier des helpers de l'application\n *\/\ndefined('LIBRARY_PATH') || define('LIBRARY_PATH', APP_PATH . 'Libraries' . DS);\n\n\/**\n * Chemin vers le dossier de stockage des fichiers temporaires\n *\/\ndefined('TEMP_PATH') || define('TEMP_PATH', STORAGE_PATH . 'temp' . DS);\n\n\/**\n * Chemin vers le dossier de cache des vues\n *\/\ndefined('VIEW_CACHE_PATH') || define('VIEW_CACHE_PATH', STORAGE_PATH . 'cache' . DS);\n\n\/**\n * Chemin vers le dossier des vues\n *\/\ndefined('VIEW_PATH') || define('VIEW_PATH', APP_PATH . 'Views' . DS);\n\n\/**\n * Chemin vers le dossier des layouts\n *\/\ndefined('LAYOUT_PATH') || define('LAYOUT_PATH', VIEW_PATH . 'layouts' . DS);\n\nif (! defined('MIDDLEWARE_PATH')) {\n    \/**\n     * Middlewares directory path\n     *\/\n    define('MIDDLEWARE_PATH', APP_PATH . 'middlewares' . DS);\n}\n\nif (! defined('MODEL_PATH')) {\n    \/**\n     * Models directory path\n     *\/\n    define('MODEL_PATH', APP_PATH . 'models' . DS);\n}\n\nif (! defined('RESOURCE_PATH')) {\n    \/**\n     * Resources directory path\n     *\/\n    define('RESOURCE_PATH', APP_PATH . 'resources' . DS);\n}\n\nif (! defined('LANG_PATH')) {\n    \/**\n     * File translation directory path\n     *\/\n    define('LANG_PATH', RESOURCE_PATH . 'lang' . DS);\n}\n\nif (! defined('SERVICE_PATH')) {\n    \/**\n     * Services directory path\n     *\/\n    define('SERVICE_PATH', APP_PATH . 'services' . DS);\n}\n\nif (! defined('LOG_PATH')) {\n    \/**\n     * Application logs files storage path\n     *\/\n    define('LOG_PATH', STORAGE_PATH . 'logs' . DS);\n}\n\nif (! defined('DATABASE_PATH')) {\n    \/**\n     * Database storage directory path\n     *\/\n    define('DATABASE_PATH', STORAGE_PATH . 'database' . DS);\n}\n\nif (! defined('DB_MIGRATION_PATH')) {\n    \/**\n     * Database migrations storage path\n     *\/\n    define('DB_MIGRATION_PATH', RESOURCE_PATH . 'database' . DS . 'migrations' . DS);\n}\n\nif (! defined('DB_SEED_PATH')) {\n    \/**\n     * Database seeds storage path\n     *\/\n    define('DB_SEED_PATH', RESOURCE_PATH . 'database' . DS . 'seeds' . DS);\n}\n\nif (! defined('DB_DUMP_PATH')) {\n    \/**\n     * Database backup storage path\n     *\/\n    define('DB_DUMP_PATH', DATABASE_PATH . 'dump' . DS);\n}\n\nif (! defined('DB_CACHE_PATH')) {\n    \/**\n     * Database cache directory path\n     *\/\n    define('DB_CACHE_PATH', DATABASE_PATH . 'cache' . DS);\n}\n\nif (! defined('SMARTY_CACHE_PATH')) {\n    \/**\n     * Smarty views cache directory path\n     *\/\n    define('SMARTY_CACHE_PATH', STORAGE_PATH . 'smarty' . DS . 'cache' . DS);\n}\n\nif (! defined('SMARTY_COMPILES_PATH')) {\n    \/**\n     * Smarty views compile directory path\n     *\/\n    define('SMARTY_COMPILES_PATH', STORAGE_PATH . 'smarty' . DS . 'compiles' . DS);\n}\n\nif (! defined('SMARTY_CONF_PATH')) {\n    \/**\n     * Smarty views config directory path\n     *\/\n    define('SMARTY_CONF_PATH', STORAGE_PATH . 'smarty' . DS . 'conf' . DS);\n}\n\n\/*\n | --------------------------------------------------------------------\n | App Namespace\n | --------------------------------------------------------------------\n |\n | This defines the default Namespace that is used throughout\n | CodeIgniter to refer to the Application directory. Change\n | this constant to change the namespace that all application\n | classes should use.\n |\n | NOTE: changing this will require manually modifying the\n | existing namespaces of App\\* namespaced-classes.\n *\/\ndefined('APP_NAMESPACE') || define('APP_NAMESPACE', 'App');\n\n\/*\n | --------------------------------------------------------------------------\n | Composer Path\n | --------------------------------------------------------------------------\n |\n | The path that Composer's autoload file is expected to live. By default,\n | the vendor folder is in the Root directory, but you can customize that here.\n *\/\ndefined('COMPOSER_PATH') || define('COMPOSER_PATH', ROOTPATH . 'vendor\/autoload.php');\n\n\/*\n |--------------------------------------------------------------------------\n | Timing Constants\n |--------------------------------------------------------------------------\n |\n | Provide simple ways to work with the myriad of PHP functions that\n | require information to be in seconds.\n *\/\ndefined('SECOND') || define('SECOND', 1);\ndefined('MINUTE') || define('MINUTE', 60);\ndefined('HOUR')   || define('HOUR', 3600);\ndefined('DAY')    || define('DAY', 86400);\ndefined('WEEK')   || define('WEEK', 604800);\ndefined('MONTH')  || define('MONTH', 2592000);\ndefined('YEAR')   || define('YEAR', 31536000);\ndefined('DECADE') || define('DECADE', 315360000);\n\n\/*\n | --------------------------------------------------------------------------\n | Exit Status Codes\n | --------------------------------------------------------------------------\n |\n | Used to indicate the conditions under which the script is exit()ing.\n | While there is no universal standard for error codes, there are some\n | broad conventions.  Three such conventions are mentioned below, for\n | those who wish to make use of them.  The CodeIgniter defaults were\n | chosen for the least overlap with these conventions, while still\n | leaving room for others to be defined in future versions and user\n | applications.\n |\n | The three main conventions used for determining exit status codes\n | are as follows:\n |\n |    Standard C\/C++ Library (stdlibc):\n |       http:\/\/www.gnu.org\/software\/libc\/manual\/html_node\/Exit-Status.html\n |       (This link also contains other GNU-specific conventions)\n |    BSD sysexits.h:\n |       http:\/\/www.gsp.com\/cgi-bin\/man.cgi?section=3&topic=sysexits\n |    Bash scripting:\n |       http:\/\/tldp.org\/LDP\/abs\/html\/exitcodes.html\n |\n *\/\ndefined('EXIT_SUCCESS')        || define('EXIT_SUCCESS', 0); \/\/ no errors\ndefined('EXIT_ERROR')          || define('EXIT_ERROR', 1); \/\/ generic error\ndefined('EXIT_CONFIG')         || define('EXIT_CONFIG', 3); \/\/ configuration error\ndefined('EXIT_UNKNOWN_FILE')   || define('EXIT_UNKNOWN_FILE', 4); \/\/ file not found\ndefined('EXIT_UNKNOWN_CLASS')  || define('EXIT_UNKNOWN_CLASS', 5); \/\/ unknown class\ndefined('EXIT_UNKNOWN_METHOD') || define('EXIT_UNKNOWN_METHOD', 6); \/\/ unknown class member\ndefined('EXIT_USER_INPUT')     || define('EXIT_USER_INPUT', 7); \/\/ invalid user input\ndefined('EXIT_DATABASE')       || define('EXIT_DATABASE', 8); \/\/ database error\ndefined('EXIT__AUTO_MIN')      || define('EXIT__AUTO_MIN', 9); \/\/ lowest automatically-assigned error code\ndefined('EXIT__AUTO_MAX')      || define('EXIT__AUTO_MAX', 125); \/\/ highest automatically-assigned error code\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,null,0,null,null,null,null,null,null,0,null,null,null,null,null,null,0,null,null,null,null,null,null,0,null,null,null,null,null,null,0,null,null,null,null,null,null,0,null,null,null,null,null,null,0,null,null,null,null,null,null,0,null,null,null,null,null,null,0,null,null,null,null,null,null,0,null,null,null,null,null,null,0,null,null,null,null,null,null,0,null,null,null,null,null,null,0,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,0,0,0,0,0,0,null]},{"name":"src\\Constants\\language\\en\\Cache.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nreturn [\n    'unableToWrite'   => 'Cache unable to write to {0}.',\n    'invalidHandlers' => 'Cache config must have an array of $validHandlers.',\n    'noBackup'        => 'Cache config must have a handler and backupHandler set.',\n    'handlerNotFound' => 'Cache config has an invalid handler or backup handler specified.',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Cast.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nreturn [\n    'baseCastMissing'        => 'The \"{0}\" class must inherit the \"CodeIgniter\\Entity\\Cast\\BaseCast\" class.',\n    'invalidCastMethod'      => 'The \"{0}\" is invalid cast method, valid methods are: [\"get\", \"set\"].',\n    'invalidTimestamp'       => 'Type casting \"timestamp\" expects a correct timestamp.',\n    'jsonErrorCtrlChar'      => 'Unexpected control character found.',\n    'jsonErrorDepth'         => 'Maximum stack depth exceeded.',\n    'jsonErrorStateMismatch' => 'Underflow or the modes mismatch.',\n    'jsonErrorSyntax'        => 'Syntax error, malformed JSON.',\n    'jsonErrorUnknown'       => 'Unknown error.',\n    'jsonErrorUtf8'          => 'Malformed UTF-8 characters, possibly incorrectly encoded.',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\CLI.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ CLI language settings\nreturn [\n    'altCommandPlural'   => 'Did you mean one of these?',\n    'altCommandSingular' => 'Did you mean this?',\n    'commandNotFound'    => 'Command \"{0}\" not found.',\n    'generator'          => [\n        'cancelOperation' => 'Operation has been cancelled.',\n        'className'       => [\n            'command'    => 'Command class name',\n            'config'     => 'Config class name',\n            'controller' => 'Controller class name',\n            'default'    => 'Class name',\n            'entity'     => 'Entity class name',\n            'filter'     => 'Filter class name',\n            'migration'  => 'Migration class name',\n            'model'      => 'Model class name',\n            'seeder'     => 'Seeder class name',\n            'validation' => 'Validation class name',\n        ],\n        'commandType'      => 'Command type',\n        'databaseGroup'    => 'Database group',\n        'fileCreate'       => 'File created: {0}',\n        'fileError'        => 'Error while creating file: {0}',\n        'fileExist'        => 'File exists: {0}',\n        'fileOverwrite'    => 'File overwritten: {0}',\n        'parentClass'      => 'Parent class',\n        'returnType'       => 'Return type',\n        'tableName'        => 'Table name',\n        'usingCINamespace' => 'Warning: Using the \"CodeIgniter\" namespace will generate the file in the system directory.',\n    ],\n    'helpArguments'       => 'Arguments:',\n    'helpDescription'     => 'Description:',\n    'helpOptions'         => 'Options:',\n    'helpUsage'           => 'Usage:',\n    'invalidColor'        => 'Invalid {0} color: {1}.',\n    'namespaceNotDefined' => 'Namespace \"{0}\" is not defined.',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Config.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Files language settings\nreturn [\n    'fileDoesNotExist'          => 'Unable to loader the \"{0} \"configuration, the {1} file does not exist',\n    'viewAdapterConfigNotFound' => 'No configuration found for adapter {0}',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Cookie.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Cookie language settings\nreturn [\n    'invalidExpiresTime'    => 'Invalid \"{0}\" type for \"Expires\" attribute. Expected: string, integer, DateTimeInterface object.',\n    'invalidExpiresValue'   => 'The cookie expiration time is not valid.',\n    'invalidCookieName'     => 'The cookie name \"{0}\" contains invalid characters.',\n    'emptyCookieName'       => 'The cookie name cannot be empty.',\n    'invalidSecurePrefix'   => 'Using the \"__Secure-\" prefix requires setting the \"Secure\" attribute.',\n    'invalidHostPrefix'     => 'Using the \"__Host-\" prefix must be set with the \"Secure\" flag, must not have a \"Domain\" attribute, and the \"Path\" is set to \"\/\".',\n    'invalidSameSite'       => 'The SameSite value must be None, Lax, Strict or a blank string, {0} given.',\n    'invalidSameSiteNone'   => 'Using the \"SameSite=None\" attribute requires setting the \"Secure\" attribute.',\n    'invalidCookieInstance' => '\"{0}\" class expected cookies array to be instances of \"{1}\" but got \"{2}\" at index {3}.',\n    'unknownCookieInstance' => 'Cookie object with name \"{0}\" and prefix \"{1}\" was not found in the collection.',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Core.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Core language settings\nreturn [\n    'copyError'                    => 'An error was encountered while attempting to replace the file ({0}). Please make sure your file directory is writable.',\n    'enabledZlibOutputCompression' => 'Your zlib.output_compression ini directive is turned on. This will not work well with output buffers.',\n    'invalidFile'                  => 'Invalid file: {0}',\n    'invalidPhpVersion'            => 'Your PHP version must be {0} or higher to run CodeIgniter. Current version: {1}',\n    'missingExtension'             => 'The framework needs the following extension(s) installed and loaded: {0}.',\n    'noHandlers'                   => '{0} must provide at least one Handler.',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Database.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Database language settings\nreturn [\n    'invalidEvent'                     => '{0} is not a valid Model Event callback.',\n    'invalidArgument'                  => 'You must provide a valid {0}.',\n    'invalidAllowedFields'             => 'Allowed fields must be specified for model: {0}',\n    'emptyDataset'                     => 'There is no data to {0}.',\n    'emptyPrimaryKey'                  => 'There is no primary key defined when trying to make {0}.',\n    'failGetFieldData'                 => 'Failed to get field data from database.',\n    'failGetIndexData'                 => 'Failed to get index data from database.',\n    'failGetForeignKeyData'            => 'Failed to get foreign key data from database.',\n    'parseStringFail'                  => 'Parsing key string failed.',\n    'featureUnavailable'               => 'This feature is not available for the database you are using.',\n    'tableNotFound'                    => 'Table `{0}` was not found in the current database.',\n    'noPrimaryKey'                     => '`{0}` model class does not specify a Primary Key.',\n    'noDateFormat'                     => '`{0}` model class does not have a valid dateFormat.',\n    'fieldNotExists'                   => 'Field `{0}` not found.',\n    'forEmptyInputGiven'               => 'Empty statement is given for the field `{0}`',\n    'forFindColumnHaveMultipleColumns' => 'Only single column allowed in Column name.',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Email.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Email language settings\nreturn [\n    'mustBeArray'          => 'The email validation method must be passed an array.',\n    'invalidAddress'       => 'Invalid email address: {0}',\n    'attachmentMissing'    => 'Unable to locate the following email attachment: {0}',\n    'attachmentUnreadable' => 'Unable to open this attachment: {0}',\n    'noFrom'               => 'Cannot send mail with no \"From\" header.',\n    'noRecipients'         => 'You must include recipients: To, Cc, or Bcc',\n    'sendFailurePHPMail'   => 'Unable to send email using PHP mail(). Your server might not be configured to send mail using this method.',\n    'sendFailureSendmail'  => 'Unable to send email using PHP Sendmail. Your server might not be configured to send mail using this method.',\n    'sendFailureSmtp'      => 'Unable to send email using PHP SMTP. Your server might not be configured to send mail using this method.',\n    'sent'                 => 'Your message has been successfully sent using the following protocol: {0}',\n    'noSocket'             => 'Unable to open a socket to Sendmail. Please check settings.',\n    'noHostname'           => 'You did not specify a SMTP hostname.',\n    'SMTPError'            => 'The following SMTP error was encountered: {0}',\n    'noSMTPAuth'           => 'Error: You must assign a SMTP username and password.',\n    'failedSMTPLogin'      => 'Failed to send AUTH LOGIN command. Error: {0}',\n    'SMTPAuthUsername'     => 'Failed to authenticate username. Error: {0}',\n    'SMTPAuthPassword'     => 'Failed to authenticate password. Error: {0}',\n    'SMTPDataFailure'      => 'Unable to send data: {0}',\n    'exitStatus'           => 'Exit status code: {0}',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Encryption.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Encryption language settings\nreturn [\n    'noDriverRequested'    => 'No driver requested; Miss Daisy will be so upset!',\n    'noHandlerAvailable'   => 'Unable to find an available {0} encryption handler.',\n    'unKnownHandler'       => '\"{0}\" cannot be configured.',\n    'starterKeyNeeded'     => 'Encrypter needs a starter key.',\n    'authenticationFailed' => 'Decrypting: authentication failed.',\n    'encryptionFailed'     => 'Encryption failed.',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Fabricator.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Fabricator language settings\nreturn [\n    'invalidModel'      => 'Invalid model supplied for fabrication.',\n    'missingFormatters' => 'No valid formatters defined.',\n    'createFailed'      => 'Fabricator failed to insert on table {0}: {1}',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Files.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Files language settings\nreturn [\n    'fileNotFound'      => 'File not found: {0}',\n    'cannotMove'        => 'Could not move file {0} to {1} ({2}).',\n    'expectedDirectory' => '{0} expects a valid directory.',\n    'expectedFile'      => '{0} expects a valid file.',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Format.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Format language settings\nreturn [\n    'invalidFormatter' => '\"{0}\" is not a valid Formatter class.',\n    'invalidJSON'      => 'Failed to parse json string, error: \"{0}\".',\n    'invalidMime'      => 'No Formatter defined for mime type: \"{0}\".',\n    'missingExtension' => 'The SimpleXML extension is required to format XML.',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\HTTP.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ HTTP language settings\nreturn [\n    \/\/ CurlRequest\n    'missingCurl'     => 'CURL must be enabled to use the CURLRequest class.',\n    'invalidSSLKey'   => 'Cannot set SSL Key. {0} is not a valid file.',\n    'sslCertNotFound' => 'SSL certificate not found at: {0}',\n    'curlError'       => '{0} : {1}',\n\n    \/\/ IncomingRequest\n    'invalidNegotiationType' => '{0} is not a valid negotiation type. Must be one of: media, charset, encoding, language.',\n\n    \/\/ Message\n    'invalidHTTPProtocol' => 'Invalid HTTP Protocol Version. Must be one of: {0}',\n\n    \/\/ Negotiate\n    'emptySupportedNegotiations' => 'You must provide an array of supported values to all Negotiations.',\n\n    \/\/ RedirectResponse\n    'invalidRoute' => '{0} route cannot be found while reverse-routing.',\n\n    \/\/ DownloadResponse\n    'cannotSetBinary'        => 'When setting filepath cannot set binary.',\n    'cannotSetFilepath'      => 'When setting binary cannot set filepath: {0}',\n    'notFoundDownloadSource' => 'Not found download body source.',\n    'cannotSetCache'         => 'It does not support caching for downloading.',\n    'cannotSetStatusCode'    => 'It does not support change status code for downloading. code: {0}, reason: {1}',\n\n    \/\/ Response\n    'missingResponseStatus' => 'HTTP Response is missing a status code',\n    'invalidStatusCode'     => '{0} is not a valid HTTP return status code',\n    'unknownStatusCode'     => 'Unknown HTTP status code provided with no message: {0}',\n\n    \/\/ URI\n    'cannotParseURI'       => 'Unable to parse URI: {0}',\n    'segmentOutOfRange'    => 'Request URI segment is out of range: {0}',\n    'invalidPort'          => 'Ports must be between 0 and 65535. Given: {0}',\n    'malformedQueryString' => 'Query strings may not include URI fragments.',\n\n    \/\/ Page Not Found\n    'pageNotFound'       => 'Page Not Found',\n    'emptyController'    => 'No Controller specified.',\n    'controllerNotFound' => 'Controller or its method is not found: {0}::{1}',\n    'methodNotFound'     => 'Controller method is not found: {0}',\n\n    \/\/ CSRF\n    \/\/ @deprecated use `Security.disallowedAction`\n    'disallowedAction' => 'The action you requested is not allowed.',\n\n    \/\/ Uploaded file moving\n    'alreadyMoved' => 'The uploaded file has already been moved.',\n    'invalidFile'  => 'The original file is not a valid file.',\n    'moveFailed'   => 'Could not move file {0} to {1} ({2})',\n\n    'uploadErrOk'        => 'The file uploaded with success.',\n    'uploadErrIniSize'   => 'The file \"%s\" exceeds your upload_max_filesize ini directive.',\n    'uploadErrFormSize'  => 'The file \"%s\" exceeds the upload limit defined in your form.',\n    'uploadErrPartial'   => 'The file \"%s\" was only partially uploaded.',\n    'uploadErrNoFile'    => 'No file was uploaded.',\n    'uploadErrCantWrite' => 'The file \"%s\" could not be written on disk.',\n    'uploadErrNoTmpDir'  => 'File could not be uploaded: missing temporary directory.',\n    'uploadErrExtension' => 'File upload was stopped by a PHP extension.',\n    'uploadErrUnknown'   => 'The file \"%s\" was not uploaded due to an unknown error.',\n\n    \/\/ SameSite setting\n    \/\/ @deprecated\n    'invalidSameSiteSetting' => 'The SameSite setting must be None, Lax, Strict, or a blank string. Given: {0}',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Images.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Images language settings\nreturn [\n    'sourceImageRequired'    => 'You must specify a source image in your preferences.',\n    'gdRequired'             => 'The GD image library is required to use this feature.',\n    'gdRequiredForProps'     => 'Your server must support the GD image library in order to determine the image properties.',\n    'gifNotSupported'        => 'GIF images are often not supported due to licensing restrictions. You may have to use JPG or PNG images instead.',\n    'jpgNotSupported'        => 'JPG images are not supported.',\n    'pngNotSupported'        => 'PNG images are not supported.',\n    'webpNotSupported'       => 'WEBP images are not supported.',\n    'fileNotSupported'       => 'The supplied file is not a supported image type.',\n    'unsupportedImageCreate' => 'Your server does not support the GD function required to process this type of image.',\n    'jpgOrPngRequired'       => 'The image resize protocol specified in your preferences only works with JPEG or PNG image types.',\n    'rotateUnsupported'      => 'Image rotation does not appear to be supported by your server.',\n    'libPathInvalid'         => 'The path to your image library is not correct. Please set the correct path in your image preferences. {0}',\n    'imageProcessFailed'     => 'Image processing failed. Please verify that your server supports the chosen protocol and that the path to your image library is correct.',\n    'rotationAngleRequired'  => 'An angle of rotation is required to rotate the image.',\n    'invalidPath'            => 'The path to the image is not correct.',\n    'copyFailed'             => 'The image copy routine failed.',\n    'missingFont'            => 'Unable to find a font to use.',\n    'saveFailed'             => 'Unable to save the image. Please make sure the image and file directory are writable.',\n    'invalidDirection'       => 'Flip direction can be only `vertical` or `horizontal`. Given: {0}',\n    'exifNotSupported'       => 'Reading EXIF data is not supported by this PHP installation.',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Loader.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Files language settings\nreturn [\n    'providersDefinitionDontExist' => 'Unable to load system services definition file. The `{0}` file does not exist or cannot be read.',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Log.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Log language settings\nreturn [\n    'invalidLogLevel'    => '{0} is an invalid log level.',\n    'invalidMessageType' => 'The given message type \"{0}\" is not supported.',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Migrations.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Migration language settings\nreturn [\n    \/\/ Migration Runner\n    'missingTable'  => 'Migrations table must be set.',\n    'disabled'      => 'Migrations have been loaded but are disabled or setup incorrectly.',\n    'notFound'      => 'Migration file not found: ',\n    'batchNotFound' => 'Target batch not found: ',\n    'empty'         => 'No Migration files found',\n    'gap'           => 'There is a gap in the migration sequence near version number: ',\n    'classNotFound' => 'The migration class \"%s\" could not be found.',\n    'missingMethod' => 'The migration class is missing an \"%s\" method.',\n\n    \/\/ Migration Command\n    'migHelpLatest'   => \"\\t\\tMigrates database to latest available migration.\",\n    'migHelpCurrent'  => \"\\t\\tMigrates database to version set as 'current' in configuration.\",\n    'migHelpVersion'  => \"\\tMigrates database to version {v}.\",\n    'migHelpRollback' => \"\\tRuns all migrations 'down' to version 0.\",\n    'migHelpRefresh'  => \"\\t\\tUninstalls and re-runs all migrations to freshen database.\",\n    'migHelpSeed'     => \"\\tRuns the seeder named [name].\",\n    'migCreate'       => \"\\tCreates a new migration named [name]\",\n    'nameMigration'   => 'Name the migration file',\n    'migNumberError'  => 'Migration number must be three digits, and there must not be any gaps in the sequence.',\n    'rollBackConfirm' => 'Are you sure you want to rollback?',\n    'refreshConfirm'  => 'Are you sure you want to refresh?',\n\n    'latest'            => 'Running all new migrations...',\n    'generalFault'      => 'Migration failed!',\n    'migInvalidVersion' => 'Invalid version number provided.',\n    'toVersionPH'       => 'Migrating to version %s...',\n    'toVersion'         => 'Migrating to current version...',\n    'rollingBack'       => 'Rolling back migrations to batch: ',\n    'noneFound'         => 'No migrations were found.',\n    'migSeeder'         => 'Seeder name',\n    'migMissingSeeder'  => 'You must provide a seeder name.',\n    'nameSeeder'        => 'Name the seeder file',\n    'removed'           => 'Rolling back: ',\n    'added'             => 'Running: ',\n\n    \/\/ Migrate Status\n    'namespace' => 'Namespace',\n    'filename'  => 'Filename',\n    'version'   => 'Version',\n    'group'     => 'Group',\n    'on'        => 'Migrated On: ',\n    'batch'     => 'Batch',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Number.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Number language settings\nreturn [\n    'terabyteAbbr' => 'TB',\n    'gigabyteAbbr' => 'GB',\n    'megabyteAbbr' => 'MB',\n    'kilobyteAbbr' => 'KB',\n    'bytes'        => 'Bytes',\n\n    \/\/ don't forget the space in front of these!\n    'thousand'    => ' thousand',\n    'million'     => ' million',\n    'billion'     => ' billion',\n    'trillion'    => ' trillion',\n    'quadrillion' => ' quadrillion',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Pager.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Pager language settings\nreturn [\n    'pageNavigation'         => 'Page navigation',\n    'first'                  => 'First',\n    'previous'               => 'Previous',\n    'next'                   => 'Next',\n    'last'                   => 'Last',\n    'older'                  => 'Older',\n    'newer'                  => 'Newer',\n    'invalidTemplate'        => '{0} is not a valid Pager template.',\n    'invalidPaginationGroup' => '{0} is not a valid Pagination group.',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Publisher.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Publisher language settings\nreturn [\n    'collision'             => 'Publisher encountered an unexpected {0} while copying {1} to {2}.',\n    'destinationNotAllowed' => 'Destination is not on the allowed list of Publisher directories: {0}',\n    'fileNotAllowed'        => '{0} fails the following restriction for {1}: {2}',\n\n    \/\/ Publish Command\n    'publishMissing' => 'No Publisher classes detected in {0} across all namespaces.',\n    'publishSuccess' => '{0} published {1} file(s) to {2}.',\n    'publishFailure' => '{0} failed to publish to {1}!',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\RESTful.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ RESTful language settings\nreturn [\n    'notImplemented' => '\"{0}\" action not implemented.',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Router.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Router language settings\nreturn [\n    'invalidParameter'    => 'A parameter does not match the expected type.',\n    'missingDefaultRoute' => 'Unable to determine what should be displayed. A default route has not been specified in the routing file.',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Security.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Security language settings\nreturn [\n    'disallowedAction' => 'The action you requested is not allowed.',\n\n    \/\/ @deprecated\n    'invalidSameSite' => 'The SameSite value must be None, Lax, Strict, or a blank string. Given: {0}',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Session.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Session language settings\nreturn [\n    'missingDatabaseTable'   => '`sessionSavePath` must have the table name for the Database Session Handler to work.',\n    'invalidSavePath'        => 'Session: Configured save path \"{0}\" is not a directory, does not exist or cannot be created.',\n    'writeProtectedSavePath' => 'Session: Configured save path \"{0}\" is not writable by the PHP process.',\n    'emptySavePath'          => 'Session: No save path configured.',\n    'invalidSavePathFormat'  => 'Session: Invalid Redis save path format: {0}',\n\n    \/\/ @deprecated\n    'invalidSameSiteSetting' => 'Session: The SameSite setting must be None, Lax, Strict, or a blank string. Given: {0}',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Test.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Testing language settings\nreturn [\n    'invalidMockClass' => '{0} is not a valid Mock class',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Time.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Time language settings\nreturn [\n    'invalidFormat'  => '\"{0}\" is not a valid datetime format',\n    'invalidMonth'   => 'Months must be between 1 and 12. Given: {0}',\n    'invalidDay'     => 'Days must be between 1 and 31. Given: {0}',\n    'invalidOverDay' => 'Days must be between 1 and {0}. Given: {1}',\n    'invalidHours'   => 'Hours must be between 0 and 23. Given: {0}',\n    'invalidMinutes' => 'Minutes must be between 0 and 59. Given: {0}',\n    'invalidSeconds' => 'Seconds must be between 0 and 59. Given: {0}',\n    'years'          => '{0, plural, =1{# year} other{# years}}',\n    'months'         => '{0, plural, =1{# month} other{# months}}',\n    'weeks'          => '{0, plural, =1{# week} other{# weeks}}',\n    'days'           => '{0, plural, =1{# day} other{# days}}',\n    'hours'          => '{0, plural, =1{# hour} other{# hours}}',\n    'minutes'        => '{0, plural, =1{# minute} other{# minutes}}',\n    'seconds'        => '{0, plural, =1{# second} other{# seconds}}',\n    'ago'            => '{0} ago',\n    'inFuture'       => 'in {0}',\n    'yesterday'      => 'Yesterday',\n    'tomorrow'       => 'Tomorrow',\n    'now'            => 'Just now',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\Validation.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ Validation language settings\nreturn [\n    \/\/ Core Messages\n    'noRuleSets'      => 'No rulesets specified in Validation configuration.',\n    'ruleNotFound'    => '{0} is not a valid rule.',\n    'groupNotFound'   => '{0} is not a validation rules group.',\n    'groupNotArray'   => '{0} rule group must be an array.',\n    'invalidTemplate' => '{0} is not a valid Validation template.',\n\n    \/\/ Rule Messages\n    'alpha'                 => 'The {field} field may only contain alphabetical characters.',\n    'alpha_dash'            => 'The {field} field may only contain alphanumeric, underscore, and dash characters.',\n    'alpha_numeric'         => 'The {field} field may only contain alphanumeric characters.',\n    'alpha_numeric_punct'   => 'The {field} field may contain only alphanumeric characters, spaces, and  ~ ! # $ % & * - _ + = | : . characters.',\n    'alpha_numeric_space'   => 'The {field} field may only contain alphanumeric and space characters.',\n    'alpha_space'           => 'The {field} field may only contain alphabetical characters and spaces.',\n    'decimal'               => 'The {field} field must contain a decimal number.',\n    'differs'               => 'The {field} field must differ from the {param} field.',\n    'equals'                => 'The {field} field must be exactly: {param}.',\n    'exact_length'          => 'The {field} field must be exactly {param} characters in length.',\n    'greater_than'          => 'The {field} field must contain a number greater than {param}.',\n    'greater_than_equal_to' => 'The {field} field must contain a number greater than or equal to {param}.',\n    'hex'                   => 'The {field} field may only contain hexidecimal characters.',\n    'in_list'               => 'The {field} field must be one of: {param}.',\n    'integer'               => 'The {field} field must contain an integer.',\n    'is_natural'            => 'The {field} field must only contain digits.',\n    'is_natural_no_zero'    => 'The {field} field must only contain digits and must be greater than zero.',\n    'is_not_unique'         => 'The {field} field must contain a previously existing value in the database.',\n    'is_unique'             => 'The {field} field must contain a unique value.',\n    'less_than'             => 'The {field} field must contain a number less than {param}.',\n    'less_than_equal_to'    => 'The {field} field must contain a number less than or equal to {param}.',\n    'matches'               => 'The {field} field does not match the {param} field.',\n    'max_length'            => 'The {field} field cannot exceed {param} characters in length.',\n    'min_length'            => 'The {field} field must be at least {param} characters in length.',\n    'not_equals'            => 'The {field} field cannot be: {param}.',\n    'not_in_list'           => 'The {field} field must not be one of: {param}.',\n    'numeric'               => 'The {field} field must contain only numbers.',\n    'regex_match'           => 'The {field} field is not in the correct format.',\n    'required'              => 'The {field} field is required.',\n    'required_with'         => 'The {field} field is required when {param} is present.',\n    'required_without'      => 'The {field} field is required when {param} is not present.',\n    'string'                => 'The {field} field must be a valid string.',\n    'timezone'              => 'The {field} field must be a valid timezone.',\n    'valid_base64'          => 'The {field} field must be a valid base64 string.',\n    'valid_email'           => 'The {field} field must contain a valid email address.',\n    'valid_emails'          => 'The {field} field must contain all valid email addresses.',\n    'valid_ip'              => 'The {field} field must contain a valid IP.',\n    'valid_url'             => 'The {field} field must contain a valid URL.',\n    'valid_date'            => 'The {field} field must contain a valid date.',\n\n    \/\/ Credit Cards\n    'valid_cc_num' => '{field} does not appear to be a valid credit card number.',\n\n    \/\/ Files\n    'uploaded' => '{field} is not a valid uploaded file.',\n    'max_size' => '{field} is too large of a file.',\n    'is_image' => '{field} is not a valid, uploaded image file.',\n    'mime_in'  => '{field} does not have a valid mime type.',\n    'ext_in'   => '{field} does not have a valid file extension.',\n    'max_dims' => '{field} is either not an image, or it is too wide or tall.',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\language\\en\\View.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\n\/\/ View language settings\nreturn [\n    'invalidCellMethod'     => '{class}::{method} is not a valid method.',\n    'missingCellParameters' => '{class}::{method} has no params.',\n    'invalidCellParameter'  => '{0} is not a valid param name.',\n    'noCellClass'           => 'No view cell class provided.',\n    'invalidCellClass'      => 'Unable to locate view cell class: {0}.',\n    'tagSyntaxError'        => 'You have a syntax error in your Parser tags: {0}',\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\providers.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nreturn [\n    BlitzPHP\\Contracts\\Router\\RouteCollectionInterface::class => service('routes'),\n    Psr\\Container\\ContainerInterface::class                   => service('container'),\n    Psr\\Http\\Message\\ResponseInterface::class                 => service('response'),\n    Psr\\Http\\Message\\ServerRequestInterface::class            => service('request'),\n    Psr\\SimpleCache\\CacheInterface::class                     => service('cache'),\n];\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\schemas\\app.config.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nuse Nette\\Schema\\Expect;\n\nreturn Expect::structure([\n    'base_url'                     => Expect::string()->default('auto'),\n    'charset'                      => Expect::string()->default('UTF-8'),\n    'environment'                  => Expect::string()->default('auto'),\n    'language'                     => Expect::string()->default('en'),\n    'force_global_secure_requests' => Expect::bool()->default(false),\n    'url_suffix'                   => Expect::string()->default(''),\n    'show_debugbar'                => Expect::anyOf(true, false, 'auto')->default('auto'),\n    'use_absolute_link'            => Expect::bool()->default(true),\n    'negotiate_locale'             => Expect::bool()->default(true),\n    'supported_locales'            => Expect::listOf('string')->default(['fr', 'en']),\n    'timezone'                     => Expect::string()->default('Africa\/Douala'),\n    \n])->otherItems();\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Constants\\schemas\\rest.config.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nuse Nette\\Schema\\Expect;\n\nreturn Expect::structure([\n    'force_https'     => Expect::bool()->default(false),\n    'allowed_methods' => Expect::listOf('string')->default(['GET', 'POST', 'PUT', 'DELETE', 'PATCH']),\n    'format'          => Expect::string()->default('json'),\n    'strict'          => Expect::bool()->default(true),\n    'fields'          => Expect::arrayOf('string', 'string'),\n    'ip_blacklist'    => Expect::listOf('string'),\n    'ip_whitelist'    => Expect::listOf('string'),\n    'ajax_only'       => Expect::bool()->default(false),\n    'auth '           => Expect::anyOf('jwt', 'session')->default('jwt'),\n    'jwt'             => Expect::arrayOf('mixed', 'string'),\n])->otherItems();\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null]},{"name":"src\\Controllers\\ApplicationController.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Controllers;\n\nuse BlitzPHP\\Loader\\Services;\nuse BlitzPHP\\Router\\Dispatcher;\nuse BlitzPHP\\View\\View;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse ReflectionClass;\nuse ReflectionException;\n\n\/**\n * Le contr\u00f4leur de base pour les applications MVC\n *\/\nclass ApplicationController extends BaseController\n{\n    \/**\n     * @var array Donn\u00e9es partag\u00e9es entre toutes les vue charg\u00e9es \u00e0 partir d'un controleur\n     *\/\n    protected $viewDatas = [];\n\n    \/**\n     * @var string Layout a utiliser\n     *\/\n    protected $layout;\n\n    \/**\n     * Charge une vue\n     *\n     * @throws ReflectionException\n     *\/\n    final protected function view(string $view, ?array $data = [], ?array $options = []): View\n    {\n        $reflection = new ReflectionClass(static::class);\n        $path       = str_replace([CONTROLLER_PATH, 'Controller', '.php'], '', $reflection->getFileName());\n        $path       = trim(strtolower($path), '\/\\\\');\n\n        $object = Services::viewer(false);\n\n        $object->setData($data)->setOptions($options);\n\n        if (! empty($this->layout) && is_string($this->layout)) {\n            $object->setLayout($this->layout);\n        }\n\n        if (! empty($this->viewDatas) && is_array($this->viewDatas)) {\n            $object->addData($this->viewDatas);\n        }\n\n        return $object->display($path . '\/' . $view);\n    }\n\n    \/**\n     * Charge et rend directement une vue\n     *\/\n    final protected function render(?string $view = null, ?array $data = [], ?array $options = []): ResponseInterface\n    {\n        if (empty($view)) {\n            $view = Dispatcher::getMethod();\n        }\n\n        $view = $this->view($view, $data, $options)->get();\n\n        return $this->response->withBody(to_stream($view));\n    }\n\n    \/**\n     * Defini des donnees \u00e0 distribuer \u00e0 toutes les vues\n     *\n     * @param mixed $value\n     *\/\n    final protected function addData(string|array $key, $value = null): self\n    {\n        $data = $key;\n\n        if (is_string($key)) {\n            $data = [$key => $value];\n        }\n\n        $this->viewDatas = array_merge($this->viewDatas, $data);\n\n        return $this;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,0,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,0,null,null,null]},{"name":"src\\Controllers\\BaseController.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Controllers;\n\nuse BlitzPHP\\Exceptions\\HttpException;\nuse BlitzPHP\\Http\\Response;\nuse BlitzPHP\\Http\\ServerRequest;\nuse BlitzPHP\\Router\\Dispatcher;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Log\\LoggerInterface;\nuse ReflectionClass;\nuse ReflectionException;\n\n\/**\n * Contr\u00f4leur de base pour toute application BlitzPHP\n *\/\nabstract class BaseController\n{\n    \/**\n     * Helpers qui seront automatiquement charg\u00e9s lors de l'instanciation de la classe.\n     *\n     * @var array\n     *\/\n    protected $helpers = [];\n\n    \/**\n     * Le mod\u00e8le qui contient les donn\u00e9es de cette ressource\n     *\n     * @var string|null\n     *\/\n    protected $modelName;\n\n    \/**\n     * Le mod\u00e8le qui contient les donn\u00e9es de cette ressource\n     *\n     * @var object|null\n     *\/\n    protected $model;\n\n    \/**\n     * Instance de l'objet Request principal.\n     *\n     * @var ServerRequest\n     *\/\n    protected $request;\n\n    \/**\n     * Instance de l'objet de Response principal.\n     *\n     * @var Response\n     *\/\n    protected $response;\n\n    \/**\n     * Instance de logger \u00e0 utiliser.\n     *\n     * @var LoggerInterface\n     *\/\n    protected $logger;\n\n    \/**\n     * Devrait appliquer l'acc\u00e8s HTTPS pour toutes les m\u00e9thodes de ce contr\u00f4leur.\n     *\n     * @var int Nombre de secondes pour d\u00e9finir l'en-t\u00eate HSTS\n     *\/\n    protected $forceHTTPS = 0;\n\n    \/**\n     * Constructor.\n     *\n     * @throws HttpException\n     *\/\n    public function initialize(ServerRequestInterface $request, ResponseInterface $response, LoggerInterface $logger)\n    {\n        $this->request  = $request; \/\/ @phpstan-ignore-line\n        $this->response = $response; \/\/ @phpstan-ignore-line\n        $this->logger   = $logger;\n\n        if ($this->forceHTTPS > 0) {\n            $this->forceHTTPS($this->forceHTTPS);\n        }\n\n        $this->getModel();\n\n        helper($this->helpers);\n    }\n\n    \/**\n     * D\u00e9finissez ou modifiez le mod\u00e8le auquel ce contr\u00f4leur est li\u00e9.\n     * \u00c9tant donn\u00e9 le nom ou l'objet, d\u00e9terminer l'autre.\n     *\n     * @param object|string|null $which\n     *\/\n    protected function setModel($which = null)\n    {\n        if ($which) {\n            $this->model     = is_object($which) ? $which : null;\n            $this->modelName = is_object($which) ? null : $which;\n        }\n\n        if (empty($this->model) && ! empty($this->modelName) && class_exists($this->modelName)) {\n            \/\/ $this->model = model($this->modelName);\n        }\n\n        if (! empty($this->model) && empty($this->modelName)) {\n            $this->modelName = get_class($this->model);\n        }\n    }\n\n    \/**\n     * Une m\u00e9thode pratique \u00e0 utiliser lorsque vous devez vous assurer qu'un seul\n     * La m\u00e9thode est accessible uniquement via HTTPS. Si ce n'est pas le cas, alors une redirection\n     * reviendra \u00e0 cette m\u00e9thode et l'en-t\u00eate HSTS sera envoy\u00e9\n     * pour que les navigateurs modernes transforment automatiquement les requ\u00eates.\n     *\n     * @param int $duration Le nombre de secondes pendant lesquelles ce lien doit \u00eatre\n     *                      consid\u00e9r\u00e9 comme s\u00fbr pour. Uniquement avec en-t\u00eate HSTS.\n     *                      La valeur par d\u00e9faut est 1 an.\n     *\n     * @throws HttpException\n     *\/\n    protected function forceHTTPS(int $duration = 31536000)\n    {\n        force_https($duration, $this->request, $this->response);\n    }\n\n    \/**\n     * Fournit un moyen simple de se lier \u00e0 la classe principale de BlitzPHP\n     * et de lui indiquer la dur\u00e9e de mise en cache de la page actuelle.\n     *\/\n    protected function cachePage(int $time)\n    {\n        Dispatcher::cache($time);\n    }\n\n    \/**\n     * Recherche le model par defaut (\u00e0 base de son nom) du controleur\n     *\n     * @throws ReflectionException\n     *\/\n    private function getModel()\n    {\n        if (! empty($this->modelName)) {\n            $this->setModel($this->modelName);\n\n            return;\n        }\n\n        $reflection = new ReflectionClass(static::class);\n        $model      = str_replace([CONTROLLER_PATH, 'Controller', '.php'], '', $reflection->getFileName()) . 'Model';\n\n        if (file_exists(MODEL_PATH . $model . '.php')) {\n            $this->setModel($model);\n        }\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,0,null,null,0,null,null,null,null]},{"name":"src\\Controllers\\RestController.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Controllers;\n\nuse BlitzPHP\\Contracts\\Http\\StatusCode;\nuse BlitzPHP\\Formatter\\Formatter;\nuse BlitzPHP\\Traits\\ApiResponseTrait;\nuse stdClass;\n\n\/**\n * Le contr\u00f4leur de base pour les API REST\n *\/\nclass RestController extends BaseController\n{\n    use ApiResponseTrait;\n\n    \/**\n     * Configurations\n     *\n     * @var stdClass\n     *\/\n    protected $config;\n\n    \/**\n     * Langue \u00e0 utiliser\n     *\n     * @var string\n     *\/\n    private $locale;\n\n    \/**\n     * Type mime associ\u00e9 \u00e0 chaque format de sortie\n     *\n     * R\u00e9pertoriez tous les formats pris en charge, le premi\u00e8re sera le format par d\u00e9faut.\n     *\/\n    protected $mimes = [\n        'json' => 'application\/json',\n        'csv'  => 'application\/csv',\n        \/\/ 'html'       => 'text\/html',\n        'jsonp'      => 'application\/javascript',\n        'php'        => 'text\/plain',\n        'serialized' => 'application\/vnd.php.serialized',\n        'xml'        => 'application\/xml',\n\n        'array' => 'php\/array',\n    ];\n\n    public function __construct()\n    {\n        $this->config = (object) config('rest');\n\n        $locale       = $this->config->language ?? null;\n        $locale       = ! empty($locale) ? $locale : config('app.language');\n        $this->locale = ! empty($locale) ? $locale : 'en';\n    }\n\n    \/**\n     * Fournit une m\u00e9thode simple et unique pour renvoyer une r\u00e9ponse d'API, format\u00e9e\n     * pour correspondre au format demand\u00e9, avec le type de contenu et le code d'\u00e9tat appropri\u00e9s.\n     *\n     * @param mixed    $data   Les donnees a renvoyer\n     * @param int|null $status Le statut de la reponse\n     *\/\n    final protected function respond($data, ?int $status = StatusCode::OK)\n    {\n        \/\/ Si les donn\u00e9es sont NULL et qu'aucun code d'\u00e9tat HTTP n'est fourni, affichage, erreur et sortie\n        if ($data === null && $status === null) {\n            $status = StatusCode::NOT_FOUND;\n        }\n\n        $this->response = $this->response->withStatus($status)->withCharset(strtolower(config('app.charset') ?? 'utf-8'));\n\n        $this->_parseResponse($data);\n\n        return $this->response;\n    }\n\n    \/**\n     * Utilis\u00e9 pour les \u00e9checs g\u00e9n\u00e9riques pour lesquels aucune m\u00e9thode personnalis\u00e9e n'existe.\n     *\n     * @param string          $message Le message d\u00e9crivant l'erreur\n     * @param int             $status  Code d'\u00e9tat HTTP\n     * @param int|string|null $code    Code d'erreur personnalis\u00e9, sp\u00e9cifique \u00e0 l'API\n     * @param array           $errors  La liste des erreurs rencontr\u00e9es\n     *\/\n    final protected function respondFail(?string $message = \"Une erreur s'est produite\", ?int $status = StatusCode::INTERNAL_ERROR, int|string|null $code = null, array $errors = [])\n    {\n        $message = $message ?: \"Une erreur s'est produite\";\n        $code    = ! empty($code) ? $code : $status;\n\n        $response = [\n            $this->config->field['message'] ?? 'message' => $message,\n        ];\n        if (! empty($this->config->field['status'])) {\n            $response[$this->config->field['status']] = false;\n        }\n        if (! empty($this->config->field['code'])) {\n            $response[$this->config->field['code']] = $code;\n        }\n        if (! empty($errors)) {\n            $response[$this->config->field['errors'] ?? 'errors'] = $errors;\n        }\n\n        if ($this->config->strict !== true) {\n            $status = StatusCode::OK;\n        }\n\n        return $this->respond($response, $status);\n    }\n\n    \/**\n     * Utilis\u00e9 pour les succ\u00e8s g\u00e9n\u00e9riques pour lesquels aucune m\u00e9thode personnalis\u00e9e n'existe.\n     *\n     * @param mixed|null $result\n     *\/\n    final protected function respondSuccess(?string $message = 'Resultat', $result = null, ?int $status = StatusCode::OK)\n    {\n        $message = $message ?: 'Resultat';\n        $status  = ! empty($status) ? $status : StatusCode::OK;\n\n        $response = [\n            $this->config->field['message'] ?? 'message' => $message,\n        ];\n        if (! empty($this->config->field['status'])) {\n            $response[$this->config->field['status']] = true;\n        }\n        if (is_array($result)) {\n            $result = array_map(fn ($element) => $this->formatEntity($element), $result);\n        }\n\n        $response[$this->config->field['result'] ?? 'result'] = $this->formatEntity($result);\n\n        return $this->respond($response, $status);\n    }\n\n    \/**\n     * Formatte les donn\u00e9es \u00e0 renvoyer lorsqu'il s'agit des objets de la classe Entity\n     *\n     * @param mixed $element\n     *\n     * @return mixed\n     *\/\n    protected function formatEntity($element)\n    {\n        \/*\n        if ($element instanceof Entity) {\n            if (method_exists($element, 'format')) {\n                return Services::injector()->call([$element, 'format']);\n            }\n\n            return call_user_func([$element, 'toArray']);\n        }\n        *\/\n        return $element;\n    }\n\n    \/**\n     * Formatte les donnees a envoyer au bon format\n     *\n     * @param mixed $data Les donnees a envoyer\n     *\/\n    private function _parseResponse($data)\n    {\n        $format = strtolower($this->config['return_format']);\n        $mime   = null;\n\n        if (array_key_exists($format, $this->mimes)) {\n            $mime = $this->mimes[$format];\n        } elseif (in_array($format, $this->mimes, true)) {\n            $mime = $format;\n        }\n\n        \/\/ Si la m\u00e9thode de format existe, appelle et renvoie la sortie dans ce format\n        if (! empty($mime)) {\n            $output = Formatter::type($mime)->format($data);\n\n            \/\/ D\u00e9finit l'en-t\u00eate du format\n            \/\/ Ensuite, v\u00e9rifiez si le client a demand\u00e9 un rappel, et si la sortie contient ce rappel :\n            $callback = $this->request->getQuery('callback');\n            if (! empty($callback) && $mime === $this->mimes['json'] && preg_match('\/^' . $callback . '\/', $output)) {\n                $this->response = $this->response->withType($this->mimes['jsonp']);\n            } else {\n                $this->response = $this->response->withType($mime === $this->mimes['array'] ? $this->mimes['json'] : $mime);\n            }\n\n            \/\/ Un tableau doit \u00eatre analys\u00e9 comme une cha\u00eene, afin de ne pas provoquer d'erreur de tableau en cha\u00eene\n            \/\/ Json est la forme la plus appropri\u00e9e pour un tel type de donn\u00e9es\n            if ($mime === $this->mimes['array']) {\n                $output = Formatter::type($this->mimes['json'])->format($output);\n            }\n        } else {\n            \/\/ S'il s'agit d'un tableau ou d'un objet, analysez-le comme un json, de mani\u00e8re \u00e0 \u00eatre une 'cha\u00eene'\n            if (is_array($data) || is_object($data)) {\n                $data = Formatter::type($this->mimes['json'])->format($data);\n            }\n            \/\/ Le format n'est pas pris en charge, sortez les donn\u00e9es brutes sous forme de cha\u00eene\n            $output = $data;\n        }\n\n        $this->response = $this->response->withStringBody($output);\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,0,null,0,null,null,0,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,null,0,null,0,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,0,null,0,null,null,null,null,0,null,null,null,0,null,0,null,0,null,null,null,null,null,0,null,null,null,null,0,null,null,0,null,null,0,null,null,null]},{"name":"src\\Core\\App.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Core;\n\nuse BlitzPHP\\Http\\Uri;\nuse BlitzPHP\\Utilities\\Helpers;\nuse InvalidArgumentException;\n\n\/**\n * Il est responsable de l'emplacement des ressources et de la gestion des chemins.\n *\n * ### Ajout de chemins\n *\n * Des chemins suppl\u00e9mentaires pour les mod\u00e8les et les plugins sont configur\u00e9s avec Configurer maintenant. Voir config\/app.php pour un\n * Exemple. Les variables `App.paths.plugins` et `App.paths.templates` sont utilis\u00e9es pour configurer les chemins des plugins\n * et mod\u00e8les respectivement. Toutes les ressources bas\u00e9es sur les classes doivent \u00eatre mapp\u00e9es \u00e0 l'aide du chargeur automatique de votre application.\n *\n * ### Inspecter les chemins charg\u00e9s\n *\n * Vous pouvez inspecter les chemins actuellement charg\u00e9s en utilisant `App::classPath('Controller')` par exemple pour voir les chemins charg\u00e9s\n * chemins de contr\u00f4leur.\n *\n * Il est \u00e9galement possible d'inspecter les chemins des classes de plugins, par exemple, pour obtenir\n * le chemin vers les assistants d'un plugin que vous appelleriez `App::classPath('View\/Helper', 'MyPlugin')`\n *\n * ### Localisation des plugins\n *\n * Les plugins peuvent \u00e9galement \u00eatre localis\u00e9s avec l'application. Utiliser Plugin::path('DebugKit') par exemple,\n * vous donne le chemin complet vers le plugin DebugKit.\n *\n * @creadit <a href=\"https:\/\/book.cakephp.org\/4\/en\/core-libraries\/app.html\">CakePHP - Cake\\Core\\App<\/a>\n *\/\nclass App\n{\n    \/**\n     * Renvoie le nom de la classe dans le namespace. Cette m\u00e9thode v\u00e9rifie si la classe est d\u00e9finie sur le\n     * application\/plugin, sinon essayez de charger depuis le noyau de BlitzPHP\n     *\n     * @param string $type Type de la classe\n     *\n     * @return string|null Nom de classe avec le namespace, null si la classe est introuvable.\n     * @psalm-return class-string|null\n     *\/\n    public static function className(string $class, string $type = '', string $suffix = ''): ?string\n    {\n        if (strpos($class, '\\\\') !== false) {\n            return class_exists($class) ? $class : null;\n        }\n\n        [$plugin, $name] = Helpers::pluginSplit($class);\n        $fullname        = '\\\\' . str_replace('\/', '\\\\', $type . '\\\\' . $name) . $suffix;\n\n        $base = $plugin ?: APP_NAMESPACE;\n        if ($base !== null) {\n            $base = str_replace('\/', '\\\\', rtrim($base, '\\\\'));\n\n            if (static::_classExistsInBase($fullname, $base)) {\n                \/** @var class-string *\/\n                return $base . $fullname;\n            }\n        }\n\n        if ($plugin || ! static::_classExistsInBase($fullname, 'BlitzPHP')) {\n            return null;\n        }\n\n        \/** @var class-string *\/\n        return 'BlitzPHP' . $fullname;\n    }\n\n    \/**\n     * Renvoie le nom de division du plugin d'une classe\n     *\n     * Exemples:\n     *\n     * ```\n     * App::shortName(\n     *     'SomeVendor\\SomePlugin\\Controller\\Component\\TestComponent',\n     *     'Controller\/Component',\n     *     'Component'\n     * )\n     * ```\n     *\n     * Returns: SomeVendor\/SomePlugin.Test\n     *\n     * ```\n     * App::shortName(\n     *     'SomeVendor\\SomePlugin\\Controller\\Component\\Subfolder\\TestComponent',\n     *     'Controller\/Component',\n     *     'Component'\n     * )\n     * ```\n     *\n     * Returns: SomeVendor\/SomePlugin.Subfolder\/Test\n     *\n     * ```\n     * App::shortName(\n     *     'Cake\\Controller\\Component\\AuthComponent',\n     *     'Controller\/Component',\n     *     'Component'\n     * )\n     * ```\n     *\n     * Returns: Auth\n     *\n     * @param string $type Type de la classe\n     *\n     * @return string Plugin split name of class\n     *\/\n    public static function shortName(string $class, string $type, string $suffix = ''): string\n    {\n        $class = str_replace('\\\\', '\/', $class);\n        $type  = '\/' . $type . '\/';\n\n        $pos = strrpos($class, $type);\n        if ($pos === false) {\n            return $class;\n        }\n\n        $pluginName = (string) substr($class, 0, $pos);\n        $name       = (string) substr($class, $pos + strlen($type));\n\n        if ($suffix) {\n            $name = (string) substr($name, 0, -strlen($suffix));\n        }\n\n        $nonPluginNamespaces = [\n            'BlitzPHP',\n            str_replace('\\\\', '\/', APP_NAMESPACE),\n        ];\n        if (in_array($pluginName, $nonPluginNamespaces, true)) {\n            return $name;\n        }\n\n        return $pluginName . '.' . $name;\n    }\n\n    \/**\n     * _classExistsInBase\n     *\n     * Enveloppe d'isolation de test\n     *\/\n    protected static function _classExistsInBase(string $classname, string $namespace): bool\n    {\n        return class_exists($namespace . $classname);\n    }\n\n    \/**\n     * Renvoie le chemin complet vers un paquet \u00e0 l'int\u00e9rieur du noyau BlitzPHP\n     *\n     * Usage:\n     *\n     * ```\n     * App::core('Cache\/Engine');\n     * ```\n     *\n     * Retournera le chemin complet vers le package des moteurs de cache.\n     *\n     * @param string $type Package type.\n     *\n     * @return string[] Chemin d'acc\u00e8s complet au package\n     *\/\n    public static function core(string $type): array\n    {\n        return [SYST_PATH . str_replace('\/', DIRECTORY_SEPARATOR, $type) . DIRECTORY_SEPARATOR];\n    }\n\n    \/**\n     * Utilis\u00e9 par les autres fonctions d'URL pour construire un\n     * URI sp\u00e9cifique au framework bas\u00e9 sur la configuration de l'application.\n     *\n     * @internal En dehors du framework, ceci ne doit pas \u00eatre utilis\u00e9 directement.\n     *\n     * @param string $relativePath Peut inclure des requ\u00eates ou des fragments\n     *\n     * @throws InvalidArgumentException Pour les chemins ou la configuration non valides\n     *\/\n    public static function getUri(string $relativePath = ''): Uri\n    {\n        $config = (object) config('app');\n\n        if ($config->base_url === '') {\n            throw new InvalidArgumentException(__METHOD__ . ' requires a valid baseURL.');\n        }\n\n        \/\/ Si un URI complet a \u00e9t\u00e9 pass\u00e9, convertissez-le\n        if (is_int(strpos($relativePath, ':\/\/'))) {\n            $full         = new Uri($relativePath);\n            $relativePath = Uri::createURIString(null, null, $full->getPath(), $full->getQuery(), $full->getFragment());\n        }\n\n        $relativePath = URI::removeDotSegments($relativePath);\n\n        \/\/ Construire l'URL compl\u00e8te bas\u00e9e sur $config et $relativePath\n        $url = rtrim($config->base_url, '\/ ') . '\/';\n\n        \/\/ Recherche une page d'index\n        if ($config->index_page !== '') {\n            $url .= $config->index_page;\n\n            \/\/ V\u00e9rifie si nous avons besoin d'un s\u00e9parateur\n            if ($relativePath !== '' && $relativePath[0] !== '\/' && $relativePath[0] !== '?') {\n                $url .= '\/';\n            }\n        }\n\n        $url .= $relativePath;\n\n        $uri = new Uri($url);\n\n        \/\/ V\u00e9rifie si le sch\u00e9ma baseURL doit \u00eatre contraint dans sa version s\u00e9curis\u00e9e\n        if ($config->force_global_secure_requests && $uri->getScheme() === 'http') {\n            $uri->setScheme('https');\n        }\n\n        return $uri;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,0,null,0,null,0,null,null,null,0,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,0,null,null,0,0,null,null,0,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,0,0,null,null,0,null,null,0,null,null,null,0,null,null,null,0,null,null,null,0,null,0,null,null,null,0,null,null,0,null,null,null]},{"name":"src\\Debug\\Logger.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Debug;\n\nuse InvalidArgumentException;\nuse Monolog\\Formatter\\HtmlFormatter;\nuse Monolog\\Formatter\\JsonFormatter;\nuse Monolog\\Formatter\\LineFormatter;\nuse Monolog\\Formatter\\NormalizerFormatter;\nuse Monolog\\Formatter\\ScalarFormatter;\nuse Monolog\\Handler\\BrowserConsoleHandler;\nuse Monolog\\Handler\\ChromePHPHandler;\nuse Monolog\\Handler\\ErrorLogHandler;\nuse Monolog\\Handler\\FirePHPHandler;\nuse Monolog\\Handler\\NativeMailerHandler;\nuse Monolog\\Handler\\RotatingFileHandler;\nuse Monolog\\Handler\\StreamHandler;\nuse Monolog\\Handler\\TelegramBotHandler;\nuse Monolog\\Logger as MonologLogger;\nuse Monolog\\Processor\\HostnameProcessor;\nuse Monolog\\Processor\\IntrospectionProcessor;\nuse Monolog\\Processor\\MemoryUsageProcessor;\nuse Monolog\\Processor\\ProcessIdProcessor;\nuse Monolog\\Processor\\PsrLogMessageProcessor;\nuse Monolog\\Processor\\UidProcessor;\nuse Monolog\\Processor\\WebProcessor;\nuse Psr\\Log\\LoggerInterface;\nuse Psr\\Log\\LogLevel;\nuse stdClass;\nuse Stringable;\n\nclass Logger implements LoggerInterface\n{\n    \/**\n     * Options de configuration provenant de app\/Config\/log.php\n     *\n     * @var object\n     *\/\n    private $config;\n\n    \/**\n     * Instance monolog\n     *\n     * @var MonologLogger\n     *\/\n    private $monolog;\n\n    public function __construct()\n    {\n        $this->config = (object) config('log');\n\n        $this->monolog = new MonologLogger($this->config->name ?? 'application');\n\n        foreach (($this->config->handlers ?? []) as $handler => $options) {\n            $this->pushHandler($handler, (object) $options);\n        }\n\n        foreach (($this->config->processors ?? []) as $processor) {\n            $this->pushProcessor($processor);\n        }\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function emergency(string|Stringable $message, array $context = []): void\n    {\n        $this->monolog->emergency($message, $context);\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function alert(string|Stringable $message, array $context = []): void\n    {\n        $this->monolog->alert($message, $context);\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function critical(string|Stringable $message, array $context = []): void\n    {\n        $this->monolog->critical($message, $context);\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function error(string|Stringable $message, array $context = []): void\n    {\n        $this->monolog->error($message, $context);\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function warning(string|Stringable $message, array $context = []): void\n    {\n        $this->monolog->warning($message, $context);\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function notice(string|Stringable $message, array $context = []): void\n    {\n        $this->monolog->notice($message, $context);\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function info(string|Stringable $message, array $context = []): void\n    {\n        $this->monolog->info($message, $context);\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function debug(string|Stringable $message, array $context = []): void\n    {\n        $this->monolog->debug($message, $context);\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function log($level, string|Stringable $message, array $context = []): void\n    {\n        $this->monolog->log($level, $message, $context);\n    }\n\n    \/**\n     * Ajoute les differents gestionnaires prise en charge par la configuration \/app\/Config\/log.php\n     *\/\n    private function pushHandler(string $handler, stdClass $options)\n    {\n        switch ($handler) {\n            case 'error':\n                $this->pushErrorHandler($options);\n                break;\n\n            case 'email':\n                $this->pushEmailHandler($options);\n                break;\n\n            case 'telegram':\n                $this->pushTelegramHandler($options);\n                break;\n\n            case 'chrome':\n                $this->pushChromeHandler($options);\n                break;\n\n            case 'firebug':\n                $this->pushFirebugHandler($options);\n                break;\n\n            case 'browser':\n                $this->pushBrowserHandler($options);\n                break;\n\n            default:\n                \/\/ File handler\n                $this->pushFileHandler($options);\n                break;\n        }\n    }\n\n    \/**\n     * Ajoute un gestionnaire de log de type Fichier\n     *\n     * Enregistre les probl\u00e8mes dans des fichiers de journalisation\n     *\/\n    private function pushFileHandler(stdClass $options): void\n    {\n        $directory = rtrim($options->path ?: LOG_PATH, DS) . DS;\n        $filename  = strtolower($this->config->name ?: 'application');\n        $extension = $options->extension ?: '.log';\n\n        if ($options->dayly_rotation ?: true === true) {\n            $handler = new RotatingFileHandler($directory . $filename . $extension, $options->max_files ?: 0, $options->level ?: LogLevel::DEBUG, true, $options->permissions ?: 644);\n        } else {\n            $handler = new StreamHandler($directory . $filename . $extension, $options->level ?: LogLevel::DEBUG, true, $options->permissions ?: 644);\n        }\n\n        $this->monolog->pushHandler(\n            $this->setFormatter($handler, ['json', 'line', 'scalar', 'normalizer'], $options->format)\n        );\n    }\n\n    \/**\n     * Ajoute un gestionnaire de log de type PHP error_log\n     *\n     * Enregistre les probl\u00e8mes dans la fonction PHP error_log().\n     *\/\n    private function pushErrorHandler(stdClass $options): void\n    {\n        $handler = new ErrorLogHandler($options->type ?: ErrorLogHandler::OPERATING_SYSTEM, $options->level ?: LogLevel::DEBUG);\n\n        $this->monolog->pushHandler(\n            $this->setFormatter($handler, ['json', 'line'], $options->format)\n        );\n    }\n\n    \/**\n     * Ajoute un gestionnaire de log de type Email\n     *\n     * Envoi un email \u00e0 l'administrateur en cas de probl\u00e8me\n     *\/\n    private function pushEmailHandler(stdClass $options): void\n    {\n        $handler = new NativeMailerHandler($options->to, $options->subject, $options->from, $options->level ?: LogLevel::ERROR);\n\n        $this->monolog->pushHandler(\n            $this->setFormatter($handler, ['html', 'json', 'line'], $options->format)\n        );\n    }\n\n    private function pushTelegramHandler(stdClass $options): void\n    {\n        $handler = new TelegramBotHandler($options->api_key, $options->channel, $options->level ?: LogLevel::DEBUG);\n\n        $this->monolog->pushHandler(\n            $this->setFormatter($handler, [], $options->format)\n        );\n    }\n\n    \/**\n     * Ajoute un gestionnaire de log pour chrome\n     *\n     * Affichera les log dans la console de chrome\n     *\/\n    private function pushChromeHandler(stdClass $options): void\n    {\n        $handler = new ChromePHPHandler($options->level ?: LogLevel::DEBUG);\n\n        $this->monolog->pushHandler(\n            $this->setFormatter($handler, [], $options->format)\n        );\n    }\n\n    \/**\n     * Ajoute un gestionnaire de log pour firebug\n     *\n     * Affichera les log dans la console firebug\n     *\/\n    private function pushFirebugHandler(stdClass $options): void\n    {\n        $handler = new FirePHPHandler();\n\n        $this->monolog->pushHandler(\n            $this->setFormatter($handler, [], $options->format)\n        );\n    }\n\n    \/**\n     * Ajoute un gestionnaire de log pour les navigateurs\n     *\n     * Affichera les log dans la console des navigateurs\n     *\/\n    private function pushBrowserHandler(stdClass $options): void\n    {\n        $handler = new BrowserConsoleHandler();\n\n        $this->monolog->pushHandler(\n            $this->setFormatter($handler, [], $options->format)\n        );\n    }\n\n    \/**\n     * Ajoute les processeur au gestionnaire de log\n     *\n     * Un processor permet d'ajouter des m\u00e9ta donn\u00e9es aux log g\u00e9n\u00e9r\u00e9s\n     *\/\n    private function pushProcessor(string $processor)\n    {\n        switch ($processor) {\n            case 'web':\n                $this->monolog->pushProcessor(new WebProcessor());\n                break;\n\n            case 'introspection':\n                $this->monolog->pushProcessor(new IntrospectionProcessor());\n                break;\n\n            case 'hostname':\n                $this->monolog->pushProcessor(new HostnameProcessor());\n                break;\n\n            case 'process_id':\n                $this->monolog->pushProcessor(new ProcessIdProcessor());\n                break;\n\n            case 'uid':\n                $this->monolog->pushProcessor(new UidProcessor());\n                break;\n\n            case 'memory_usage':\n                $this->monolog->pushProcessor(new MemoryUsageProcessor());\n                break;\n\n            case 'psr':\n                $this->monolog->pushProcessor(new PsrLogMessageProcessor());\n                break;\n\n            default:\n                throw new InvalidArgumentException('Invalid formatter for log processor. Accepts values: web\/introspection\/hostname\/process_id\/uid\/memory_usage\/psr');\n        }\n    }\n\n    \/**\n     * Definit le formateur des gestionnaire\n     *\n     * @param array $allowed Formats autoris\u00e9s\n     *\/\n    private function setFormatter(object $handler, array $allowed, ?string $format = 'json'): object\n    {\n        if (! method_exists($handler, 'setFormatter')) {\n            return $handler;\n        }\n\n        if (empty($format)) {\n            $format = 'json';\n        }\n        if (! empty($allowed) && ! in_array($format, $allowed, true)) {\n            throw new InvalidArgumentException('Invalid formatter for log file handler. Accepts values: ' . implode('\/', $allowed));\n        }\n\n        switch ($format) {\n            case 'json':\n                $handler->setFormatter(new JsonFormatter());\n                break;\n\n            case 'line':\n                $handler->setFormatter(new LineFormatter(null, $this->config->date_format ?? 'Y-m-d H:i:s'));\n                break;\n\n            case 'normalizer':\n                $handler->setFormatter(new NormalizerFormatter($this->config->date_format ?? 'Y-m-d H:i:s'));\n                break;\n\n            case 'scalar':\n                $handler->setFormatter(new ScalarFormatter($this->config->date_format ?? 'Y-m-d H:i:s'));\n                break;\n\n            case 'html':\n                $handler->setFormatter(new HtmlFormatter($this->config->date_format ?? 'Y-m-d H:i:s'));\n                break;\n\n            default:\n                break;\n        }\n\n        return $handler;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,0,0,0,null,null,0,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,0,null,null,0,null,null,0,null,null,null]},{"name":"src\\Debug\\Timer.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Debug;\n\nuse RuntimeException;\n\nclass Timer\n{\n    \/**\n     * Liste de toutes les minuteries.\n     *\n     * @var array\n     *\/\n    protected $timers = [];\n\n    \/**\n     * D\u00e9marre une minuterie en cours d'ex\u00e9cution.\n     *\n     * Plusieurs appels peuvent \u00eatre effectu\u00e9s vers cette m\u00e9thode afin que plusieurs\n     * les points d'ex\u00e9cution peuvent \u00eatre mesur\u00e9s.\n     *\n     * @param string $name Le nom de cette minuterie.\n     * @param float  $time Permet \u00e0 l'utilisateur de fournir du temps.\n     *\/\n    public function start(string $name, ?float $time = null): self\n    {\n        $this->timers[strtolower($name)] = [\n            'start' => ! empty($time) ? $time : microtime(true),\n            'end'   => null,\n        ];\n\n        return $this;\n    }\n\n    \/**\n     * Arr\u00eate une minuterie en cours d'ex\u00e9cution.\n     *\n     * Si le minuteur n'est pas arr\u00eat\u00e9 avant l'appel de la m\u00e9thode timers(),\n     * il sera automatiquement arr\u00eat\u00e9 \u00e0 ce point.\n     *\n     * @param string $name Le nom de cette minuterie.\n     *\/\n    public function stop(string $name): self\n    {\n        $name = strtolower($name);\n\n        if (empty($this->timers[$name])) {\n            throw new RuntimeException('Cannot stop timer: invalid name given.');\n        }\n\n        $this->timers[$name]['end'] = microtime(true);\n\n        return $this;\n    }\n\n    \/**\n     * Renvoie la dur\u00e9e d'une minuterie enregistr\u00e9e.\n     *\n     * @param string $name     Le nom de la minuterie.\n     * @param int    $decimals Nombre de d\u00e9cimales.\n     *\n     * @return float|null Renvoie null si timer existe sous ce nom.\n     *                    Renvoie un flottant repr\u00e9sentant le nombre de\n     *                    secondes se sont \u00e9coul\u00e9es pendant que cette minuterie fonctionnait.\n     *\/\n    public function getElapsedTime(string $name, int $decimals = 4): ?float\n    {\n        $name = strtolower($name);\n\n        if (empty($this->timers[$name])) {\n            return null;\n        }\n\n        return $this->getDuration($this->timers[$name], $decimals);\n    }\n\n    \/**\n     * Renvoie le tableau des minuteurs, avec la dur\u00e9e pr\u00e9-calcul\u00e9e pour vous.\n     *\/\n    public function getTimers(int $decimals = 4): array\n    {\n        $timers = $this->timers;\n\n        foreach ($timers as &$timer) {\n            $timer['duration'] = $this->getDuration($timer, $decimals);\n        }\n\n        return $timers;\n    }\n\n    \/**\n     * V\u00e9rifie si oui ou non un minuteurs avec le nom sp\u00e9cifi\u00e9 existe.\n     *\/\n    public function has(string $name): bool\n    {\n        return array_key_exists(strtolower($name), $this->timers);\n    }\n\n    \/**\n     * Renvoie la dur\u00e9e d'une minuterie enregistr\u00e9e.\n     *\n     * @return float Renvoie un nombre flottant repr\u00e9sentant le nombre de\n     *               secondes qui se sont \u00e9coul\u00e9es pendant que cette minuterie fonctionnait.\n     *\/\n    private function getDuration(array $timer, int $decimals = 4): float\n    {\n        if (empty($timer['end'])) {\n            $timer['end'] = microtime(true);\n        }\n\n        return (float) number_format($timer['end'] - $timer['start'], $decimals);\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null]},{"name":"src\\Event\\Event.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Event;\n\nuse BlitzPHP\\Contracts\\Event\\EventInterface;\n\n\/**\n * Event\n *\n * @credit      https:\/\/www.phpclasses.org\/package\/9961-PHP-Manage-events-implementing-PSR-14-interface.html - Kiril Savchev <k.savchev@gmail.com>\n *\/\nclass Event implements EventInterface\n{\n    \/**\n     * le nom de l'evenement\n     *\n     * @var string\n     *\/\n    protected $name = '';\n\n    \/**\n     * La cible de l'evenement\n     *\n     * @var mixed\n     *\/\n    protected $target;\n\n    \/**\n     * Les param\u00e8tres de l'evenement\n     *\n     * @var array\n     *\/\n    protected $params = [];\n\n    \/**\n     * Indicateur indiquant si l'\u00e9v\u00e9nement doit \u00eatre arr\u00eat\u00e9 lors du d\u00e9clenchement\n     *\n     * @var bool\n     *\/\n    protected $isPropagationStopped = false;\n\n    \/**\n     * Creation de l'evenement\n     *\n     * @param mixed|null $target\n     *\/\n    public function __construct(?string $name = '', $target = null, array $params = [])\n    {\n        $this->name   = $name;\n        $this->target = $target;\n        $this->params = $params;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function setName(string $name): void\n    {\n        $this->name = $name;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getParams(): array\n    {\n        return $this->params;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getParam(string $name)\n    {\n        return $this->params[$name] ?? null;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function setParams(array $params): void\n    {\n        $this->params = $params;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getTarget()\n    {\n        return $this->target;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function setTarget($target): void\n    {\n        $this->target = $target;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function isPropagationStopped(): bool\n    {\n        return $this->isPropagationStopped;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function stopPropagation(bool $flag): void\n    {\n        $this->isPropagationStopped = $flag;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null]},{"name":"src\\Event\\EventListenerManagerTrait.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Event;\n\nuse BlitzPHP\\Contracts\\Event\\EventManagerInterface;\nuse Closure;\n\n\/**\n * EventListenerManagerTrait\n *\n * @credit      https:\/\/www.phpclasses.org\/package\/9961-PHP-Manage-events-implementing-PSR-14-interface.html - Kiril Savchev <k.savchev@gmail.com>\n *\/\ntrait EventListenerManagerTrait\n{\n    \/**\n     * L'actuel gestionnaire d'evenement\n     *\n     * @var EventManager\n     *\/\n    protected $eventManager;\n\n    \/**\n     * Modifie le gestionnaire d'evenement\n     *\/\n    public function setEventManager(EventManagerInterface $eventManager): self\n    {\n        $this->eventManager = $eventManager;\n\n        return $this;\n    }\n\n    \/**\n     *Renvoi le gestionnaire d'evenement\n     *\/\n    public function getEventManager(): EventManagerInterface\n    {\n        return $this->eventManager;\n    }\n\n    \/**\n     * Joindre un callback \u00e0 un \u00e9v\u00e9nement\n     *\n     * Si $bindContext est fourni, l'objet courant doit \u00eatre li\u00e9 comme\n     * un contexte au callback fourni.\n     *\/\n    public function addEventListener(string $event, Closure $callback, int $priority = 0, bool $bindContext = false): bool\n    {\n        if ($bindContext) {\n            $callback = Closure::bind($callback, $this, static::class);\n        }\n\n        return $this->eventManager->attach($event, $callback, $priority);\n    }\n\n    \/**\n     * D\u00e9clenche un \u00e9v\u00e9nement\n     *\n     * @param array|EventInterface $event\n     * @param mixed                $target\n     * @param array|object         $params\n     *\n     * @return mixed\n     *\/\n    public function fireEvent($event, $target = null, $params = [])\n    {\n        return $this->eventManager->trigger($event, $target, $params);\n    }\n\n    \/**\n     * Supprime un callback attach\u00e9 \u00e0 un \u00e9v\u00e9nement\n     *\/\n    public function removeEventListener(string $event, callable $callback): bool\n    {\n        return $this->eventManager->detach($event, $callback);\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null]},{"name":"src\\Event\\EventManager.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Event;\n\nuse BlitzPHP\\Contracts\\Event\\EventInterface;\nuse BlitzPHP\\Contracts\\Event\\EventManagerInterface;\n\n\/**\n * EventManager\n *\n * @credit      https:\/\/www.phpclasses.org\/package\/9961-PHP-Manage-events-implementing-PSR-14-interface.html - Kiril Savchev <k.savchev@gmail.com>\n *\/\nclass EventManager implements EventManagerInterface\n{\n    \/**\n     * Le nom g\u00e9n\u00e9rique de l'\u00e9v\u00e9nement\n     *\/\n    public const WILDCARD = '*';\n\n    \/**\n     * @var array\n     *\/\n    protected $events;\n\n    \/**\n     * Stocke des informations sur les \u00e9v\u00e9nements\n     * pour affichage dans la barre d'outils de d\u00e9bogage.\n     *\n     * @var array\n     *\/\n    protected static $performanceLog = [];\n\n    \/**\n     * Cr\u00e9er un objet gestionnaire d'\u00e9v\u00e9nements\n     *\n     * @param array $events [Optionnel]\n     *\/\n    public function __construct(array $events = [])\n    {\n        $this->events = $events;\n        if (! array_key_exists(self::WILDCARD, $this->events)) {\n            $this->events[self::WILDCARD] = [];\n        }\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function clearListeners(string $event): void\n    {\n        $this->events[$event] = [];\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function attach(string $event, callable $callback, int $priority = 0): bool\n    {\n        if (! array_key_exists($event, $this->events)) {\n            $this->events[$event] = [];\n        }\n        if (! array_key_exists($priority, $this->events[$event])) {\n            $this->events[$event][$priority] = [];\n        }\n\n        if (! in_array($callback, $this->events[$event][$priority], true)) {\n            $this->events[$event][$priority][] = $callback;\n\n            return true;\n        }\n\n        return false;\n    }\n\n    \/**\n     * Alias de la m\u00e9thode attach\n     *\/\n    public function on(string $event, callable $callback, int $priority = 0): bool\n    {\n        return $this->attach($event, $callback, $priority);\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function detach(string $event, callable $callback): bool\n    {\n        if (! array_key_exists($event, $this->events) || ! $this->events[$event]) {\n            return false;\n        }\n\n        $eventsAgregation = $this->events[$event];\n\n        foreach ($eventsAgregation as $priority => $events) {\n            if (is_array($events) && in_array($callback, $events, true)) {\n                $key = array_search($callback, $events, true);\n                unset($this->events[$event][$priority][$key]);\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function trigger($event, $target = null, $argv = [])\n    {\n        if (! ($event instanceof EventInterface)) {\n            $event = new Event($event, $target, $argv);\n        } else {\n            if ($target) {\n                $event->setTarget($target);\n            }\n            if ($argv) {\n                $event->setParams($argv);\n            }\n        }\n\n        $eventName = $event->getName();\n        if (! array_key_exists($eventName, $this->events)) {\n            $this->events[$eventName] = [];\n        }\n\n        $events = array_merge($this->events[self::WILDCARD], $this->events[$eventName]);\n        $result = null;\n\n        foreach ($events as $priority) {\n            if (! is_array($priority)) {\n                continue;\n            }\n\n            foreach ($priority as $callback) {\n                if ($event->isPropagationStopped()) {\n                    break 2;\n                }\n\n                $start = microtime(true);\n\n                $result = $callback($event, $result);\n\n                static::$performanceLog[] = [\n                    'start' => $start,\n                    'end'   => microtime(true),\n                    'event' => strtolower($eventName),\n                ];\n            }\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Getter pour les enregistrements du journal des performances.\n     *\/\n    public static function getPerformanceLogs(): array\n    {\n        return static::$performanceLog;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,0,0,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,0,null,0,null,null,0,0,null,null,null,0,null,null,null,null,0,null,null,0,null,0,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null]},{"name":"src\\Exceptions\\ConfigException.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Exceptions;\n\n\/**\n * Exception pour la journalisation automatique.\n *\/\nclass ConfigException extends CriticalError\n{\n    use DebugTraceableTrait;\n\n    \/**\n     * code d'erreur\n     *\n     * @var int\n     *\/\n    protected $code = 3;\n\n    public static function disabledMigrations()\n    {\n        return new static(lang('Migrations.disabled'));\n    }\n\n    public static function configDontExist(string $config, string $file)\n    {\n        return new static(lang('Config.fileDoesNotExist', [$config, $file]));\n    }\n\n    public static function viewAdapterConfigNotFound(string $adapter)\n    {\n        return new static(lang('Config.viewAdapterConfigNotFound', [$adapter]));\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null]},{"name":"src\\Exceptions\\DebugTraceableTrait.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Exceptions;\n\nuse BlitzPHP\\Loader\\Services;\nuse Throwable;\n\n\/**\n * Ce trait fournit aux exceptions du cadre la possibilit\u00e9 d'identifier\n * pr\u00e9cis\u00e9ment o\u00f9 l'exception a \u00e9t\u00e9 d\u00e9clench\u00e9e plut\u00f4t qu'instanci\u00e9e.\n *\n * Ceci est principalement utilis\u00e9 pour les exceptions instanci\u00e9es dans les factories.\n *\/\ntrait DebugTraceableTrait\n{\n    \/**\n     * Ajuste le constructeur de l'exception pour assigner le fichier\/la ligne \u00e0 o\u00f9\n     * il est r\u00e9ellement d\u00e9clench\u00e9 plut\u00f4t que d'\u00eatre instanci\u00e9.\n     *\/\n    final public function __construct(string $message = '', int $code = 0, ?Throwable $previous = null)\n    {\n        parent::__construct($message, $code, $previous);\n\n        $trace = $this->getTrace()[0];\n\n        if (isset($trace['class']) && $trace['class'] === static::class) {\n            [\n                'line' => $this->line,\n                'file' => $this->file,\n            ] = $trace;\n        }\n    }\n\n    \/**\n     * Obtenir le message syst\u00e8me traduit\n     *\n     * Utilisez une instance de langue non partag\u00e9e dans les services.\n     * Si une instance partag\u00e9e est cr\u00e9\u00e9e, la langue\n     * ont les param\u00e8tres r\u00e9gionaux actuels, donc m\u00eame si les utilisateurs appellent\n     * `$this->request->setLocale()` dans le contr\u00f4leur ensuite,\n     * les param\u00e8tres r\u00e9gionaux de la langue ne seront pas modifi\u00e9s.\n     *\/\n    protected static function lang(string $line, array $args = []): string\n    {\n        $lang = Services::language(null, false);\n\n        return $lang->getLine($line, $args);\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null]},{"name":"src\\Exceptions\\DownloadException.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Exceptions;\n\nuse RuntimeException;\n\n\/**\n * Class DownloadException\n *\/\nclass DownloadException extends RuntimeException implements ExceptionInterface\n{\n    use DebugTraceableTrait;\n\n    public static function cannotSetFilePath(string $path)\n    {\n        return new static(lang('HTTP.cannotSetFilepath', [$path]));\n    }\n\n    public static function cannotSetBinary()\n    {\n        return new static(lang('HTTP.cannotSetBinary'));\n    }\n\n    public static function notFoundDownloadSource()\n    {\n        return new static(lang('HTTP.notFoundDownloadSource'));\n    }\n\n    public static function cannotSetCache()\n    {\n        return new static(lang('HTTP.cannotSetCache'));\n    }\n\n    public static function cannotSetStatusCode(int $code, string $reason)\n    {\n        return new static(lang('HTTP.cannotSetStatusCode', [$code, $reason]));\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null]},{"name":"src\\Exceptions\\FormatException.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Exceptions;\n\nuse RuntimeException;\n\n\/**\n * FormatException\n *\/\nclass FormatException extends RuntimeException implements ExceptionInterface\n{\n    use DebugTraceableTrait;\n\n    \/**\n     * Lev\u00e9e lorsque la classe instanci\u00e9e n'existe pas.\n     *\/\n    public static function invalidFormatter(string $class)\n    {\n        return new static(lang('Format.invalidFormatter', [$class]));\n    }\n\n    \/**\n     * Lanc\u00e9 dans JSONFormatter lorsque le json_encode produit\n     * un code d'erreur autre que JSON_ERROR_NONE et JSON_ERROR_RECURSION.\n     *\/\n    public static function invalidJSON(?string $error = null)\n    {\n        return new static(lang('Format.invalidJSON', [$error]));\n    }\n\n    \/**\n     * Lev\u00e9 lorsque le type MIME fourni n'a pas\n     * classe Formatter d\u00e9finie.\n     *\/\n    public static function invalidMime(string $mime)\n    {\n        return new static(lang('Format.invalidMime', [$mime]));\n    }\n\n    \/**\n     * Lanc\u00e9 sur XMLFormatter lorsque l'extension `simplexml`\n     * N'est pas install\u00e9.\n     *\n     * @codeCoverageIgnore\n     *\/\n    public static function missingExtension()\n    {\n        return new static(lang('Format.missingExtension'));\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null]},{"name":"src\\Exceptions\\FrameworkException.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Exceptions;\n\nuse RuntimeException;\n\n\/**\n * Class FrameworkException\n *\n * Une collection d'exceptions lanc\u00e9es par le framework\n * qui ne peut \u00eatre d\u00e9termin\u00e9 qu'au moment de l'ex\u00e9cution.\n *\/\nclass FrameworkException extends RuntimeException implements ExceptionInterface\n{\n    use DebugTraceableTrait;\n\n    public static function enabledZlibOutputCompression()\n    {\n        return new static(lang('Core.enabledZlibOutputCompression'));\n    }\n\n    public static function invalidFile(string $path)\n    {\n        return new static(lang('Core.invalidFile', [$path]));\n    }\n\n    public static function copyError(string $path)\n    {\n        return new static(lang('Core.copyError', [$path]));\n    }\n\n    public static function missingExtension(string $extension)\n    {\n        if (strpos($extension, 'intl') !== false) {\n            \/\/ @codeCoverageIgnoreStart\n            $message = sprintf(\n                'The framework needs the following extension(s) installed and loaded: %s.',\n                $extension\n            );\n        \/\/ @codeCoverageIgnoreEnd\n        } else {\n            $message = lang('Core.missingExtension', [$extension]);\n        }\n\n        return new static($message);\n    }\n\n    public static function noHandlers(string $class)\n    {\n        return new static(lang('Core.noHandlers', [$class]));\n    }\n\n    public static function fabricatorCreateFailed(string $table, string $reason)\n    {\n        return new static(lang('Fabricator.createFailed', [$table, $reason]));\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null]},{"name":"src\\Exceptions\\HttpException.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Exceptions;\n\nclass HttpException extends FrameworkException\n{\n    public static function methodNotAllowed(string $method): self\n    {\n        return new static(self::lang('HTTP.methodNotAllowed', [$method]));\n    }\n\n    public static function invalidStatusCode(int $code)\n    {\n        return new static(lang('HTTP.invalidStatusCode', [$code]));\n    }\n\n    public static function invalidRedirectRoute(string $route)\n    {\n        return new static(lang('HTTP.invalidRoute', [$route]));\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null]},{"name":"src\\Exceptions\\LoadException.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Exceptions;\n\nuse OutOfBoundsException;\n\nclass LoadException extends OutOfBoundsException implements ExceptionInterface\n{\n    use DebugTraceableTrait;\n\n    \/**\n     * Code d'erreur\n     *\n     * @var int\n     *\/\n    protected $code = 404;\n\n    public static function helperNotFound(string $helper): self\n    {\n        return new static(self::lang('Loader.helperNotFound', [$helper]));\n    }\n\n    public static function libraryNotFound(string $library): self\n    {\n        return new static(self::lang('Loader.libraryNotFound', [$library]));\n    }\n\n    public static function libraryDontExist(string $library): self\n    {\n        return new static(self::lang('Loader.libraryDontExist', [$library]));\n    }\n\n    public static function modelNotFound(string $model, string $path): self\n    {\n        return new static(self::lang('Loader.modelNotFound', [$model, $path]));\n    }\n\n    public static function modelDontExist(string $model, string $path): self\n    {\n        return new static(self::lang('Loader.modelDontExist', [$model, $path]));\n    }\n\n    public static function langNotFound(string $lang): self\n    {\n        return new static(self::lang('Loader.langNotFound', [$lang]));\n    }\n\n    public static function controllerNotFound(string $controller, string $path): self\n    {\n        return new static(self::lang('Loader.controllerNotFound', [$controller, $path]));\n    }\n\n    public static function controllerDontExist(string $controller, string $path): self\n    {\n        return new static(self::lang('Loader.controllerDontExist', [$controller, $path]));\n    }\n\n    public static function providersDefinitionDontExist(string $filename): self\n    {\n        return new static('Unable to load system services definition file. The `' . $filename . '` file does not exist or cannot be read.');\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null]},{"name":"src\\Exceptions\\ModelException.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Exceptions;\n\n\/**\n * Model Exceptions.\n *\/\nclass ModelException extends FrameworkException\n{\n    public static function noPrimaryKey(string $modelName)\n    {\n        return new static(lang('Database.noPrimaryKey', [$modelName]));\n    }\n\n    public static function noDateFormat(string $modelName)\n    {\n        return new static(lang('Database.noDateFormat', [$modelName]));\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null]},{"name":"src\\Exceptions\\PageNotFoundException.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Exceptions;\n\nuse OutOfBoundsException;\n\nclass PageNotFoundException extends OutOfBoundsException implements ExceptionInterface\n{\n    use DebugTraceableTrait;\n\n    \/**\n     * Code d'erreur\n     *\n     * @var int\n     *\/\n    protected $code = 404;\n\n    public static function pageNotFound(?string $message = null)\n    {\n        return new static($message ?? self::lang('HTTP.pageNotFound'));\n    }\n\n    public static function emptyController()\n    {\n        return new static(self::lang('HTTP.emptyController'));\n    }\n\n    public static function controllerNotFound(string $controller, string $method)\n    {\n        return new static(self::lang('HTTP.controllerNotFound', [$controller, $method]));\n    }\n\n    public static function methodNotFound(string $method)\n    {\n        return new static(self::lang('HTTP.methodNotFound', [$method]));\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null]},{"name":"src\\Exceptions\\RouterException.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Exceptions;\n\n\/**\n * RouterException\n *\/\nclass RouterException extends FrameworkException\n{\n    \/**\n     * Lev\u00e9 lorsque le type de param\u00e8tre r\u00e9el ne correspond pas\n     * les types attendus.\n     *\n     * @return RouterException\n     *\/\n    public static function invalidParameterType()\n    {\n        return new static(lang('Router.invalidParameterType'));\n    }\n\n    \/**\n     * Lev\u00e9e lorsqu'une route par d\u00e9faut n'est pas d\u00e9finie.\n     *\n     * @return RouterException\n     *\/\n    public static function missingDefaultRoute()\n    {\n        return new static(lang('Router.missingDefaultRoute'));\n    }\n\n    \/**\n     * Lancer lorsque le contr\u00f4leur ou sa m\u00e9thode est introuvable.\n     *\n     * @return RouterException\n     *\/\n    public static function controllerNotFound(string $controller, string $method)\n    {\n        return new static(lang('HTTP.controllerNotFound', [$controller, $method]));\n    }\n\n    \/**\n     * Lancer lorsque la route n'est pas valide.\n     *\n     * @return RouterException\n     *\/\n    public static function invalidRoute(string $route)\n    {\n        return new static(lang('HTTP.invalidRoute', [$route]));\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null]},{"name":"src\\Exceptions\\TestException.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Exceptions;\n\n\/**\n * Exception for automatic logging.\n *\/\nclass TestException extends CriticalError\n{\n    use DebugTraceableTrait;\n\n    public static function invalidMockClass(string $name)\n    {\n        return new static(lang('Test.invalidMockClass', [$name]));\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null]},{"name":"src\\Exceptions\\ViewException.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Exceptions;\n\nclass ViewException extends FrameworkException\n{\n    public static function invalidCellMethod(string $class, string $method)\n    {\n        return new static(lang('View.invalidCellMethod', ['class' => $class, 'method' => $method]));\n    }\n\n    public static function missingCellParameters(string $class, string $method)\n    {\n        return new static(lang('View.missingCellParameters', ['class' => $class, 'method' => $method]));\n    }\n\n    public static function invalidCellParameter(string $key)\n    {\n        return new static(lang('View.invalidCellParameter', [$key]));\n    }\n\n    public static function noCellClass()\n    {\n        return new static(lang('View.noCellClass'));\n    }\n\n    public static function invalidCellClass(?string $class = null)\n    {\n        return new static(lang('View.invalidCellClass', [$class]));\n    }\n\n    public static function tagSyntaxError(string $output)\n    {\n        return new static(lang('View.tagSyntaxError', [$output]));\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null]},{"name":"src\\Formatter\\ArrayFormatter.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Formatter;\n\n\/**\n * Formateur de donn\u00e9es en tableau\n *\/\nclass ArrayFormatter implements FormatterInterface\n{\n    \/**\n     * Prend les donn\u00e9es fournies et les formate.\n     *\n     * @param mixed $data\n     *\n     * @return array Donn\u00e9es format\u00e9es sous forme de tableau ; sinon, un tableau vide\n     *\/\n    public function format($data)\n    {\n        if (! is_array($data)) {\n            $data = (array) $data;\n        }\n\n        $array = [];\n\n        foreach ($data as $key => $value) {\n            if (is_object($value) || is_array($value)) {\n                $array[$key] = $this->format($value);\n            } else {\n                $array[$key] = $value;\n            }\n        }\n\n        return $array;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,0,null,0,null,null,null,0,null,null,null]},{"name":"src\\Formatter\\CsvFormatter.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Formatter;\n\n\/**\n * Formateur de donn\u00e9es en CSV\n *\n * @see http:\/\/www.metashock.de\/2014\/02\/create-csv-file-in-memory-php\/\n *\/\nclass CsvFormatter implements FormatterInterface\n{\n    \/**\n     * D\u00e9limiteur de champ (un seul caract\u00e8re)\n     *\n     * @var string\n     *\/\n    private $delimiter = ',';\n\n    \/**\n     * Encadrement du champ (un seul caract\u00e8re).\n     *\n     * @var string\n     *\/\n    private $enclosure = '\"';\n\n    \/**\n     * Prend les donn\u00e9es fournies et les formate.\n     *\n     * @param mixed $data\n     *\n     * @return string|null Une chaine format\u00e9e en CSV\n     *\/\n    public function format($data)\n    {\n        \/\/ Utiliser un seuil de 1 Mo (1024 * 1024)\n        $handle = fopen('php:\/\/temp\/maxmemory:1048576', 'wb');\n        if ($handle === false) {\n            return null;\n        }\n\n        if (! is_array($data)) {\n            $data = (array) $data;\n        }\n\n        \/\/ V\u00e9rifie s'il s'agit d'un tableau multidimensionnel\n        if (isset($data[0]) && count($data) !== count($data, COUNT_RECURSIVE)) {\n            $headings = array_keys($data[0]);\n        } else {\n            $headings = array_keys($data);\n            $data     = [$data];\n        }\n\n        \/\/ Appliquer les en-t\u00eates\n        fputcsv($handle, $headings, $this->delimiter, $this->enclosure);\n\n        foreach ($data as $record) {\n            \/\/ Si l'enregistrement n'est pas un tableau, alors break.\n            \/\/ C'est parce que le 2\u00e8me param\u00e8tre de fputcsv() doit \u00eatre un tableau\n            if (! is_array($record)) {\n                break;\n            }\n\n            \/\/ Suppression de la notification \"conversion de tableau en cha\u00eene\".\n            \/\/ Gardez le \"mal\" @ ici.\n            $record = @array_map('strval', $record);\n\n            fputcsv($handle, $record, $this->delimiter, $this->enclosure);\n        }\n\n        rewind($handle);\n\n        $csv = stream_get_contents($handle);\n\n        fclose($handle);\n\n        \/\/ Convertit l'encodage UTF-8 en UTF-16LE qui est pris en charge par MS Excel\n        return mb_convert_encoding($csv, 'UTF-16LE', 'UTF-8');\n    }\n\n    \/**\n     * Recup\u00e8re le d\u00e9limiteur de champ\n     *\/\n    public function getDelimiter(): string\n    {\n        return $this->delimiter;\n    }\n\n    \/**\n     * D\u00e9finit le d\u00e9limiteur de champ\n     *\/\n    public function setDelimiter(string $delimiter): self\n    {\n        $this->delimiter = $delimiter[0] ?? ',';\n\n        return $this;\n    }\n\n    \/**\n     * Recup\u00e8re l'encadrement du champ (un seul caract\u00e8re).\n     *\/\n    public function getEnclosure(): string\n    {\n        return $this->enclosure;\n    }\n\n    \/**\n     * Set d\u00e9finit l'encadrement du champ (un seul caract\u00e8re).\n     *\/\n    public function setEnclosure(string $enclosure): self\n    {\n        $this->enclosure = $enclosure[0] ?? '\"';\n\n        return $this;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,null,null,null,0,null,0,0,null,null,null,0,null,null,null,null,null,0,null,null,null,null,0,null,0,null,null,0,null,0,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null]},{"name":"src\\Formatter\\Formatter.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Formatter;\n\nuse BlitzPHP\\Exceptions\\FormatException;\n\nclass Formatter\n{\n    \/**\n     * Lorsque vous effectuez une n\u00e9gociation de contenu avec la requ\u00eate, il s'agit des\n     * formats disponibles pris en charge par votre application.\n     * Un formateur valide doit exister pour le format sp\u00e9cifi\u00e9.\n     *\n     * Ces formats ne sont v\u00e9rifi\u00e9s que lorsque les donn\u00e9es sont transmises \u00e0 la r\u00e9ponse ()\n     * La m\u00e9thode est un tableau.\n     *\n     * @var string[]\n     *\/\n    protected static $supportedResponseFormats = [\n        'application\/json',\n        'application\/xml', \/\/ XML lisible par machine\n        'text\/xml', \/\/ XML lisible par l'homme\n    ];\n\n    \/**\n     * R\u00e9pertorie la classe \u00e0 utiliser pour formater les r\u00e9ponses avec un type particulier.\n     * Pour chaque type mime, indiquez la classe \u00e0 utiliser.\n     *\n     * @var array<string, string>\n     *\/\n    protected static $formatters = [\n        'application\/json' => JsonFormatter::class,\n        'application\/csv'  => CsvFormatter::class,\n        'application\/xml'  => XmlFormatter::class,\n        'text\/xml'         => XmlFormatter::class,\n\n        'php\/array' => ArrayFormatter::class,\n    ];\n\n    \/**\n     * Une m\u00e9thode Factory pour renvoyer le formateur appropri\u00e9 pour le type mime donn\u00e9.\n     *\n     * @throws FormatException\n     *\/\n    public static function type(string $mime): FormatterInterface\n    {\n        if (! array_key_exists($mime, self::$formatters)) {\n            throw FormatException::invalidMime($mime);\n        }\n\n        $className = self::$formatters[$mime];\n\n        if (! class_exists($className)) {\n            throw FormatException::invalidFormatter($className);\n        }\n\n        $class = new $className();\n\n        if (! $class instanceof FormatterInterface) {\n            throw FormatException::invalidFormatter($className);\n        }\n\n        return $class;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null]},{"name":"src\\Formatter\\JsonFormatter.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Formatter;\n\nuse BlitzPHP\\Loader\\Services;\n\n\/**\n * Formateur de donn\u00e9es JSON\n *\/\nclass JsonFormatter implements FormatterInterface\n{\n    \/**\n     * Prend les donn\u00e9es fournies et les formate.\n     *\n     * @param mixed $data\n     *\n     * @return false|string Repr\u00e9sentation Json d'une valeur\n     *                      false en cas d'erreur de formattage\n     *\/\n    public function format($data)\n    {\n        \/\/ Obtenir le param\u00e8tre de rappel (si d\u00e9fini)\n        $callback = Services::request()->getQuery('callback');\n\n        if (empty($callback)) {\n            return json_encode($data, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);\n        }\n\n        \/\/ Nous n'honorons qu'un rappel jsonp qui sont des identifiants javascript valides\n        if (preg_match('\/^[a-z_\\$][a-z0-9\\$_]*(\\.[a-z_\\$][a-z0-9\\$_]*)*$\/i', $callback)) {\n            \/\/ Renvoie les donn\u00e9es sous forme de json encod\u00e9 avec un rappel\n            return $callback . '(' . json_encode($data, JSON_UNESCAPED_UNICODE) . ');';\n        }\n\n        \/\/ Une fonction de rappel jsonp non valide a \u00e9t\u00e9 fournie.\n        \/\/ Bien que je ne pense pas que cela devrait \u00eatre cod\u00e9 en dur ici\n        $data['warning'] = 'INVALID JSONP CALLBACK: ' . $callback;\n\n        return json_encode($data, JSON_UNESCAPED_UNICODE);\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,0,null,null,null,null,0,null,0,null,null,null]},{"name":"src\\Formatter\\XmlFormatter.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Formatter;\n\nuse SimpleXMLElement;\n\n\/**\n * Formateur de donn\u00e9es XML\n *\/\nclass XmlFormatter implements FormatterInterface\n{\n    \/**\n     * @var string\n     *\/\n    protected $basenode = 'xml';\n\n    \/**\n     * @var SimpleXMLElement\n     *\/\n    protected $structure;\n\n    \/**\n     * Prend les donn\u00e9es fournies et les formate.\n     *\n     * @param mixed $data\n     *\n     * @return false|string Repr\u00e9sentation XML d'une valeur\n     *                      false en cas d'erreur de formattage\n     *\/\n    public function format($data)\n    {\n        if (empty($this->structure)) {\n            $this->structure = simplexml_load_string(\"<?xml version='1.0' encoding='utf-8'?><{$this->basenode} \/>\");\n        }\n\n        \/\/ Forcez-le \u00e0 \u00eatre quelque chose d'utile\n        if (! is_array($data) && ! is_object($data)) {\n            $data = (array) $data;\n        }\n\n        foreach ($data as $key => $value) {\n            \/\/ change false\/true en 0\/1\n            if (is_bool($value)) {\n                $value = (int) $value;\n            }\n\n            \/\/ pas de touches num\u00e9riques dans notre xml s'il vous plait !\n            if (is_numeric($key)) {\n                helper('inflector');\n                \/\/ cr\u00e9e une cl\u00e9 de cha\u00eene...\n                $key = singular($this->basenode) !== $this->basenode ? singular($this->basenode) : 'item';\n            }\n\n            \/\/ remplace tout ce qui n'est pas alphanum\u00e9rique\n            $key = preg_replace('\/[^a-z_\\-0-9]\/i', '', $key);\n\n            if ($key === '_attributes' && (is_array($value) || is_object($value))) {\n                $attributes = $value;\n                if (is_object($attributes)) {\n                    $attributes = get_object_vars($attributes);\n                }\n\n                foreach ($attributes as $attribute_name => $attribute_value) {\n                    $this->structure->addAttribute($attribute_name, $attribute_value);\n                }\n            }\n            \/\/ s'il y a un autre tableau trouv\u00e9 appelez r\u00e9cursivement cette fonction\n            elseif (is_array($value) || is_object($value)) {\n                $node = $this->structure->addChild($key);\n\n                \/\/ appel r\u00e9cursif\n                $this->structure = $node;\n                $this->basenode  = $key;\n                $this->format($value);\n            } else {\n                \/\/ ajouter un seul noeud\n                $value = htmlspecialchars(html_entity_decode($value, ENT_QUOTES, 'UTF-8'), ENT_QUOTES, 'UTF-8');\n\n                $this->structure->addChild($key, $value);\n            }\n        }\n\n        return $this->structure->asXML();\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,null,0,null,null,null,null,0,null,0,null,null,null,0,null,null,0,null,0,null,null,null,0,null,null,null,null,0,null,null,0,0,0,null,null,0,null,0,null,null,null,0,null,null,null]},{"name":"src\\Helpers\\common.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nuse BlitzPHP\\Config\\Config;\nuse BlitzPHP\\Core\\App;\nuse BlitzPHP\\HTTP\\Redirection;\nuse BlitzPHP\\Http\\ServerRequest;\nuse BlitzPHP\\Http\\Uri;\nuse BlitzPHP\\Loader\\Services;\nuse BlitzPHP\\Utilities\\Helpers;\nuse Kint\\Kint;\n\n\/\/ ================================= FONCTIONS D'ACCESSIBILITE ================================= \/\/\n\nif (! function_exists('env')) {\n\n    \/**\n     * Obtient une variable d'environnement \u00e0 partir des sources disponibles et fournit une \u00e9mulation\n     * pour les variables d'environnement non prises en charge ou incoh\u00e9rentes\n     *\n     * @param string     $key     Nom de la variable d'environnement\n     * @param mixed|null $default\n     *\n     * @return string Param\u00e9trage des variables d'environnement.\n     *\/\n    function env(string $key, $default = null)\n    {\n        return Helpers::env($key, $default);\n    }\n}\n\nif (! function_exists('helper')) {\n    \/**\n     * Charge un fichier d'aide en m\u00e9moire. Prend en charge les assistants d'espace de noms,\n     * \u00e0 la fois dans et hors du r\u00e9pertoire 'helpers' d'un r\u00e9pertoire \u00e0 espace de noms.\n     *\n     * Chargera TOUS les assistants du nom correspondant, dans l'ordre suivant :\n     *   1. app\/Helpers\n     *   2. {namespace}\/Helpers\n     *   3. system\/Helpers\n     *\n     * @param array|string $filenames\n     *\/\n    function helper($filenames)\n    {\n        \/\/ Load::helper($filenames);\n    }\n}\n\nif (! function_exists('service')) {\n    \/**\n     * Permet un acc\u00e8s plus propre au fichier de configuration des services.\n     * Renvoie toujours une instance SHARED de la classe, donc\n     * appeler la fonction plusieurs fois doit toujours\n     * renvoie la m\u00eame instance.\n     *\n     * Ceux-ci sont \u00e9gaux :\n     *  - $cache = service('cache')\n     *  - $cache = \\BlitzPHP\\Loader\\Services::cache();\n     *\/\n    function service(string $name, ...$params)\n    {\n        return Services::$name(...$params);\n    }\n}\n\nif (! function_exists('single_service')) {\n    \/**\n     * Autoriser l'acc\u00e8s propre \u00e0 un service.\n     * Renvoie toujours une nouvelle instance de la classe.\n     *\/\n    function single_service(string $name, ...$params)\n    {\n        \/\/ Assurez-vous qu'il ne s'agit PAS d'une instance partag\u00e9e\n        $params[] = false;\n\n        return Services::$name(...$params);\n    }\n}\n\nif (! function_exists('show404')) {\n    \/**\n     * Afficher une page 404 introuvable dans le navigateur\n     *\/\n    function show404(string $message = 'The page you requested was not found.', string $heading = 'Page Not Found', array $params = [])\n    {\n        \/\/ return Errors::show404($message, $heading, $params);\n    }\n}\n\nif (! function_exists('config')) {\n    \/**\n     * GET\/SET App config\n     *\n     * @param mixed $value\n     *\n     * @return mixed\n     *\/\n    function config(string $config, $value = null, bool $force_set = false)\n    {\n        if (! empty($value) || (empty($value) && true === $force_set)) {\n            Config::set($config, $value);\n        }\n\n        return Config::get($config);\n    }\n}\n\n\/\/ ================================= FONCTIONS D'ENVIRONNEMENT D'EXECUTION ================================= \/\/\n\nif (! function_exists('on_dev')) {\n    \/**\n     * Testez pour voir si nous sommes dans un environnement de d\u00e9veloppement.\n     *\/\n    function on_dev(bool $checkOnline = false): bool\n    {\n        if ($checkOnline && is_online()) {\n            return false;\n        }\n\n        $env = config('app.environment');\n\n        return in_array($env, ['dev', 'development'], true);\n    }\n}\n\nif (! function_exists('on_prod')) {\n    \/**\n     * Testez pour voir si nous sommes dans un environnement de production.\n     *\/\n    function on_prod(bool $checkOnline = false): bool\n    {\n        if ($checkOnline && is_online()) {\n            return true;\n        }\n\n        $env = config('app.environment');\n\n        return in_array($env, ['prod', 'production'], true);\n    }\n}\n\nif (! function_exists('on_test')) {\n    \/**\n     * Testez pour voir si nous sommes dans un environnement de test\n     *\/\n    function on_test(): bool\n    {\n        $env = config('app.environment');\n\n        return in_array($env, ['test', 'testing'], true);\n    }\n}\n\nif (! function_exists('is_cli')) {\n    \/**\n     * Testez pour voir si une demande a \u00e9t\u00e9 faite \u00e0 partir de la ligne de commande.\n     *\/\n    function is_cli(): bool\n    {\n        return PHP_SAPI === 'cli' || defined('STDIN');\n    }\n}\n\nif (! function_exists('is_php')) {\n    \/**\n     * D\u00e9termine si la version actuelle de PHP est \u00e9gale ou sup\u00e9rieure \u00e0 la valeur fournie.\n     *\/\n    function is_php(string $version): bool\n    {\n        return Helpers::isPhp($version);\n    }\n}\n\nif (! function_exists('is_windows')) {\n    \/**\n     * D\u00e9terminez si l'environnement actuel est bas\u00e9 sur Windows.\n     *\/\n    function is_windows(): bool\n    {\n        return PHP_OS_FAMILY === 'Windows';\n    }\n}\n\nif (! function_exists('is_https')) {\n    \/**\n     * Determines if the application is accessed via an encrypted * (HTTPS) connection.\n     *\/\n    function is_https(): bool\n    {\n        return Services::request()->is('ssl');\n    }\n}\n\nif (! function_exists('is_localfile')) {\n    \/**\n     * V\u00e9rifiez si le fichier auquel vous souhaitez acc\u00e9der est un fichier local de votre application ou non\n     *\/\n    function is_localfile(string $name): bool\n    {\n        return false;\n        \/\/ return Helpers::is_localfile($name);\n    }\n}\n\nif (! function_exists('is_online')) {\n    \/**\n     * Tester si l'application s'ex\u00e9cute en local ou en ligne.\n     *\/\n    function is_online(): bool\n    {\n        return Helpers::isOnline();\n    }\n}\n\nif (! function_exists('is_ajax_request')) {\n    \/**\n     * Testez pour voir si une requ\u00eate contient l'en-t\u00eate HTTP_X_REQUESTED_WITH.\n     *\/\n    function is_ajax_request(): bool\n    {\n        return Services::request()->is('ajax');\n    }\n}\n\n\/\/ ================================= FONCTIONS DE MANIPULATION D'URL ================================= \/\/\n\nif (! function_exists('site_url')) {\n    \/**\n     * Renvoie une URL de site telle que d\u00e9finie par la configuration de l'application.\n     *\n     * @param mixed $relativePath Cha\u00eene d'URI ou tableau de segments d'URI\n     *\/\n    function site_url($relativePath = '', ?string $scheme = null): string\n    {\n        if (is_array($relativePath)) {\n            $relativePath = implode('\/', $relativePath);\n        }\n\n        $uri = App::getUri($relativePath);\n\n        return Uri::createURIString(\n            $scheme ?? $uri->getScheme(),\n            $uri->getAuthority(),\n            $uri->getPath(),\n            $uri->getQuery(),\n            $uri->getFragment()\n        );\n    }\n}\n\nif (! function_exists('base_url')) {\n    \/**\n     * Cr\u00e9ez une URL locale bas\u00e9e sur votre chemin de base.\n     * Les segments peuvent \u00eatre transmis sous forme de cha\u00eene ou de tableau, comme site_url\n     * ou une URL vers un fichier peut \u00eatre transmise, par ex. \u00e0 un fichier image.\n     *\n     * @param mixed $uri\n     *\/\n    function base_url($uri = '', ?string $protocol = null): string\n    {\n        return '';\n        \/\/ return Helpers::base_url($uri, $protocol);\n    }\n}\n\nif (! function_exists('current_url')) {\n    \/**\n     * Current URL\n     *\n     * Returns the full URL (including segments) of the page where this\n     * function is placed\n     *\n     * @param bool $returnObject True to return an object instead of a strong\n     *\n     * @return \\BlitzPHP\\Http\\Uri|string\n     *\/\n    function current_url(bool $returnObject = false)\n    {\n        $uri = Services::uri(site_url($_SERVER['REQUEST_URI']));\n\n        \/\/ Since we're basing off of the IncomingRequest URI,\n        \/\/ we are guaranteed to have a host based on our own configs.\n        return $returnObject\n            ? $uri\n            : (string) $uri->setQuery('');\n    }\n}\n\nif (! function_exists('previous_url')) {\n    \/**\n     * Renvoie l'URL pr\u00e9c\u00e9dente sur laquelle se trouvait le visiteur actuel. Pour des raisons de s\u00e9curit\u00e9\n     * nous v\u00e9rifions d'abord une variable de session enregistr\u00e9e, si elle existe, et l'utilisons.\n     * Si ce n'est pas disponible, cependant, nous utiliserons une URL \u00e9pur\u00e9e de $_SERVER['HTTP_REFERER']\n     * qui peut \u00eatre d\u00e9fini par l'utilisateur, il n'est donc pas fiable et n'est pas d\u00e9fini par certains navigateurs\/serveurs.\n     *\n     * @return \\BlitzPHP\\Http\\Uri|mixed|string\n     *\/\n    function previous_url(bool $returnObject = false)\n    {\n        \/\/ R\u00e9cup\u00e9rez d'abord la session, si nous l'avons,\n        \/\/ car c'est plus fiable et plus s\u00fbr.\n        \/\/ Sinon, r\u00e9cup\u00e9rez une version \u00e9pur\u00e9e de $_SERVER.\n        $referer = $_SESSION['_blitz_previous_url'] ?? null;\n        if (false === filter_var($referer, FILTER_VALIDATE_URL)) {\n            $referer = Services::request()->getServer('HTTP_REFERER', FILTER_SANITIZE_URL);\n        }\n\n        $referer ??= site_url('\/');\n\n        return $returnObject ? Services::uri($referer) : $referer;\n    }\n}\n\nif (! function_exists('redirection')) {\n    \/**\n     * Redirige l'utilisateur\n     *\/\n    function redirection(string $uri = '', string $method = 'location', ?int $code = 302)\n    {\n        $response = redirect()->to($uri, $code, $method);\n\n        Services::emitter()->emitHeaders($response);\n\n        exit(EXIT_SUCCESS);\n    }\n}\n\nif (! function_exists('redirect')) {\n    \/**\n     * M\u00e9thode pratique qui fonctionne avec la $request globale actuelle et\n     * l'instance $router \u00e0 rediriger \u00e0 l'aide de routes nomm\u00e9es et le routage invers\u00e9\n     * pour d\u00e9terminer l'URL \u00e0 laquelle aller. Si rien n'est trouv\u00e9, traitera\n     * comme une redirection traditionnelle et passez la cha\u00eene, en laissant\n     * $redirection->redirect() d\u00e9termine la m\u00e9thode et le code corrects.\n     *\n     * Si plus de contr\u00f4le est n\u00e9cessaire, vous devez utiliser explicitement $response->redirect.\n     *\/\n    function redirect(?string $uri = null): Redirection\n    {\n        $redirection = Services::redirection();\n\n        if (! empty($uri)) {\n            return $redirection->route($uri);\n        }\n\n        return $redirection;\n    }\n}\n\nif (! function_exists('link_to')) {\n    \/**\n     * \u00c9tant donn\u00e9 une cha\u00eene de contr\u00f4leur\/m\u00e9thode et tous les param\u00e8tres,\n     * tentera de cr\u00e9er l'URL relative \u00e0 la route correspondante.\n     *\n     * REMARQUE : Cela n\u00e9cessite que le contr\u00f4leur\/la m\u00e9thode\n     * ait une route d\u00e9finie dans le fichier de configuration des routes.\n     *\/\n    function link_to(string $method, ...$params): string\n    {\n        $url = Services::routes()->reverseRoute($method, ...$params);\n\n        return site_url($url);\n    }\n}\n\nif (! function_exists('clean_url')) {\n    function clean_url(string $url): string\n    {\n        return Helpers::cleanUrl($url);\n    }\n}\n\nif (! function_exists('clean_path')) {\n    \/**\n     * Une m\u00e9thode pratique pour nettoyer les chemins pour\n     * une sortie plus belle. Utile pour les exceptions\n     * gestion, journalisation des erreurs, etc.\n     *\/\n    function clean_path(string $path): string\n    {\n        \/\/ Resolve relative paths\n        $path = realpath($path) ?: $path;\n\n        switch (true) {\n            case strpos($path, APP_PATH) === 0:\n                return 'APP_PATH' . DIRECTORY_SEPARATOR . substr($path, strlen(APP_PATH));\n\n            case strpos($path, SYST_PATH) === 0:\n                return 'SYST_PATH' . DIRECTORY_SEPARATOR . substr($path, strlen(SYST_PATH));\n\n            case defined('COMPOSER_PATH') && strpos($path, COMPOSER_PATH) === 0:\n                return 'COMPOSER_PATH' . DIRECTORY_SEPARATOR . substr($path, strlen(COMPOSER_PATH));\n\n            case strpos($path, ROOTPATH) === 0:\n                return 'ROOTPATH' . DIRECTORY_SEPARATOR . substr($path, strlen(ROOTPATH));\n\n            default:\n                return $path;\n        }\n    }\n}\n\n\/\/ ================================= FONCTIONS DE DEBOGAGE ================================= \/\/\n\nif (! function_exists('dd')) {\n    \/**\n     * Prints a Kint debug report and exits.\n     *\n     * @param array ...$vars\n     *\n     * @codeCoverageIgnore Can't be tested ... exits\n     *\/\n    function dd(...$vars)\n    {\n        Kint::$aliases[] = 'dd';\n        Kint::dump(...$vars);\n\n        exit;\n    }\n}\n\nif (! function_exists('deprecationWarning')) {\n    \/**\n     * M\u00e9thode d'assistance pour g\u00e9n\u00e9rer des avertissements d'obsolescence\n     *\n     * @param string $message    Le message \u00e0 afficher comme avertissement d'obsolescence.\n     * @param int    $stackFrame Le cadre de pile \u00e0 inclure dans l'erreur. Par d\u00e9faut \u00e0 1\n     *                           car cela devrait pointer vers le code de l'application\/du plugin.\n     *\n     * @return void\n     *\/\n    function deprecation_warning(string $message, int $stackFrame = 1)\n    {\n        Helpers::deprecationWarning($message, $stackFrame);\n    }\n}\n\nif (! function_exists('logger')) {\n    \/**\n     * A convenience\/compatibility method for logging events through\n     * the Log system.\n     *\n     * Allowed log levels are:\n     *  - emergency\n     *  - alert\n     *  - critical\n     *  - error\n     *  - warning\n     *  - notice\n     *  - info\n     *  - debug\n     *\n     * @param int|string $level\n     *\n     * @return \\BlitzPHP\\Debug\\Logger|mixed\n     *\/\n    function logger($level = null, ?string $message = null, array $context = [])\n    {\n        $logger = Services::logger();\n\n        if (! empty($level) && ! empty($message)) {\n            return $logger->log($level, $message, $context);\n        }\n\n        return $logger;\n    }\n}\n\nif (! function_exists('cache')) {\n    \/**\n     * Une m\u00e9thode pratique qui donne acc\u00e8s au cache\n     * objet. Si aucun param\u00e8tre n'est fourni, renverra l'objet,\n     * sinon, tentera de renvoyer la valeur mise en cache.\n     *\n     * Examples:\n     *    cache()->set('foo', 'bar'); or cache('foo', 'bar');\n     *    $foo = cache('bar');\n     *\n     * @param mixed|null $value\n     *\n     * @return \\BlitzPHP\\Cache\\Cache|bool|mixed\n     *\/\n    function cache(?string $key = null, $value = null)\n    {\n        $cache = Services::cache();\n\n        if (empty($key)) {\n            return $cache;\n        }\n\n        if (empty($value)) {\n            return $cache->get($key);\n        }\n\n        return $cache->set($key, $value);\n    }\n}\n\nif (! function_exists('pr')) {\n    \/**\n     * print_r() convenience function.\n     *\n     * In terminals this will act similar to using print_r() directly, when not run on cli\n     * print_r() will also wrap <pre> tags around the output of given variable. Similar to debug().\n     *\n     * This function returns the same variable that was passed.\n     *\n     * @param mixed $var Variable to print out.\n     *\n     * @return mixed the same $var that was passed to this function\n     *\/\n    function pr($var)\n    {\n        $template = (PHP_SAPI !== 'cli' && PHP_SAPI !== 'phpdbg') ? '<pre class=\"pr\">%s<\/pre>' : \"\\n%s\\n\\n\";\n        printf($template, trim(print_r($var, true)));\n\n        return $var;\n    }\n}\n\nif (! function_exists('pj')) {\n    \/**\n     * json pretty print convenience function.\n     *\n     * In terminals this will act similar to using json_encode() with JSON_PRETTY_PRINT directly, when not run on cli\n     * will also wrap <pre> tags around the output of given variable. Similar to pr().\n     *\n     * This function returns the same variable that was passed.\n     *\n     * @param mixed $var Variable to print out.\n     *\n     * @return mixed the same $var that was passed to this function\n     *\n     * @see pr()\n     *\/\n    function pj($var)\n    {\n        return Helpers::pj($var);\n    }\n}\n\nif (! function_exists('trigger_warning')) {\n    \/**\n     * D\u00e9clenche un E_USER_WARNING.\n     *\/\n    function trigger_warning(string $message)\n    {\n        Helpers::triggerWarning($message);\n    }\n}\n\nif (! function_exists('vd')) {\n    \/**\n     * Shortcut to ref, HTML mode\n     *\n     * @return string|void\n     *\/\n    function vd(...$params)\n    {\n        \/\/ return \tHelpers::r(...$params);\n    }\n}\n\nif (! function_exists('vdt')) {\n    \/**\n     * Shortcut to ref, plain text mode\n     *\n     * @return string|void\n     *\/\n    function vdt(...$params)\n    {\n        \/\/ return \tHelpers::rt(...$params);\n    }\n}\n\n\/\/ ================================= FONCTIONS DIVERSES ================================= \/\/\n\nif (! function_exists('force_https')) {\n    \/**\n     * Utilis\u00e9 pour forcer l'acc\u00e8s \u00e0 une page via HTTPS.\n     * Utilise une redirection standard, plus d\u00e9finira l'en-t\u00eate HSTS\n     * pour les navigateurs modernes qui prennent en charge, ce qui donne une meilleur\n     * protection contre les attaques de l'homme du milieu.\n     *\n     * @see https:\/\/en.wikipedia.org\/wiki\/HTTP_Strict_Transport_Security\n     *\n     * @param int $duration Combien de temps l'en-t\u00eate SSL doit-il \u00eatre d\u00e9fini ? (en secondes)\n     *                      Par d\u00e9faut \u00e0 1 an.\n     * @credit CodeIgniter <a href=\"http:\/\/codeigniter.com\/\">helpers force_https() - \/system\/Common.php<\/a>\n     *\n     * Non testable, car il sortira !\n     * @codeCoverageIgnore\n     *\/\n    function force_https(int $duration = 31536000, ?ServerRequest $request = null, ?Redirection $response = null)\n    {\n        if (null === $request) {\n            $request = Services::request();\n        }\n        if (null === $response) {\n            $response = Services::redirection();\n        }\n\n        if (is_cli() || $request->is('ssl')) {\n            return;\n        }\n\n        \/\/ Si la biblioth\u00e8que de session est charg\u00e9e, nous devons r\u00e9g\u00e9n\u00e9rer\n        \/\/ l'ID de session pour des raisons de s\u00e9curit\u00e9.\n        Services::session()->renew();\n\n        $baseURL = base_url();\n\n        if (strpos($baseURL, 'http:\/\/') === 0) {\n            $baseURL = (string) substr($baseURL, strlen('http:\/\/'));\n        }\n\n        $uri = Uri::createURIString(\n            'https',\n            $baseURL,\n            $request->getUri()->getPath(), \/\/ Les URI absolus doivent utiliser un \"\/\" pour un chemin vide\n            $request->getUri()->getQuery(),\n            $request->getUri()->getFragment()\n        );\n\n        \/\/ D\u00e9finir un en-t\u00eate HSTS\n        $response = $response->to($uri)->withHeader('Strict-Transport-Security', 'max-age=' . $duration);\n\n        Services::emitter()->emitHeaders($response);\n\n        exit(EXIT_SUCCESS);\n    }\n}\n\nif (! function_exists('getTypeName')) {\n    \/**\n     * Renvoie la classe d'objets ou le type var de ce n'est pas un objet\n     *\n     * @param mixed $var Variable \u00e0 v\u00e9rifier\n     *\n     * @return string Renvoie le nom de la classe ou le type de variable\n     *\/\n    function getTypeName($var): string\n    {\n        return is_object($var) ? get_class($var) : gettype($var);\n    }\n}\n\nif (! function_exists('ip_address')) {\n    \/**\n     * Renvoie l'adresse IP de l'utilisateur actuel\n     *\/\n    function ip_address(): string\n    {\n        return (string) Services::request()->clientIp();\n    }\n}\n\nif (! function_exists('is_really_writable')) {\n    \/**\n     * Tests d'inscriptibilit\u00e9 des fichiers\n     *\/\n    function is_really_writable(string $file): bool\n    {\n        return true;\n        \/\/ return Helpers::is_really_writable($file);\n    }\n}\n\nif (! function_exists('lang')) {\n    \/**\n     * Une m\u00e9thode pratique pour traduire une cha\u00eene ou un tableau d'entr\u00e9es et formater\n     * le r\u00e9sultat avec le MessageFormatter de l'extension intl.\n     *\n     * @param array  $args\n     * @param string $locale\n     *\n     * @return string\n     *\/\n    function lang(string $line, ?array $args = [], ?string $locale = null)\n    {\n        return Services::language($locale)->getLine($line, $args);\n    }\n}\n\nif (! function_exists('namespaceSplit')) {\n    \/**\n     * S\u00e9parez l'espace de noms du nom de classe.\n     *\n     * Couramment utilis\u00e9 comme `list($namespace, $className) = namespaceSplit($class);`.\n     *\n     * @param string $class Le nom complet de la classe, ie `BlitzPHP\\Http\\Request`.\n     *\n     * @return array Tableau avec 2 index. 0 => namespace, 1 => classname.\n     *\/\n    function namespaceSplit(string $class): array\n    {\n        $pos = strrpos($class, '\\\\');\n        if ($pos === false) {\n            return ['', $class];\n        }\n\n        return [substr($class, 0, $pos), substr($class, $pos + 1)];\n    }\n}\n\nif (! function_exists('view_exist')) {\n    \/**\n     * Verifie si un fichier de vue existe. Utile pour limiter les failles include\n     *\/\n    function view_exist(string $name, string $ext = '.php'): bool\n    {\n        $ext  = str_replace('.', '', $ext);\n        $name = str_replace(VIEW_PATH, '', $name);\n        $name = preg_match('#\\.' . $ext . '$#', $name) ? $name : $name . '.' . $ext;\n\n        return is_file(VIEW_PATH . rtrim($name, DS));\n    }\n}\n\nif (! function_exists('view')) {\n    \/**\n     * Charge une vue\n     *\n     * @return \\BlitzPHP\\View\\View\n     *\/\n    function view(string $view, ?array $data = [], ?array $options = [])\n    {\n        $object = Services::viewer(false);\n\n        $object->addData($data)->setOptions($options);\n\n        return $object->display($view);\n    }\n}\n\nif (! function_exists('flash')) {\n    \/**\n     * Fournisseur d'acces rapide a la classe PHP Flash\n     *\n     * @return FlashMessages|string\n     *\/\n    \/*\n    function flash()\n    {\n         @var FlashMessages $flash\n        $flash = service(FlashMessages::class);\n\n        $params = func_get_args();\n        $type = array_shift($params);\n\n        if (!empty($type)) {\n            if (empty($params)) {\n                if ($type === 'all') {\n                    $type = null;\n                }\n                return $flash->display($type, false);\n            }\n\n            $message = array_shift($params);\n\n            return $flash->add($message, $type, ...$params);\n        }\n\n        return $flash;\n    }*\/\n}\n\nif (! function_exists('geo_ip')) {\n    \/**\n     * Recuperation des coordonnees (pays, ville, etc) d'un utilisateur en fonction de son ip\n     *\/\n    function geo_ip(?string $ip = null): ?array\n    {\n        return json_decode(file_get_contents('http:\/\/ip-api.com\/json\/' . $ip), true);\n    }\n}\n\nif (! function_exists('to_stream')) {\n    \/**\n     * Cr\u00e9ez un nouveau flux bas\u00e9 sur le type d'entr\u00e9e.\n     *\n     * Options est un tableau associatif pouvant contenir les cl\u00e9s suivantes :\n     * - metadata : Tableau de m\u00e9tadonn\u00e9es personnalis\u00e9es.\n     * - size : Taille du flux.\n     *\n     * @param bool|callable|float|int|\\Iterator|\\Psr\\Http\\Message\\StreamInterface|resource|string|null $resource Donn\u00e9es du corps de l'entit\u00e9\n     * @param array                                                                                    $options  Additional options\n     *\n     * @uses GuzzleHttp\\Psr7\\stream_for\n     *\n     * @throws \\InvalidArgumentException si l'argument $resource n'est pas valide.\n     *\n     * @return \\Psr\\Http\\Message\\StreamInterface\n     *\/\n    function to_stream($resource = '', array $options = []): Psr\\Http\\Message\\StreamInterface\n    {\n        return \\GuzzleHttp\\Psr7\\Utils::streamFor($resource, $options);\n    }\n}\n\nif (! function_exists('value')) {\n    \/**\n     * Renvoie la valeur par d\u00e9faut de la valeur donn\u00e9e.\n     *\n     * @param mixed $value\n     *\n     * @return mixed\n     *\/\n    function value($value)\n    {\n        return $value instanceof Closure ? $value() : $value;\n    }\n}\n\nif (! function_exists('with')) {\n    \/**\n     * Renvoie la valeur donn\u00e9e, \u00e9ventuellement transmise via le rappel donn\u00e9.\n     *\n     * @param mixed $value\n     *\n     * @return mixed\n     *\/\n    function with($value, ?callable $callback = null)\n    {\n        return null === $callback ? $value : $callback($value);\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,2,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,0,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null]},{"name":"src\\Http\\Cookie\\Cookie.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Http\\Cookie;\n\nuse BlitzPHP\\Contracts\\Http\\CookieInterface;\nuse BlitzPHP\\Utilities\\Arr;\nuse DateTime;\nuse DateTimeImmutable;\nuse DateTimeInterface;\nuse DateTimeZone;\nuse InvalidArgumentException;\n\n\/**\n * Objet cookie pour cr\u00e9er un cookie et le transformer en valeur d'en-t\u00eate\n *\n * Un cookie HTTP (\u00e9galement appel\u00e9 cookie Web, cookie Internet, cookie de navigateur ou\n * simplement cookie) est une petite donn\u00e9e envoy\u00e9e depuis un site Web et stock\u00e9e sur\n * l'ordinateur de l'utilisateur par le navigateur Web de l'utilisateur pendant que l'utilisateur navigue.\n *\n * Les cookies ont \u00e9t\u00e9 con\u00e7us pour \u00eatre un m\u00e9canisme fiable permettant aux sites Web de se souvenir\n * informations avec \u00e9tat (telles que les articles ajout\u00e9s dans le panier d'achat en ligne\n * store) ou pour enregistrer l'activit\u00e9 de navigation de l'utilisateur (y compris les clics\n * boutons particuliers, connexion ou enregistrement des pages visit\u00e9es\n * le pass\u00e9). Ils peuvent \u00e9galement \u00eatre utilis\u00e9s pour m\u00e9moriser des informations arbitraires\n * que l'utilisateur a pr\u00e9c\u00e9demment saisi dans les champs de formulaire tels que les noms et les pr\u00e9f\u00e9rences.\n *\n * Les objets cookies sont immuables et vous devez r\u00e9affecter les variables lors de la modification de l'objets cookies :\n *\n * ```\n * $cookie = $cookie->withValue('0');\n * ```\n *\n * @see https:\/\/tools.ietf.org\/html\/draft-ietf-httpbis-rfc6265bis-03\n * @see https:\/\/en.wikipedia.org\/wiki\/HTTP_cookie\n * @see \\BlitzPHP\\Http\\Cookie\\CookieCollection for working with collections of cookies.\n * @see \\BlitzPHP\\Http\\Response::getCookieCollection() for working with response cookies.\n * @credit <a href=\"https:\/\/api.cakephp.org\/4.3\/class-Cake.Http.Cookie.Cookie.html\">CakePHP - \\Cake\\Http\\Cookie\\Cookie<\/a>\n *\/\nclass Cookie implements CookieInterface\n{\n    \/**\n     * Nom du cookie\n     *\n     * @var string\n     *\/\n    protected $name = '';\n\n    \/**\n     * Valeur brute du cookie.\n     *\n     * @var array|string\n     *\/\n    protected $value = '';\n\n    \/**\n     * Indique si une valeur JSON a \u00e9t\u00e9 d\u00e9velopp\u00e9e dans un tableau.\n     *\n     * @var bool\n     *\/\n    protected $isExpanded = false;\n\n    \/**\n     * Date d'expiration\n     *\n     * @var DateTime|DateTimeImmutable|null\n     *\/\n    protected $expiresAt;\n\n    \/**\n     * Chemin\n     *\n     * @var string\n     *\/\n    protected $path = '\/';\n\n    \/**\n     * Domaine\n     *\n     * @var string\n     *\/\n    protected $domain = '';\n\n    \/**\n     * Securis\u00e9 ?\n     *\n     * @var bool\n     *\/\n    protected $secure = false;\n\n    \/**\n     * Uniquement via HTTP ?\n     *\n     * @var bool\n     *\/\n    protected $httpOnly = false;\n\n    \/**\n     * Samesite\n     *\n     * @var string|null\n     *\/\n    protected $sameSite;\n\n    \/**\n     * Attributs par d\u00e9faut pour un cookie.\n     *\n     * @var array<string, mixed>\n     *\n     * @see \\BlitzPHP\\Http\\Cookie\\Cookie::setDefaults()\n     *\/\n    protected static $defaults = [\n        'expires'  => null,\n        'path'     => '\/',\n        'domain'   => '',\n        'secure'   => false,\n        'httponly' => false,\n        'samesite' => null,\n    ];\n\n    \/**\n     * Constructor\n     *\n     * Les arguments des constructeurs sont similaires \u00e0 la m\u00e9thode native PHP `setcookie()`.\n     * La seule diff\u00e9rence est le 3\u00e8me argument qui excepte null ou un\n     * Objet DateTime ou DateTimeImmutable \u00e0 la place d'un entier.\n     *\n     * @see http:\/\/php.net\/manual\/en\/function.setcookie.php\n     *\n     * @param array|string                    $value     Valeur du cookie\n     * @param DateTime|DateTimeImmutable|null $expiresAt\n     *\/\n    public function __construct(\n        string $name,\n        $value = '',\n        ?DateTimeInterface $expiresAt = null,\n        ?string $path = null,\n        ?string $domain = null,\n        ?bool $secure = null,\n        ?bool $httpOnly = null,\n        ?string $sameSite = null\n    ) {\n        $this->validateName($name);\n        $this->name = $name;\n\n        $this->_setValue($value);\n\n        $this->domain   = $domain ?? static::$defaults['domain'];\n        $this->httpOnly = $httpOnly ?? static::$defaults['httponly'];\n        $this->path     = $path ?? static::$defaults['path'];\n        $this->secure   = $secure ?? static::$defaults['secure'];\n        if ($sameSite === null) {\n            $this->sameSite = static::$defaults['samesite'];\n        } else {\n            $this->validateSameSiteValue($sameSite);\n            $this->sameSite = $sameSite;\n        }\n\n        if ($expiresAt) {\n            $expiresAt = $expiresAt->setTimezone(new DateTimeZone('GMT'));\n        } else {\n            $expiresAt = static::$defaults['expires'];\n        }\n        $this->expiresAt = $expiresAt;\n    }\n\n    \/**\n     * D\u00e9finissez les options par d\u00e9faut pour les cookies.\n     *\n     * Les options valides sont :\n     *\n     * - `expires` : peut \u00eatre un horodatage UNIX ou une cha\u00eene compatible `strtotime()` ou une instance `DateTimeInterface` ou `null`.\n     * - `path` : une cha\u00eene de chemin. Par d\u00e9faut `'\/'`.\n     * - `domain` : cha\u00eene de nom de domaine. La valeur par d\u00e9faut est ''''.\n     * - `httponly` : bool\u00e9en. La valeur par d\u00e9faut est \"false\".\n     * - `secure` : bool\u00e9en. La valeur par d\u00e9faut est \"false\".\n     * - `samesite` : peut \u00eatre l'un des \u00e9l\u00e9ments suivants : `CookieInterface::SAMESITE_LAX`, `CookieInterface::SAMESITE_STRICT`,\n     *              `CookieInterface::SAMESITE_NONE` ou `null`. La valeur par d\u00e9faut est `null`.\n     *\/\n    public static function setDefaults(array $options): void\n    {\n        if (isset($options['expires'])) {\n            $options['expires'] = static::dateTimeInstance($options['expires']);\n        }\n        if (isset($options['samesite'])) {\n            static::validateSameSiteValue($options['samesite']);\n        }\n\n        static::$defaults = $options + static::$defaults;\n    }\n\n    \/**\n     * M\u00e9thode d'usine pour cr\u00e9er des instances de Cookie.\n     *\n     * @see \\BlitzPHP\\Cookie\\Cookie::setDefaults()\n     *\n     * @param mixed $value\n     *\/\n    public static function create(string $name, $value, array $options = []): self\n    {\n        $options += static::$defaults;\n        $options['expires'] = static::dateTimeInstance($options['expires']);\n\n        return new static(\n            $name,\n            $value,\n            $options['expires'],\n            $options['path'],\n            $options['domain'],\n            $options['secure'],\n            $options['httponly'],\n            $options['samesite']\n        );\n    }\n\n    \/**\n     * Convertit la valeur d'expiration non nulle en instance DateTimeInterface.\n     *\n     * @param mixed $expires Expiry value.\n     *\n     * @return DateTime|DatetimeImmutable|null\n     *\/\n    protected static function dateTimeInstance($expires): ?DateTimeInterface\n    {\n        if ($expires === null) {\n            return null;\n        }\n\n        if ($expires instanceof DateTimeInterface) {\n            \/** @psalm-suppress UndefinedInterfaceMethod *\/\n            return $expires->setTimezone(new DateTimeZone('GMT')); \/\/ @phpstan-ignore-line\n        }\n\n        if (! is_string($expires) && ! is_int($expires)) {\n            throw new InvalidArgumentException(sprintf(\n                'Invalid type `%s` for expires. Expected an string, integer or DateTime object.',\n                getTypeName($expires)\n            ));\n        }\n\n        if (! is_numeric($expires)) {\n            $expires = strtotime($expires) ?: null;\n        }\n\n        if ($expires !== null) {\n            $expires = new DateTimeImmutable('@' . (string) $expires);\n        }\n\n        return $expires;\n    }\n\n    \/**\n     * Cr\u00e9ez une instance de cookie \u00e0 partir de la cha\u00eene d'en-t\u00eate \"set-cookie\".\n     *\n     * @param string $cookie Cha\u00eene d'en-t\u00eate de cookie.\n     *\n     * @see \\BlitzPHP\\Http\\Cookie\\Cookie::setDefaults()\n     *\/\n    public static function createFromHeaderString(string $cookie, array $defaults = []): self\n    {\n        if (strpos($cookie, '\";\"') !== false) {\n            $cookie = str_replace('\";\"', '{__cookie_replace__}', $cookie);\n            $parts  = str_replace('{__cookie_replace__}', '\";\"', explode(';', $cookie));\n        } else {\n            $parts = preg_split('\/\\;[ \\t]*\/', $cookie);\n        }\n\n        [$name, $value] = explode('=', array_shift($parts), 2);\n        $data           = [\n            'name'  => urldecode($name),\n            'value' => urldecode($value),\n        ] + $defaults;\n\n        foreach ($parts as $part) {\n            if (strpos($part, '=') !== false) {\n                [$key, $value] = explode('=', $part);\n            } else {\n                $key   = $part;\n                $value = true;\n            }\n\n            $key        = strtolower($key);\n            $data[$key] = $value;\n        }\n\n        if (isset($data['max-age'])) {\n            $data['expires'] = time() + (int) $data['max-age'];\n            unset($data['max-age']);\n        }\n\n        if (isset($data['samesite'])) {\n            \/\/ Ignorer la valeur non valide lors de l'analyse des en-t\u00eates\n            \/\/ https:\/\/tools.ietf.org\/html\/draft-west-first-party-cookies-07#section-4.1\n            if (! in_array($data['samesite'], CookieInterface::SAMESITE_VALUES, true)) {\n                unset($data['samesite']);\n            }\n        }\n\n        $name  = (string) $data['name'];\n        $value = (string) $data['value'];\n        unset($data['name'], $data['value']);\n\n        return self::create(\n            $name,\n            $value,\n            $data\n        );\n    }\n\n    \/**\n     * Renvoie une valeur d'en-t\u00eate sous forme de cha\u00eene\n     *\/\n    public function toHeaderValue(): string\n    {\n        $value = $this->value;\n        if ($this->isExpanded) {\n            \/** @psalm-suppress PossiblyInvalidArgument *\/\n            $value = $this->_flatten($this->value);\n        }\n        $headerValue = [];\n        \/** @psalm-suppress PossiblyInvalidArgument *\/\n        $headerValue[] = sprintf('%s=%s', $this->name, rawurlencode($value));\n\n        if ($this->expiresAt) {\n            $headerValue[] = sprintf('expires=%s', $this->getFormattedExpires());\n        }\n        if ($this->path !== '') {\n            $headerValue[] = sprintf('path=%s', $this->path);\n        }\n        if ($this->domain !== '') {\n            $headerValue[] = sprintf('domain=%s', $this->domain);\n        }\n        if ($this->sameSite) {\n            $headerValue[] = sprintf('samesite=%s', $this->sameSite);\n        }\n        if ($this->secure) {\n            $headerValue[] = 'secure';\n        }\n        if ($this->httpOnly) {\n            $headerValue[] = 'httponly';\n        }\n\n        return implode('; ', $headerValue);\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function withName(string $name): self\n    {\n        $this->validateName($name);\n        $new       = clone $this;\n        $new->name = $name;\n\n        return $new;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getId(): string\n    {\n        return \"{$this->name};{$this->domain};{$this->path}\";\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getName(): string\n    {\n        return $this->name;\n    }\n\n    \/**\n     * Valide le nom du cookie\n     *\n     * @throws InvalidArgumentException\n     *\n     * @see https:\/\/tools.ietf.org\/html\/rfc2616#section-2.2 Rules for naming cookies.\n     *\/\n    protected function validateName(string $name): void\n    {\n        if (preg_match(\"\/[=,;\\t\\r\\n\\013\\014]\/\", $name)) {\n            throw new InvalidArgumentException(\n                sprintf('The cookie name `%s` contains invalid characters.', $name)\n            );\n        }\n\n        if (empty($name)) {\n            throw new InvalidArgumentException('The cookie name cannot be empty.');\n        }\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getValue()\n    {\n        return $this->value;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getScalarValue()\n    {\n        if ($this->isExpanded) {\n            \/** @psalm-suppress PossiblyInvalidArgument *\/\n            return $this->_flatten($this->value);\n        }\n\n        return $this->value;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function withValue($value): self\n    {\n        $new = clone $this;\n        $new->_setValue($value);\n\n        return $new;\n    }\n\n    \/**\n     * Setter pour l'attribut de valeur.\n     *\n     * @param array|string $value\n     *\/\n    protected function _setValue($value): void\n    {\n        $this->isExpanded = is_array($value);\n        $this->value      = $value;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function withPath(string $path): self\n    {\n        $new       = clone $this;\n        $new->path = $path;\n\n        return $new;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getPath(): string\n    {\n        return $this->path;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function withDomain(string $domain)\n    {\n        $new         = clone $this;\n        $new->domain = $domain;\n\n        return $new;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getDomain(): string\n    {\n        return $this->domain;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function isSecure(): bool\n    {\n        return $this->secure;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function withSecure(bool $secure): self\n    {\n        $new         = clone $this;\n        $new->secure = $secure;\n\n        return $new;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function withHttpOnly(bool $httpOnly): self\n    {\n        $new           = clone $this;\n        $new->httpOnly = $httpOnly;\n\n        return $new;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function isHttpOnly(): bool\n    {\n        return $this->httpOnly;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function withExpiry($dateTime): self\n    {\n        $new            = clone $this;\n        $new->expiresAt = $dateTime->setTimezone(new DateTimeZone('GMT'));\n\n        return $new;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getExpiry()\n    {\n        return $this->expiresAt;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getExpiresTimestamp(): ?int\n    {\n        if (! $this->expiresAt) {\n            return null;\n        }\n\n        return (int) $this->expiresAt->format('U');\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getFormattedExpires(): string\n    {\n        if (! $this->expiresAt) {\n            return '';\n        }\n\n        return $this->expiresAt->format(static::EXPIRES_FORMAT);\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function isExpired($time = null): bool\n    {\n        $time = $time ?: new DateTimeImmutable('now', new DateTimeZone('UTC'));\n        if (! $this->expiresAt) {\n            return false;\n        }\n\n        return $this->expiresAt < $time;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function withNeverExpire()\n    {\n        $new            = clone $this;\n        $new->expiresAt = new DateTimeImmutable('2038-01-01');\n\n        return $new;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function withExpired()\n    {\n        $new            = clone $this;\n        $new->expiresAt = new DateTimeImmutable('1970-01-01 00:00:01');\n\n        return $new;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getSameSite(): ?string\n    {\n        return $this->sameSite;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function withSameSite(?string $sameSite)\n    {\n        if ($sameSite !== null) {\n            $this->validateSameSiteValue($sameSite);\n        }\n\n        $new           = clone $this;\n        $new->sameSite = $sameSite;\n\n        return $new;\n    }\n\n    \/**\n     * V\u00e9rifiez que la valeur transmise pour SameSite est valide.\n     *\n     * @throws InvalidArgumentException\n     *\/\n    protected static function validateSameSiteValue(string $sameSite)\n    {\n        if (! in_array($sameSite, CookieInterface::SAMESITE_VALUES, true)) {\n            throw new InvalidArgumentException(\n                'Samesite value must be either of: ' . implode(', ', CookieInterface::SAMESITE_VALUES)\n            );\n        }\n    }\n\n    \/**\n     * V\u00e9rifie si une valeur existe dans les donn\u00e9es du cookie.\n     *\n     * Cette m\u00e9thode \u00e9tendra les donn\u00e9es complexes s\u00e9rialis\u00e9es,\n     * \u00e0 la premi\u00e8re utilisation.\n     *\/\n    public function check(string $path): bool\n    {\n        if ($this->isExpanded === false) {\n            \/** @psalm-suppress PossiblyInvalidArgument *\/\n            $this->value = $this->_expand($this->value);\n        }\n\n        \/** @psalm-suppress PossiblyInvalidArgument *\/\n        return Arr::check($this->value, $path);\n    }\n\n    \/**\n     * Cr\u00e9er un nouveau cookie avec des donn\u00e9es mises \u00e0 jour.\n     *\n     * @param mixed $value\n     *\/\n    public function withAddedValue(string $path, $value): self\n    {\n        $new = clone $this;\n        if ($new->isExpanded === false) {\n            \/** @psalm-suppress PossiblyInvalidArgument *\/\n            $new->value = $new->_expand($new->value);\n        }\n\n        \/** @psalm-suppress PossiblyInvalidArgument *\/\n        $new->value = Arr::insert($new->value, $path, $value);\n\n        return $new;\n    }\n\n    \/**\n     * Cr\u00e9er un nouveau cookie sans chemin sp\u00e9cifique\n     *\/\n    public function withoutAddedValue(string $path): self\n    {\n        $new = clone $this;\n        if ($new->isExpanded === false) {\n            \/** @psalm-suppress PossiblyInvalidArgument *\/\n            $new->value = $new->_expand($new->value);\n        }\n\n        \/** @psalm-suppress PossiblyInvalidArgument *\/\n        $new->value = Arr::remove($new->value, $path);\n\n        return $new;\n    }\n\n    \/**\n     * Lire les donn\u00e9es du cookie\n     *\n     * Cette m\u00e9thode \u00e9tendra les donn\u00e9es complexes s\u00e9rialis\u00e9es,\n     * \u00e0 la premi\u00e8re utilisation.\n     *\/\n    public function read(?string $path = null)\n    {\n        if ($this->isExpanded === false) {\n            \/** @psalm-suppress PossiblyInvalidArgument *\/\n            $this->value = $this->_expand($this->value);\n        }\n\n        if ($path === null) {\n            return $this->value;\n        }\n\n        \/** @psalm-suppress PossiblyInvalidArgument *\/\n        return Arr::get($this->value, $path);\n    }\n\n    \/**\n     * V\u00e9rifie si la valeur du cookie a \u00e9t\u00e9 \u00e9tendue\n     *\/\n    public function isExpanded(): bool\n    {\n        return $this->isExpanded;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getOptions(): array\n    {\n        $options = [\n            'expires'  => (int) $this->getExpiresTimestamp(),\n            'path'     => $this->path,\n            'domain'   => $this->domain,\n            'secure'   => $this->secure,\n            'httponly' => $this->httpOnly,\n        ];\n\n        if ($this->sameSite !== null) {\n            $options['samesite'] = $this->sameSite;\n        }\n\n        return $options;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function toArray(): array\n    {\n        return [\n            'name'  => $this->name,\n            'value' => $this->getScalarValue(),\n        ] + $this->getOptions();\n    }\n\n    \/**\n     * La m\u00e9thode Implode pour conserver les cl\u00e9s sont des tableaux multidimensionnels\n     *\n     * @param array $array Carte des cl\u00e9s et des valeurs\n     *\n     * @return string Une cha\u00eene encod\u00e9e JSON.\n     *\/\n    protected function _flatten(array $array): string\n    {\n        return json_encode($array);\n    }\n\n    \/**\n     * M\u00e9thode Explode pour renvoyer le tableau \u00e0 partir de la cha\u00eene d\u00e9finie dans CookieComponent :: _flatten ()\n     * Maintient la r\u00e9trocompatibilit\u00e9 de lecture avec 1.x CookieComponent::_flatten().\n     *\n     * @param string $string Une cha\u00eene contenant des donn\u00e9es encod\u00e9es JSON, ou une cha\u00eene nue.\n     *\n     * @return array|string Carte des cl\u00e9s et des valeurs\n     *\/\n    protected function _expand(string $string)\n    {\n        $this->isExpanded = true;\n        $first            = substr($string, 0, 1);\n        if ($first === '{' || $first === '[') {\n            $ret = json_decode($string, true);\n\n            return $ret ?? $string;\n        }\n\n        $array = [];\n\n        foreach (explode(',', $string) as $pair) {\n            $key = explode('|', $pair);\n            if (! isset($key[1])) {\n                return $key[0];\n            }\n            $array[$key[0]] = $key[1];\n        }\n\n        return $array;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,0,0,0,0,null,0,null,0,0,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,0,null,null,null,0,null,null,null,0,null,0,0,null,null,0,0,null,null,null,0,0,null,null,null,null,null,null,0,null,null,null,0,0,0,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,0,null,0,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,null,0,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,0,null,null,0,null,null,0,null,0,null,0,null,null,0,null,null,null]},{"name":"src\\Http\\Cookie\\CookieCollection.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Http\\Cookie;\n\nuse ArrayIterator;\nuse BlitzPHP\\Contracts\\Http\\CookieInterface;\nuse Countable;\nuse DateTimeImmutable;\nuse DateTimeZone;\nuse Exception;\nuse InvalidArgumentException;\nuse IteratorAggregate;\nuse Psr\\Http\\Message\\RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Traversable;\n\n\/**\n * Fournit une collection immuable d'objets cookies. Ajout ou suppression\n * \u00e0 une collection renvoie une *nouvelle* collection que vous devez conserver.\n *\n * @credit <a href=\"https:\/\/api.cakephp.org\/4.3\/class-Cake.Http.Cookie.CookieCollection.html\">CakePHP - \\Cake\\Http\\Cookie\\CookieCollection<\/a>\n *\/\n\/** @phpstan-consistent-constructor *\/\nclass CookieCollection implements IteratorAggregate, Countable\n{\n    \/**\n     * Cbjets cookies\n     *\n     * @var CookieInterface[]\n     *\/\n    protected $cookies = [];\n\n    \/**\n     * Constructeur\n     *\n     * @param CookieInterface[] $cookies Tableau de cookies\n     *\/\n    public function __construct(array $cookies = [])\n    {\n        $this->checkCookies($cookies);\n\n        foreach ($cookies as $cookie) {\n            $this->cookies[$cookie->getId()] = $cookie;\n        }\n    }\n\n    \/**\n     * Cr\u00e9er une collection de cookies \u00e0 partir d'un tableau d'en-t\u00eates Set-Cookie\n     *\n     * @param array<string>        $header   Le tableau des valeurs d'en-t\u00eate set-cookie.\n     * @param array<string, mixed> $defaults Les attributs par d\u00e9faut.\n     *\/\n    public static function createFromHeader(array $header, array $defaults = []): self\n    {\n        $cookies = [];\n\n        foreach ($header as $value) {\n            try {\n                $cookies[] = Cookie::createFromHeaderString($value, $defaults);\n            } catch (Exception $e) {\n                \/\/ Ne pas exploser sur les cookies invalides\n            }\n        }\n\n        return new static($cookies);\n    }\n\n    \/**\n     * Cr\u00e9er une nouvelle collection \u00e0 partir des cookies dans un ServerRequest\n     *\/\n    public static function createFromServerRequest(ServerRequestInterface $request): self\n    {\n        $data    = $request->getCookieParams();\n        $cookies = [];\n\n        foreach ($data as $name => $value) {\n            $cookies[] = new Cookie($name, $value);\n        }\n\n        return new static($cookies);\n    }\n\n    \/**\n     * Obtenir le nombre de cookies dans la collection.\n     *\/\n    public function count(): int\n    {\n        return count($this->cookies);\n    }\n\n    \/**\n     * Ajoutez un cookie et obtenez une collection mise \u00e0 jour.\n     *\n     * Les cookies sont stock\u00e9s par identifiant. Cela signifie qu'il peut y avoir des doublons\n     * cookies si une collection de cookies est utilis\u00e9e pour les cookies sur plusieurs\n     * domaines. Cela peut avoir un impact sur le comportement de get(), has() et remove().\n     *\/\n    public function add(CookieInterface $cookie): self\n    {\n        $new                            = clone $this;\n        $new->cookies[$cookie->getId()] = $cookie;\n\n        return $new;\n    }\n\n    \/**\n     * Obtenez le premier cookie par son nom.\n     *\n     * @throws InvalidArgumentException If cookie not found.\n     *\/\n    public function get(string $name): CookieInterface\n    {\n        $key = mb_strtolower($name);\n\n        foreach ($this->cookies as $cookie) {\n            if (mb_strtolower($cookie->getName()) === $key) {\n                return $cookie;\n            }\n        }\n\n        throw new InvalidArgumentException(\n            sprintf(\n                'Cookie %s not found. Use has() to check first for existence.',\n                $name\n            )\n        );\n    }\n\n    \/**\n     * V\u00e9rifier si un cookie avec le nom donn\u00e9 existe\n     *\/\n    public function has(string $name): bool\n    {\n        $key = mb_strtolower($name);\n\n        foreach ($this->cookies as $cookie) {\n            if (mb_strtolower($cookie->getName()) === $key) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    \/**\n     * Cr\u00e9ez une nouvelle collection avec tous les cookies correspondant \u00e0 $name supprim\u00e9s.\n     *\n     * Si le cookie n'est pas dans la collection, cette m\u00e9thode ne fera rien.\n     *\/\n    public function remove(string $name): self\n    {\n        $new = clone $this;\n        $key = mb_strtolower($name);\n\n        foreach ($new->cookies as $i => $cookie) {\n            if (mb_strtolower($cookie->getName()) === $key) {\n                unset($new->cookies[$i]);\n            }\n        }\n\n        return $new;\n    }\n\n    \/**\n     * V\u00e9rifie si seuls des objets de cookie valides sont dans le tableau\n     *\n     * @param CookieInterface[] $cookies\n     *\n     * @throws InvalidArgumentException\n     *\/\n    protected function checkCookies(array $cookies): void\n    {\n        foreach ($cookies as $index => $cookie) {\n            if (! $cookie instanceof CookieInterface) {\n                throw new InvalidArgumentException(\n                    sprintf(\n                        'Expected `%s[]` as $cookies but instead got `%s` at index %d',\n                        static::class,\n                        getTypeName($cookie),\n                        $index\n                    )\n                );\n            }\n        }\n    }\n\n    \/**\n     * Obtient l'it\u00e9rateur\n     *\n     * @return Traversable<string, CookieInterface>\n     *\/\n    public function getIterator(): Traversable\n    {\n        return new ArrayIterator($this->cookies);\n    }\n\n    \/**\n     * Ajoutez des cookies qui correspondent au chemin\/domaine\/expiration de la requ\u00eate.\n     *\n     * Cela permet aux CookieCollections d'\u00eatre utilis\u00e9es comme \"cookie jar\" dans un client HTTP\n     * situation. Cookies correspondant au domaine + chemin de la requ\u00eate qui n'ont pas expir\u00e9\n     * lorsque cette m\u00e9thode est appel\u00e9e sera appliqu\u00e9e \u00e0 la requ\u00eate.\n     *\n     * @param array $extraCookies Tableau associatif de cookies suppl\u00e9mentaires \u00e0 ajouter \u00e0 la requ\u00eate. Ceci\n     *                            est utile lorsque vous avez des donn\u00e9es de cookies en dehors de la collection que vous souhaitez envoyer.\n     *\/\n    public function addToRequest(RequestInterface $request, array $extraCookies = []): RequestInterface\n    {\n        $uri     = $request->getUri();\n        $cookies = $this->findMatchingCookies(\n            $uri->getScheme(),\n            $uri->getHost(),\n            $uri->getPath() ?: '\/'\n        );\n        $cookies     = array_merge($cookies, $extraCookies);\n        $cookiePairs = [];\n\n        foreach ($cookies as $key => $value) {\n            $cookie = sprintf('%s=%s', rawurlencode($key), rawurlencode($value));\n            $size   = strlen($cookie);\n            if ($size > 4096) {\n                trigger_warning(sprintf(\n                    'The cookie `%s` exceeds the recommended maximum cookie length of 4096 bytes.',\n                    $key\n                ));\n            }\n            $cookiePairs[] = $cookie;\n        }\n\n        if (empty($cookiePairs)) {\n            return $request;\n        }\n\n        return $request->withHeader('Cookie', implode('; ', $cookiePairs));\n    }\n\n    \/**\n     * Rechercher les cookies correspondant au sch\u00e9ma, \u00e0 l'h\u00f4te et au chemin\n     *\/\n    protected function findMatchingCookies(string $scheme, string $host, string $path): array\n    {\n        $out = [];\n        $now = new DateTimeImmutable('now', new DateTimeZone('UTC'));\n\n        foreach ($this->cookies as $cookie) {\n            if ($scheme === 'http' && $cookie->isSecure()) {\n                continue;\n            }\n            if (strpos($path, $cookie->getPath()) !== 0) {\n                continue;\n            }\n            $domain     = $cookie->getDomain();\n            $leadingDot = substr($domain, 0, 1) === '.';\n            if ($leadingDot) {\n                $domain = ltrim($domain, '.');\n            }\n\n            if ($cookie->isExpired($now)) {\n                continue;\n            }\n\n            $pattern = '\/' . preg_quote($domain, '\/') . '$\/';\n            if (! preg_match($pattern, $host)) {\n                continue;\n            }\n\n            $out[$cookie->getName()] = $cookie->getValue();\n        }\n\n        return $out;\n    }\n\n    \/**\n     * Cr\u00e9ez une nouvelle collection qui inclut les cookies de la r\u00e9ponse.\n     *\/\n    public function addFromResponse(ResponseInterface $response, RequestInterface $request): self\n    {\n        $uri  = $request->getUri();\n        $host = $uri->getHost();\n        $path = $uri->getPath() ?: '\/';\n\n        $cookies = static::createFromHeader(\n            $response->getHeader('Set-Cookie'),\n            ['domain' => $host, 'path' => $path]\n        );\n        $new = clone $this;\n\n        foreach ($cookies as $cookie) {\n            $new->cookies[$cookie->getId()] = $cookie;\n        }\n        $new->removeExpiredCookies($host, $path);\n\n        return $new;\n    }\n\n    \/**\n     * Supprimez les cookies expir\u00e9s de la collection.\n     *\/\n    protected function removeExpiredCookies(string $host, string $path): void\n    {\n        $time        = new DateTimeImmutable('now', new DateTimeZone('UTC'));\n        $hostPattern = '\/' . preg_quote($host, '\/') . '$\/';\n\n        foreach ($this->cookies as $i => $cookie) {\n            if (! $cookie->isExpired($time)) {\n                continue;\n            }\n            $pathMatches = strpos($path, $cookie->getPath()) === 0;\n            $hostMatches = preg_match($hostPattern, $cookie->getDomain());\n            if ($pathMatches && $hostMatches) {\n                unset($this->cookies[$i]);\n            }\n        }\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,0,null,null,null,null,null,null,null,0,0,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,0,0,null,null,0,0,null,null,null,null,0,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,0,null,null,null,0,null,null,0,null,0,0,null,0,null,null,null,0,null,null,0,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,0,0,0,null,null,null,null,0,0,null,null,0,null,0,null,0,null,null,null,null,null,null,null,0,0,null,null,null,0,null,0,0,null,0,null,null,null,null,null]},{"name":"src\\Http\\Middleware.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Http;\n\nuse BlitzPHP\\Loader\\Services;\nuse LogicException;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Server\\RequestHandlerInterface;\n\nclass Middleware implements RequestHandlerInterface\n{\n    \/**\n     * @var ResponseInterface\n     *\/\n    private $response;\n\n    \/**\n     * @var array\n     *\/\n    private $middlewares = [];\n\n    \/**\n     * @var int\n     *\/\n    private $index = 0;\n\n    \/**\n     * Contructor\n     *\/\n    public function __construct(Response $response)\n    {\n        $this->response = $response;\n    }\n\n    \/**\n     * Ajoute un middleware a la chaine d'execution\n     *\n     * @param array|callable|object|string $middlewares\n     *\/\n    public function add($middlewares): self\n    {\n        if (! is_array($middlewares)) {\n            $middlewares = [$middlewares];\n        }\n\n        foreach ($middlewares as $middleware) {\n            $this->append($middleware);\n        }\n\n        return $this;\n    }\n\n    \/**\n     * Ajoute un middleware en bout de chaine\n     *\n     * @param callable|object|string $middleware\n     *\/\n    public function append($middleware): self\n    {\n        $middleware          = $this->makeMiddleware($middleware);\n        $this->middlewares[] = $middleware;\n\n        return $this;\n    }\n\n    \/**\n     * Ajoute un middleware en debut de chaine\n     *\n     * @param callable|object|string $middleware\n     *\/\n    public function prepend($middleware): self\n    {\n        $middleware = $this->makeMiddleware($middleware);\n        array_unshift($this->middlewares, $middleware);\n\n        return $this;\n    }\n\n    \/**\n     * insert un middleware a une position donnee\n     *\n     * @param callable|object|string $middleware\n     * @alias insertAt\n     *\/\n    public function insert(int $index, $middleware): self\n    {\n        return $this->insertAt($index, $middleware);\n    }\n\n    \/**\n     * Ins\u00e9rez un middleware appelable \u00e0 un index sp\u00e9cifique.\n     *\n     * Si l'index existe d\u00e9j\u00e0, le nouvel appelable sera ins\u00e9r\u00e9,\n     * et l'\u00e9l\u00e9ment existant sera d\u00e9cal\u00e9 d'un indice sup\u00e9rieur.\n     *\n     * @param int                    $index      La position o\u00f9 le middleware doit \u00eatre ins\u00e9rer.\n     * @param callable|object|string $middleware Le middleware \u00e0 inserer.\n     *\/\n    public function insertAt(int $index, $middleware): self\n    {\n        $middleware = $this->makeMiddleware($middleware);\n        array_splice($this->middlewares, $index, 0, $middleware);\n\n        return $this;\n    }\n\n    \/**\n     * Ins\u00e9rez un objet middleware avant la premi\u00e8re classe correspondante.\n     *\n     * Trouve l'index du premier middleware qui correspond \u00e0 la classe fournie,\n     * et ins\u00e8re l'appelable fourni avant.\n     *\n     * @param string                 $class      Le nom de classe pour ins\u00e9rer le middleware avant.\n     * @param callable|object|string $middleware Le middleware \u00e0 inserer.\n     *\n     * @throws LogicException Si le middleware \u00e0 ins\u00e9rer avant n'est pas trouv\u00e9.\n     *\/\n    public function insertBefore(string $class, $middleware): self\n    {\n        $found = false;\n        $i     = 0;\n\n        foreach ($this->middlewares as $i => $object) {\n            if ((is_string($object) && $object === $class) || is_a($object, $class)) {\n                $found = true;\n                break;\n            }\n        }\n        if ($found) {\n            return $this->insertAt($i, $middleware);\n        }\n\n        throw new LogicException(sprintf(\"No middleware matching '%s' could be found.\", $class));\n    }\n\n    \/**\n     * Ins\u00e9rez un objet middleware apr\u00e8s la premi\u00e8re classe correspondante.\n     *\n     * Trouve l'index du premier middleware qui correspond \u00e0 la classe fournie,\n     * et ins\u00e8re le callback fourni apr\u00e8s celui-ci. Si la classe n'est pas trouv\u00e9e,\n     * cette m\u00e9thode se comportera comme add().\n     *\n     * @param string                 $class      Le nom de classe pour ins\u00e9rer le middleware apr\u00e8s.\n     * @param callable|object|string $middleware Le middleware \u00e0 inserer.\n     *\/\n    public function insertAfter(string $class, $middleware): self\n    {\n        $found = false;\n        $i     = 0;\n\n        foreach ($this->middlewares as $i => $object) {\n            if ((is_string($object) && $object === $class) || is_a($object, $class)) {\n                $found = true;\n                break;\n            }\n        }\n        if ($found) {\n            return $this->insertAt($i + 1, $middleware);\n        }\n\n        return $this->add($middleware);\n    }\n\n    \/**\n     * Execution du middleware\n     *\/\n    public function handle(ServerRequestInterface $request): ResponseInterface\n    {\n        $middleware = $this->getMiddleware();\n\n        if (empty($middleware)) {\n            return $this->response;\n        }\n        if (is_callable($middleware)) {\n            return $middleware($request, $this->response, [$this, 'handle']);\n        }\n\n        return $middleware->process($request, $this);\n    }\n\n    \/**\n     * Fabrique un middleware\n     *\n     * @param callable|object|string $middleware\n     *\n     * @return callable|object\n     *\/\n    private function makeMiddleware($middleware)\n    {\n        if (is_string($middleware)) {\n            return Services::container()->get($middleware);\n        }\n\n        return $middleware;\n    }\n\n    \/**\n     * Recuperation du middleware actuel\n     *\n     * @return callable|object|null\n     *\/\n    private function getMiddleware()\n    {\n        $middleware = null;\n\n        if (isset($this->middlewares[$this->index])) {\n            $middleware = $this->middlewares[$this->index];\n        }\n        $this->index++;\n\n        return $middleware;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,0,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,0,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,0,null,null,null]},{"name":"src\\Http\\Negotiator.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Http;\n\nuse BlitzPHP\\Exceptions\\HttpException;\n\nclass Negotiator\n{\n    \/**\n     * Request\n     *\n     * @var ServerRequest\n     *\/\n    protected $request;\n\n    \/**\n     * Constructor\n     *\n     * @param ServerRequest $request\n     *\/\n    public function __construct(?ServerRequest $request = null)\n    {\n        if (null !== $request) {\n            $this->request = $request;\n        }\n    }\n\n    \/**\n     * Stores the request instance to grab the headers from.\n     *\/\n    public function setRequest(ServerRequest $request): self\n    {\n        $this->request = $request;\n\n        return $this;\n    }\n\n    \/**\n     * Determines the best content-type to use based on the $supported\n     * types the application says it supports, and the types requested\n     * by the client.\n     *\n     * If no match is found, the first, highest-ranking client requested\n     * type is returned.\n     *\n     * @param bool $strictMatch If TRUE, will return an empty string when no match found.\n     *                          If FALSE, will return the first supported element.\n     *\/\n    public function media(array $supported, bool $strictMatch = false): string\n    {\n        return $this->getBestMatch($supported, $this->request->getHeaderLine('accept'), true, $strictMatch);\n    }\n\n    \/**\n     * Determines the best charset to use based on the $supported\n     * types the application says it supports, and the types requested\n     * by the client.\n     *\n     * If no match is found, the first, highest-ranking client requested\n     * type is returned.\n     *\/\n    public function charset(array $supported): string\n    {\n        $match = $this->getBestMatch($supported, $this->request->getHeaderLine('accept-charset'), false, true);\n\n        \/\/ If no charset is shown as a match, ignore the directive\n        \/\/ as allowed by the RFC, and tell it a default value.\n        if (empty($match)) {\n            return 'utf-8';\n        }\n\n        return $match;\n    }\n\n    \/**\n     * Determines the best encoding type to use based on the $supported\n     * types the application says it supports, and the types requested\n     * by the client.\n     *\n     * If no match is found, the first, highest-ranking client requested\n     * type is returned.\n     *\/\n    public function encoding(array $supported = []): string\n    {\n        $supported[] = 'identity';\n\n        return $this->getBestMatch($supported, $this->request->getHeaderLine('accept-encoding'));\n    }\n\n    \/**\n     * Determines the best language to use based on the $supported\n     * types the application says it supports, and the types requested\n     * by the client.\n     *\n     * If no match is found, the first, highest-ranking client requested\n     * type is returned.\n     *\/\n    public function language(array $supported): string\n    {\n        return $this->getBestMatch($supported, $this->request->getHeaderLine('accept-language'));\n    }\n\n    \/\/--------------------------------------------------------------------\n    \/\/ Utility Methods\n    \/\/--------------------------------------------------------------------\n\n    \/**\n     * Does the grunt work of comparing any of the app-supported values\n     * against a given Accept* header string.\n     *\n     * Portions of this code base on Aura.Accept library.\n     *\n     * @param array  $supported    App-supported values\n     * @param string $header       header string\n     * @param bool   $enforceTypes If TRUE, will compare media types and sub-types.\n     * @param bool   $strictMatch  If TRUE, will return empty string on no match.\n     *                             If FALSE, will return the first supported element.\n     *\n     * @return string Best match\n     *\/\n    protected function getBestMatch(array $supported, ?string $header = null, bool $enforceTypes = false, bool $strictMatch = false): string\n    {\n        if (empty($supported)) {\n            throw new HttpException('You must provide an array of supported values to all Negotiations.');\n        }\n\n        if (empty($header)) {\n            return $strictMatch ? '' : $supported[0];\n        }\n\n        $acceptable = $this->parseHeader($header);\n\n        foreach ($acceptable as $accept) {\n            \/\/ if acceptable quality is zero, skip it.\n            if ($accept['q'] === 0.0) {\n                continue;\n            }\n\n            \/\/ if acceptable value is \"anything\", return the first available\n            if ($accept['value'] === '*' || $accept['value'] === '*\/*') {\n                return $supported[0];\n            }\n\n            \/\/ If an acceptable value is supported, return it\n            foreach ($supported as $available) {\n                if ($this->match($accept, $available, $enforceTypes)) {\n                    return $available;\n                }\n            }\n        }\n\n        \/\/ No matches? Return the first supported element.\n        return $strictMatch ? '' : $supported[0];\n    }\n\n    \/**\n     * Parses an Accept* header into it's multiple values.\n     *\n     * This is based on code from Aura.Accept library.\n     *\/\n    public function parseHeader(string $header): array\n    {\n        $results    = [];\n        $acceptable = explode(',', $header);\n\n        foreach ($acceptable as $value) {\n            $pairs = explode(';', $value);\n\n            $value = $pairs[0];\n\n            unset($pairs[0]);\n\n            $parameters = [];\n\n            foreach ($pairs as $pair) {\n                $param = [];\n                preg_match(\n                    '\/^(?P<name>.+?)=(?P<quoted>\"|\\')?(?P<value>.*?)(?:\\k<quoted>)?$\/',\n                    $pair,\n                    $param\n                );\n                $parameters[trim($param['name'])] = trim($param['value']);\n            }\n\n            $quality = 1.0;\n\n            if (array_key_exists('q', $parameters)) {\n                $quality = $parameters['q'];\n                unset($parameters['q']);\n            }\n\n            $results[] = [\n                'value'  => trim($value),\n                'q'      => (float) $quality,\n                'params' => $parameters,\n            ];\n        }\n\n        \/\/ Sort to get the highest results first\n        usort($results, static function ($a, $b) {\n            if ($a['q'] === $b['q']) {\n                $a_ast = substr_count($a['value'], '*');\n                $b_ast = substr_count($b['value'], '*');\n\n                \/\/ '*\/*' has lower precedence than 'text\/*',\n                \/\/ and 'text\/*' has lower priority than 'text\/plain'\n                \/\/\n                \/\/ This seems backwards, but needs to be that way\n                \/\/ due to the way PHP7 handles ordering or array\n                \/\/ elements created by reference.\n                if ($a_ast > $b_ast) {\n                    return 1;\n                }\n\n                \/\/ If the counts are the same, but one element\n                \/\/ has more params than another, it has higher precedence.\n                \/\/\n                \/\/ This seems backwards, but needs to be that way\n                \/\/ due to the way PHP7 handles ordering or array\n                \/\/ elements created by reference.\n                if ($a_ast === $b_ast) {\n                    return count($b['params']) - count($a['params']);\n                }\n\n                return 0;\n            }\n\n            \/\/ Still here? Higher q values have precedence.\n            return ($a['q'] > $b['q']) ? -1 : 1;\n        });\n\n        return $results;\n    }\n\n    \/**\n     * Match-maker\n     *\/\n    protected function match(array $acceptable, string $supported, bool $enforceTypes = false): bool\n    {\n        $supported = $this->parseHeader($supported);\n        if (is_array($supported) && count($supported) === 1) {\n            $supported = $supported[0];\n        }\n\n        \/\/ Is it an exact match?\n        if ($acceptable['value'] === $supported['value']) {\n            return $this->matchParameters($acceptable, $supported);\n        }\n\n        \/\/ Do we need to compare types\/sub-types? Only used\n        \/\/ by negotiateMedia().\n        if ($enforceTypes) {\n            return $this->matchTypes($acceptable, $supported);\n        }\n\n        return false;\n    }\n\n    \/**\n     * Checks two Accept values with matching 'values' to see if their\n     * 'params' are the same.\n     *\/\n    protected function matchParameters(array $acceptable, array $supported): bool\n    {\n        if (count($acceptable['params']) !== count($supported['params'])) {\n            return false;\n        }\n\n        foreach ($supported['params'] as $label => $value) {\n            if (! isset($acceptable['params'][$label]) || $acceptable['params'][$label] !== $value) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * Compares the types\/subtypes of an acceptable Media type and\n     * the supported string.\n     *\/\n    public function matchTypes(array $acceptable, array $supported): bool\n    {\n        [$aType, $aSubType] = explode('\/', $acceptable['value']);\n        [$sType, $sSubType] = explode('\/', $supported['value']);\n\n        \/\/ If the types don't match, we're done.\n        if ($aType !== $sType) {\n            return false;\n        }\n\n        \/\/ If there's an asterisk, we're cool\n        if ($aSubType === '*') {\n            return true;\n        }\n\n        \/\/ Otherwise, subtypes must match also.\n        return $aSubType === $sSubType;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,null,0,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,0,null,0,null,0,null,0,null,null,0,null,null,null,null,0,0,null,null,0,null,null,0,0,null,null,null,null,null,null,0,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,0,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,0,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,0,0,null,null,null,0,null,null,null,null,0,null,null,null,0,null,null,null]},{"name":"src\\Http\\Redirection.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\HTTP;\n\nuse BlitzPHP\\Exceptions\\HttpException;\nuse BlitzPHP\\Loader\\Services;\n\n\/**\n * G\u00e9rer une r\u00e9ponse de redirection\n *\n * @credit CodeIgniter 4 <a href=\"https:\/\/codeigniter.com\">CodeIgniter\\HTTP\\RedirectResponse<\/a>\n *\/\nclass Redirection extends Response\n{\n    \/**\n     * D\u00e9finit l'URI vers lequel rediriger et, \u00e9ventuellement, le code d'\u00e9tat HTTP \u00e0 utiliser.\n     * Si aucun code n'est fourni, il sera automatiquement d\u00e9termin\u00e9.\n     *\n     * @param string   $uri  L'URI vers laquelle rediriger\n     * @param int|null $code Code d'\u00e9tat HTTP\n     *\/\n    public function to(string $uri, ?int $code = null, string $method = 'auto'): self\n    {\n        \/\/ Si cela semble \u00eatre une URL relative, alors convertissez-la en URL compl\u00e8te\n        \/\/ pour une meilleure s\u00e9curit\u00e9.\n        if (strpos($uri, 'http') !== 0) {\n            $uri = site_url($uri);\n        }\n\n        return $this->redirect($uri, $method, $code);\n    }\n\n    \/**\n     * Sets the URI to redirect to but as a reverse-routed or named route\n     * instead of a raw URI.\n     *\n     * @throws HTTPException\n     *\/\n    public function route(string $route, array $params = [], int $code = 302, string $method = 'auto'): self\n    {\n        $route = Services::routes()->reverseRoute($route, ...$params);\n\n        if (! $route) {\n            throw HttpException::invalidRedirectRoute($route);\n        }\n\n        return $this->redirect(site_url($route), $method, $code);\n    }\n\n    \/**\n     * Helper function to return to previous page.\n     *\n     * Example:\n     *  return redirect()->back();\n     *\/\n    public function back(?int $code = null, string $method = 'auto'): self\n    {\n        Services::session();\n\n        return $this->redirect(previous_url(), $method, $code);\n    }\n\n    \/**\n     * Sp\u00e9cifie que les tableaux $_GET et $_POST actuels doivent \u00eatre\n     * emball\u00e9 avec la r\u00e9ponse.\n     *\n     * Il sera alors disponible via la fonction d'assistance 'old()'.\n     *\/\n    public function withInput(): self\n    {\n        $session = Services::session();\n\n        \/*  $session->setFlashdata('_ci_old_input', [\n             'get'  => $_GET ?? [],\n             'post' => $_POST ?? [],\n         ]); *\/\n\n        \/\/ Si la validation contient des erreurs, retransmettez-les\n        \/\/ afin qu'ils puissent \u00eatre affich\u00e9s lors de la validation\n        \/\/ dans une m\u00e9thode diff\u00e9rente de l'affichage du formulaire.\n\n        \/* $validation = Services::validation();\n\n        if ($validation->getErrors()) {\n            \/\/$session->setFlashdata('_ci_validation_errors', serialize($validation->getErrors()));\n        } *\/\n\n        return $this;\n    }\n\n    \/**\n     * Ajoute une cl\u00e9 et un message \u00e0 la session en tant que Flashdata.\n     *\n     * @param array|string $message\n     *\/\n    public function with(string $key, $message): self\n    {\n        \/\/ Services::session()->setFlashdata($key, $message);\n\n        return $this;\n    }\n\n    \/**\n     * Copie tous les en-t\u00eates de l'instance de r\u00e9ponse globale\n     * dans cette Redirection. Utile lorsque vous venez de\n     * d\u00e9finir un en-t\u00eate pour s'assurer qu'il est bien envoy\u00e9\n     * avec la r\u00e9ponse de redirection..\n     *\/\n    public function withHeaders(): self\n    {\n        $new = clone $this;\n\n        foreach (Services::response()->getHeaders() as $name => $header) {\n            $new = $new->withHeader($name, $header);\n        }\n\n        return $new;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null]},{"name":"src\\Http\\Response.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Http;\n\nuse BlitzPHP\\Contracts\\Http\\CookieInterface;\nuse BlitzPHP\\Contracts\\Http\\StatusCode;\nuse BlitzPHP\\Exceptions\\HttpException;\nuse BlitzPHP\\Exceptions\\LoadException;\nuse BlitzPHP\\Http\\Cookie\\CookieCollection;\nuse DateTime;\nuse DateTimeInterface;\nuse DateTimeZone;\nuse GuzzleHttp\\Psr7\\MessageTrait;\nuse GuzzleHttp\\Psr7\\Stream;\nuse GuzzleHttp\\Psr7\\Utils;\nuse InvalidArgumentException;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\StreamInterface;\nuse SplFileInfo;\n\n\/**\n * Les r\u00e9ponses contiennent le texte de la r\u00e9ponse, l'\u00e9tat et les en-t\u00eates d'une r\u00e9ponse HTTP.\n *\n * Il existe des packages externes tels que `fig\/http-message-util` qui fournissent HTTP\n * constantes de code d'\u00e9tat. Ceux-ci peuvent \u00eatre utilis\u00e9s avec n'importe quelle m\u00e9thode qui accepte ou\n * renvoie un entier de code d'\u00e9tat. Gardez \u00e0 l'esprit que ces constantes peuvent\n * inclure les codes d'\u00e9tat qui sont maintenant autoris\u00e9s, ce qui lancera un\n * `\\InvalidArgumentException`.\n *\n * @credit CakePHP <a href=\"https:\/\/api.cakephp.org\/4.3\/class-Cake.Http.Response.html\">Cake\\Http\\Response<\/a>\n *\/\nclass Response implements ResponseInterface\n{\n    use MessageTrait;\n\n    \/**\n     * @var int\n     *\/\n    public const STATUS_CODE_MIN = 100;\n\n    \/**\n     * @var int\n     *\/\n    public const STATUS_CODE_MAX = 599;\n\n    \/**\n     * Codes d'\u00e9tat HTTP autoris\u00e9s et leur description par d\u00e9faut.\n     *\n     * @var array<int, string>\n     *\/\n    protected $_statusCodes = [\n        100 => 'Continue',\n        101 => 'Switching Protocols',\n        102 => 'Processing',\n        200 => 'OK',\n        201 => 'Created',\n        202 => 'Accepted',\n        203 => 'Non-Authoritative Information',\n        204 => 'No Content',\n        205 => 'Reset Content',\n        206 => 'Partial Content',\n        207 => 'Multi-status',\n        208 => 'Already Reported',\n        226 => 'IM used',\n        300 => 'Multiple Choices',\n        301 => 'Moved Permanently',\n        302 => 'Found',\n        303 => 'See Other',\n        304 => 'Not Modified',\n        305 => 'Use Proxy',\n        306 => '(Unused)',\n        307 => 'Temporary Redirect',\n        308 => 'Permanent Redirect',\n        400 => 'Bad Request',\n        401 => 'Unauthorized',\n        402 => 'Payment Required',\n        403 => 'Forbidden',\n        404 => 'Not Found',\n        405 => 'Method Not Allowed',\n        406 => 'Not Acceptable',\n        407 => 'Proxy Authentication Required',\n        408 => 'Request Timeout',\n        409 => 'Conflict',\n        410 => 'Gone',\n        411 => 'Length Required',\n        412 => 'Precondition Failed',\n        413 => 'Request Entity Too Large',\n        414 => 'Request-URI Too Large',\n        415 => 'Unsupported Media Type',\n        416 => 'Requested range not satisfiable',\n        417 => 'Expectation Failed',\n        418 => 'I\\'m a teapot',\n        421 => 'Misdirected Request',\n        422 => 'Unprocessable Entity',\n        423 => 'Locked',\n        424 => 'Failed Dependency',\n        425 => 'Unordered Collection',\n        426 => 'Upgrade Required',\n        428 => 'Precondition Required',\n        429 => 'Too Many Requests',\n        431 => 'Request Header Fields Too Large',\n        444 => 'Connection Closed Without Response',\n        451 => 'Unavailable For Legal Reasons',\n        499 => 'Client Closed Request',\n        500 => 'Internal Server Error',\n        501 => 'Not Implemented',\n        502 => 'Bad Gateway',\n        503 => 'Service Unavailable',\n        504 => 'Gateway Timeout',\n        505 => 'Unsupported Version',\n        506 => 'Variant Also Negotiates',\n        507 => 'Insufficient Storage',\n        508 => 'Loop Detected',\n        510 => 'Not Extended',\n        511 => 'Network Authentication Required',\n        599 => 'Network Connect Timeout Error',\n    ];\n\n    \/**\n     * Contient la cl\u00e9 de type pour les mappages de type mime pour les types mime connus.\n     *\n     * @var array<string, mixed>\n     *\/\n    protected $_mimeTypes = [\n        'html'    => ['text\/html', '*\/*'],\n        'json'    => 'application\/json',\n        'xml'     => ['application\/xml', 'text\/xml'],\n        'xhtml'   => ['application\/xhtml+xml', 'application\/xhtml', 'text\/xhtml'],\n        'webp'    => 'image\/webp',\n        'rss'     => 'application\/rss+xml',\n        'ai'      => 'application\/postscript',\n        'bcpio'   => 'application\/x-bcpio',\n        'bin'     => 'application\/octet-stream',\n        'ccad'    => 'application\/clariscad',\n        'cdf'     => 'application\/x-netcdf',\n        'class'   => 'application\/octet-stream',\n        'cpio'    => 'application\/x-cpio',\n        'cpt'     => 'application\/mac-compactpro',\n        'csh'     => 'application\/x-csh',\n        'csv'     => ['text\/csv', 'application\/vnd.ms-excel'],\n        'dcr'     => 'application\/x-director',\n        'dir'     => 'application\/x-director',\n        'dms'     => 'application\/octet-stream',\n        'doc'     => 'application\/msword',\n        'docx'    => 'application\/vnd.openxmlformats-officedocument.wordprocessingml.document',\n        'drw'     => 'application\/drafting',\n        'dvi'     => 'application\/x-dvi',\n        'dwg'     => 'application\/acad',\n        'dxf'     => 'application\/dxf',\n        'dxr'     => 'application\/x-director',\n        'eot'     => 'application\/vnd.ms-fontobject',\n        'eps'     => 'application\/postscript',\n        'exe'     => 'application\/octet-stream',\n        'ez'      => 'application\/andrew-inset',\n        'flv'     => 'video\/x-flv',\n        'gtar'    => 'application\/x-gtar',\n        'gz'      => 'application\/x-gzip',\n        'bz2'     => 'application\/x-bzip',\n        '7z'      => 'application\/x-7z-compressed',\n        'hal'     => ['application\/hal+xml', 'application\/vnd.hal+xml'],\n        'haljson' => ['application\/hal+json', 'application\/vnd.hal+json'],\n        'halxml'  => ['application\/hal+xml', 'application\/vnd.hal+xml'],\n        'hdf'     => 'application\/x-hdf',\n        'hqx'     => 'application\/mac-binhex40',\n        'ico'     => 'image\/x-icon',\n        'ips'     => 'application\/x-ipscript',\n        'ipx'     => 'application\/x-ipix',\n        'js'      => 'application\/javascript',\n        'jsonapi' => 'application\/vnd.api+json',\n        'latex'   => 'application\/x-latex',\n        'jsonld'  => 'application\/ld+json',\n        'kml'     => 'application\/vnd.google-earth.kml+xml',\n        'kmz'     => 'application\/vnd.google-earth.kmz',\n        'lha'     => 'application\/octet-stream',\n        'lsp'     => 'application\/x-lisp',\n        'lzh'     => 'application\/octet-stream',\n        'man'     => 'application\/x-troff-man',\n        'me'      => 'application\/x-troff-me',\n        'mif'     => 'application\/vnd.mif',\n        'ms'      => 'application\/x-troff-ms',\n        'nc'      => 'application\/x-netcdf',\n        'oda'     => 'application\/oda',\n        'otf'     => 'font\/otf',\n        'pdf'     => 'application\/pdf',\n        'pgn'     => 'application\/x-chess-pgn',\n        'pot'     => 'application\/vnd.ms-powerpoint',\n        'pps'     => 'application\/vnd.ms-powerpoint',\n        'ppt'     => 'application\/vnd.ms-powerpoint',\n        'pptx'    => 'application\/vnd.openxmlformats-officedocument.presentationml.presentation',\n        'ppz'     => 'application\/vnd.ms-powerpoint',\n        'pre'     => 'application\/x-freelance',\n        'prt'     => 'application\/pro_eng',\n        'ps'      => 'application\/postscript',\n        'roff'    => 'application\/x-troff',\n        'scm'     => 'application\/x-lotusscreencam',\n        'set'     => 'application\/set',\n        'sh'      => 'application\/x-sh',\n        'shar'    => 'application\/x-shar',\n        'sit'     => 'application\/x-stuffit',\n        'skd'     => 'application\/x-koan',\n        'skm'     => 'application\/x-koan',\n        'skp'     => 'application\/x-koan',\n        'skt'     => 'application\/x-koan',\n        'smi'     => 'application\/smil',\n        'smil'    => 'application\/smil',\n        'sol'     => 'application\/solids',\n        'spl'     => 'application\/x-futuresplash',\n        'src'     => 'application\/x-wais-source',\n        'step'    => 'application\/STEP',\n        'stl'     => 'application\/SLA',\n        'stp'     => 'application\/STEP',\n        'sv4cpio' => 'application\/x-sv4cpio',\n        'sv4crc'  => 'application\/x-sv4crc',\n        'svg'     => 'image\/svg+xml',\n        'svgz'    => 'image\/svg+xml',\n        'swf'     => 'application\/x-shockwave-flash',\n        't'       => 'application\/x-troff',\n        'tar'     => 'application\/x-tar',\n        'tcl'     => 'application\/x-tcl',\n        'tex'     => 'application\/x-tex',\n        'texi'    => 'application\/x-texinfo',\n        'texinfo' => 'application\/x-texinfo',\n        'tr'      => 'application\/x-troff',\n        'tsp'     => 'application\/dsptype',\n        'ttc'     => 'font\/ttf',\n        'ttf'     => 'font\/ttf',\n        'unv'     => 'application\/i-deas',\n        'ustar'   => 'application\/x-ustar',\n        'vcd'     => 'application\/x-cdlink',\n        'vda'     => 'application\/vda',\n        'xlc'     => 'application\/vnd.ms-excel',\n        'xll'     => 'application\/vnd.ms-excel',\n        'xlm'     => 'application\/vnd.ms-excel',\n        'xls'     => 'application\/vnd.ms-excel',\n        'xlsx'    => 'application\/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n        'xlw'     => 'application\/vnd.ms-excel',\n        'zip'     => 'application\/zip',\n        'aif'     => 'audio\/x-aiff',\n        'aifc'    => 'audio\/x-aiff',\n        'aiff'    => 'audio\/x-aiff',\n        'au'      => 'audio\/basic',\n        'kar'     => 'audio\/midi',\n        'mid'     => 'audio\/midi',\n        'midi'    => 'audio\/midi',\n        'mp2'     => 'audio\/mpeg',\n        'mp3'     => 'audio\/mpeg',\n        'mpga'    => 'audio\/mpeg',\n        'ogg'     => 'audio\/ogg',\n        'oga'     => 'audio\/ogg',\n        'spx'     => 'audio\/ogg',\n        'ra'      => 'audio\/x-realaudio',\n        'ram'     => 'audio\/x-pn-realaudio',\n        'rm'      => 'audio\/x-pn-realaudio',\n        'rpm'     => 'audio\/x-pn-realaudio-plugin',\n        'snd'     => 'audio\/basic',\n        'tsi'     => 'audio\/TSP-audio',\n        'wav'     => 'audio\/x-wav',\n        'aac'     => 'audio\/aac',\n        'asc'     => 'text\/plain',\n        'c'       => 'text\/plain',\n        'cc'      => 'text\/plain',\n        'css'     => 'text\/css',\n        'etx'     => 'text\/x-setext',\n        'f'       => 'text\/plain',\n        'f90'     => 'text\/plain',\n        'h'       => 'text\/plain',\n        'hh'      => 'text\/plain',\n        'htm'     => ['text\/html', '*\/*'],\n        'ics'     => 'text\/calendar',\n        'm'       => 'text\/plain',\n        'rtf'     => 'text\/rtf',\n        'rtx'     => 'text\/richtext',\n        'sgm'     => 'text\/sgml',\n        'sgml'    => 'text\/sgml',\n        'tsv'     => 'text\/tab-separated-values',\n        'tpl'     => 'text\/template',\n        'txt'     => 'text\/plain',\n        'text'    => 'text\/plain',\n        'avi'     => 'video\/x-msvideo',\n        'fli'     => 'video\/x-fli',\n        'mov'     => 'video\/quicktime',\n        'movie'   => 'video\/x-sgi-movie',\n        'mpe'     => 'video\/mpeg',\n        'mpeg'    => 'video\/mpeg',\n        'mpg'     => 'video\/mpeg',\n        'qt'      => 'video\/quicktime',\n        'viv'     => 'video\/vnd.vivo',\n        'vivo'    => 'video\/vnd.vivo',\n        'ogv'     => 'video\/ogg',\n        'webm'    => 'video\/webm',\n        'mp4'     => 'video\/mp4',\n        'm4v'     => 'video\/mp4',\n        'f4v'     => 'video\/mp4',\n        'f4p'     => 'video\/mp4',\n        'm4a'     => 'audio\/mp4',\n        'f4a'     => 'audio\/mp4',\n        'f4b'     => 'audio\/mp4',\n        'gif'     => 'image\/gif',\n        'ief'     => 'image\/ief',\n        'jpg'     => 'image\/jpeg',\n        'jpeg'    => 'image\/jpeg',\n        'jpe'     => 'image\/jpeg',\n        'pbm'     => 'image\/x-portable-bitmap',\n        'pgm'     => 'image\/x-portable-graymap',\n        'png'     => 'image\/png',\n        'pnm'     => 'image\/x-portable-anymap',\n        'ppm'     => 'image\/x-portable-pixmap',\n        'ras'     => 'image\/cmu-raster',\n        'rgb'     => 'image\/x-rgb',\n        'tif'     => 'image\/tiff',\n        'tiff'    => 'image\/tiff',\n        'xbm'     => 'image\/x-xbitmap',\n        'xpm'     => 'image\/x-xpixmap',\n        'xwd'     => 'image\/x-xwindowdump',\n        'psd'     => [\n            'application\/photoshop',\n            'application\/psd',\n            'image\/psd',\n            'image\/x-photoshop',\n            'image\/photoshop',\n            'zz-application\/zz-winassoc-psd',\n        ],\n        'ice'          => 'x-conference\/x-cooltalk',\n        'iges'         => 'model\/iges',\n        'igs'          => 'model\/iges',\n        'mesh'         => 'model\/mesh',\n        'msh'          => 'model\/mesh',\n        'silo'         => 'model\/mesh',\n        'vrml'         => 'model\/vrml',\n        'wrl'          => 'model\/vrml',\n        'mime'         => 'www\/mime',\n        'pdb'          => 'chemical\/x-pdb',\n        'xyz'          => 'chemical\/x-pdb',\n        'javascript'   => 'application\/javascript',\n        'form'         => 'application\/x-www-form-urlencoded',\n        'file'         => 'multipart\/form-data',\n        'xhtml-mobile' => 'application\/vnd.wap.xhtml+xml',\n        'atom'         => 'application\/atom+xml',\n        'amf'          => 'application\/x-amf',\n        'wap'          => ['text\/vnd.wap.wml', 'text\/vnd.wap.wmlscript', 'image\/vnd.wap.wbmp'],\n        'wml'          => 'text\/vnd.wap.wml',\n        'wmlscript'    => 'text\/vnd.wap.wmlscript',\n        'wbmp'         => 'image\/vnd.wap.wbmp',\n        'woff'         => 'application\/x-font-woff',\n        'appcache'     => 'text\/cache-manifest',\n        'manifest'     => 'text\/cache-manifest',\n        'htc'          => 'text\/x-component',\n        'rdf'          => 'application\/xml',\n        'crx'          => 'application\/x-chrome-extension',\n        'oex'          => 'application\/x-opera-extension',\n        'xpi'          => 'application\/x-xpinstall',\n        'safariextz'   => 'application\/octet-stream',\n        'webapp'       => 'application\/x-web-app-manifest+json',\n        'vcf'          => 'text\/x-vcard',\n        'vtt'          => 'text\/vtt',\n        'mkv'          => 'video\/x-matroska',\n        'pkpass'       => 'application\/vnd.apple.pkpass',\n        'ajax'         => 'text\/html',\n        'bmp'          => 'image\/bmp',\n    ];\n\n    \/**\n     * Code de statut \u00e0 envoyer au client\n     *\n     * @var int\n     *\/\n    protected $_status = 200;\n\n    \/**\n     * Objet de fichier pour le fichier \u00e0 lire comme r\u00e9ponse\n     *\n     * @var SplFileInfo|null\n     *\/\n    protected $_file;\n\n    \/**\n     * Gamme de fichiers. Utilis\u00e9 pour demander des plages de fichiers.\n     *\n     * @var array<int>\n     *\/\n    protected $_fileRange = [];\n\n    \/**\n     * Le jeu de caract\u00e8res avec lequel le corps de la r\u00e9ponse est encod\u00e9\n     *\n     * @var string\n     *\/\n    protected $_charset = 'UTF-8';\n\n    \/**\n     * Contient toutes les directives de cache qui seront converties\n     * dans les en-t\u00eates lors de l'envoi de la requ\u00eate\n     *\n     * @var array\n     *\/\n    protected $_cacheDirectives = [];\n\n    \/**\n     * Collecte de cookies \u00e0 envoyer au client\n     *\n     * @var CookieCollection\n     *\/\n    protected $_cookies;\n\n    \/**\n     * Phrase de raison\n     *\n     * @var string\n     *\/\n    protected $_reasonPhrase = 'OK';\n\n    \/**\n     * Options du mode flux.\n     *\n     * @var string\n     *\/\n    protected $_streamMode = 'wb+';\n\n    \/**\n     * Cible de flux ou objet de ressource.\n     *\n     * @var resource|string\n     *\/\n    protected $_streamTarget = 'php:\/\/memory';\n\n    \/**\n     * Constructeur\n     *\n     * @param array<string, mixed> $options liste de param\u00e8tres pour configurer la r\u00e9ponse. Les valeurs possibles sont :\n     *\n     * - body : le texte de r\u00e9ponse qui doit \u00eatre envoy\u00e9 au client\n     * - status : le code d'\u00e9tat HTTP avec lequel r\u00e9pondre\n     * - type : une cha\u00eene compl\u00e8te de type mime ou une extension mapp\u00e9e dans cette classe\n     * - charset : le jeu de caract\u00e8res pour le corps de la r\u00e9ponse\n     *\n     * @throws InvalidArgumentException\n     *\/\n    public function __construct(array $options = [])\n    {\n        $this->_streamTarget = $options['streamTarget'] ?? $this->_streamTarget;\n        $this->_streamMode   = $options['streamMode'] ?? $this->_streamMode;\n\n        if (isset($options['stream'])) {\n            if (! $options['stream'] instanceof StreamInterface) {\n                throw new InvalidArgumentException('Stream option must be an object that implements StreamInterface');\n            }\n            $this->stream = $options['stream'];\n        } else {\n            $this->_createStream();\n        }\n\n        if (isset($options['body'])) {\n            $this->stream->write($options['body']);\n        }\n\n        if (isset($options['status'])) {\n            $this->_setStatus($options['status']);\n        }\n\n        if (! isset($options['charset'])) {\n            $options['charset'] = config('app.charset');\n        }\n        $this->_charset = $options['charset'];\n\n        $type = 'text\/html';\n        if (isset($options['type'])) {\n            $type = $this->resolveType($options['type']);\n        }\n        $this->_setContentType($type);\n\n        $this->_cookies = new CookieCollection();\n    }\n\n    \/**\n     * Cr\u00e9e l'objet de flux.\n     *\/\n    protected function _createStream(): void\n    {\n        $this->stream = new Stream(Utils::tryFopen($this->_streamTarget, $this->_streamMode));\n    }\n\n    \/**\n     * Formate l'en-t\u00eate Content-Type en fonction du contentType et du jeu de caract\u00e8res configur\u00e9s\n     * le jeu de caract\u00e8res ne sera d\u00e9fini dans l'en-t\u00eate que si la r\u00e9ponse est de type texte\n     *\/\n    protected function _setContentType(string $type): void\n    {\n        if (in_array($this->_status, [304, 204], true)) {\n            $this->_clearHeader('Content-Type');\n\n            return;\n        }\n        $allowed = [\n            'application\/javascript', 'application\/xml', 'application\/rss+xml',\n        ];\n\n        $charset = false;\n        if (\n            $this->_charset\n            && (\n                strpos($type, 'text\/') === 0\n                || in_array($type, $allowed, true)\n            )\n        ) {\n            $charset = true;\n        }\n\n        if ($charset && strpos($type, ';') === false) {\n            $this->_setHeader('Content-Type', \"{$type}; charset={$this->_charset}\");\n        } else {\n            $this->_setHeader('Content-Type', $type);\n        }\n    }\n\n    \/**\n     * Effectuez une redirection vers une nouvelle URL, en deux versions : en-t\u00eate ou emplacement.\n     *\n     * @param string $uri  L'URI vers laquelle rediriger\n     * @param int    $code Le type de redirection, par d\u00e9faut \u00e0 302\n     *\n     * @throws HttpException Pour un code d'\u00e9tat invalide.\n     *\/\n    public function redirect(string $uri, string $method = 'auto', ?int $code = null): self\n    {\n        \/\/ Suppose une r\u00e9ponse de code d'\u00e9tat 302 ; remplacer si n\u00e9cessaire\n        if (empty($code)) {\n            $code = StatusCode::FOUND;\n        }\n\n        \/\/ Environnement IIS probable ? Utilisez 'refresh' pour une meilleure compatibilit\u00e9\n        if ($method === 'auto' && isset($_SERVER['SERVER_SOFTWARE']) && strpos($_SERVER['SERVER_SOFTWARE'], 'Microsoft-IIS') !== false) {\n            $method = 'refresh';\n        }\n\n        \/\/ remplace le code d'\u00e9tat pour HTTP\/1.1 et sup\u00e9rieur\n        \/\/ reference: http:\/\/en.wikipedia.org\/wiki\/Post\/Redirect\/Get\n        if (isset($_SERVER['SERVER_PROTOCOL'], $_SERVER['REQUEST_METHOD']) && $this->getProtocolVersion() >= 1.1 && $method !== 'refresh') {\n            $code = ($_SERVER['REQUEST_METHOD'] !== 'GET') ? StatusCode::SEE_OTHER : ($code === StatusCode::FOUND ? StatusCode::TEMPORARY_REDIRECT : $code);\n        }\n\n        $new = $method === 'refresh'\n            ? $this->withHeader('Refresh', '0;url=' . $uri)\n            : $this->withLocation($uri);\n\n        return $new->withStatus($code);\n    }\n\n    \/**\n     * Renvoie une instance avec un en-t\u00eate d'emplacement mis \u00e0 jour.\n     *\n     * Si le code d'\u00e9tat actuel est 200, il sera remplac\u00e9\n     * avec 302.\n     *\n     * @param string $url L'emplacement vers lequel rediriger.\n     *\n     * @return static Une nouvelle r\u00e9ponse avec l'en-t\u00eate Location d\u00e9fini.\n     *\/\n    public function withLocation(string $url): static\n    {\n        $new = $this->withHeader('Location', $url);\n        if ($new->_status === StatusCode::OK) {\n            $new->_status = StatusCode::FOUND;\n        }\n\n        return $new;\n    }\n\n    \/**\n     * D\u00e9finit un en-t\u00eate.\n     *\n     * @phpstan-param non-empty-string $header\n     *\/\n    protected function _setHeader(string $header, string $value): void\n    {\n        $normalized                     = strtolower($header);\n        $this->headerNames[$normalized] = $header;\n        $this->headers[$header]         = [$value];\n    }\n\n    \/**\n     * Effacer l'en-t\u00eate\n     *\n     * @phpstan-param non-empty-string $header\n     *\/\n    protected function _clearHeader(string $header): void\n    {\n        $normalized = strtolower($header);\n        if (! isset($this->headerNames[$normalized])) {\n            return;\n        }\n        $original = $this->headerNames[$normalized];\n        unset($this->headerNames[$normalized], $this->headers[$original]);\n    }\n\n    \/**\n     * Obtient le code d'\u00e9tat de la r\u00e9ponse.\n     *\n     * Le code d'\u00e9tat est un code de r\u00e9sultat entier \u00e0 3 chiffres de la tentative du serveur\n     * pour comprendre et satisfaire la demande.\n     *\/\n    public function getStatusCode(): int\n    {\n        return $this->_status;\n    }\n\n    \/**\n     * Renvoie une instance avec le code d'\u00e9tat sp\u00e9cifi\u00e9 et, \u00e9ventuellement, la phrase de raison.\n     *\n     * Si aucune expression de raison n'est sp\u00e9cifi\u00e9e, les impl\u00e9mentations PEUVENT choisir par d\u00e9faut\n     * \u00e0 la RFC 7231 ou \u00e0 l'expression de raison recommand\u00e9e par l'IANA pour la r\u00e9ponse\n     * code d'\u00e9tat.\n     *\n     * Cette m\u00e9thode DOIT \u00eatre mise en \u0153uvre de mani\u00e8re \u00e0 conserver la\n     * immuabilit\u00e9 du message, et DOIT retourner une instance qui a le\n     * \u00e9tat mis \u00e0 jour et expression de raison.\n     *\n     * Si le code d'\u00e9tat est 304 ou 204, l'en-t\u00eate Content-Type existant\n     * sera effac\u00e9, car ces codes de r\u00e9ponse n'ont pas de corps.\n     *\n     * Il existe des packages externes tels que `fig\/http-message-util` qui fournissent HTTP\n     * constantes de code d'\u00e9tat. Ceux-ci peuvent \u00eatre utilis\u00e9s avec n'importe quelle m\u00e9thode qui accepte ou\n     * renvoie un entier de code d'\u00e9tat. Cependant, gardez \u00e0 l'esprit que ces constantes\n     * peut inclure des codes d'\u00e9tat qui sont maintenant autoris\u00e9s, ce qui lancera un\n     * `\\InvalidArgumentException`.\n     *\n     * @see https:\/\/tools.ietf.org\/html\/rfc7231#section-6\n     * @see https:\/\/www.iana.org\/assignments\/http-status-codes\/http-status-codes.xhtml\n     *\n     * @param int    $code         Le code d'\u00e9tat entier \u00e0 3 chiffres \u00e0 d\u00e9finir.\n     * @param string $reasonPhrase La phrase de raison \u00e0 utiliser avec le\n     *                             code d'\u00e9tat fourni ; si aucun n'est fourni, les impl\u00e9mentations PEUVENT\n     *                             utilisez les valeurs par d\u00e9faut comme sugg\u00e9r\u00e9 dans la sp\u00e9cification HTTP.\n     *\n     * @throws HttpException Pour les arguments de code d'\u00e9tat non valides.\n     *\/\n    public function withStatus($code, $reasonPhrase = ''): static\n    {\n        $new = clone $this;\n        $new->_setStatus($code, $reasonPhrase);\n\n        return $new;\n    }\n\n    \/**\n     * Modificateur pour l'\u00e9tat de la r\u00e9ponse\n     *\n     * @throws HttpException Pour les arguments de code d'\u00e9tat non valides.\n     *\/\n    protected function _setStatus(int $code, string $reasonPhrase = ''): void\n    {\n        if ($code < static::STATUS_CODE_MIN || $code > static::STATUS_CODE_MAX) {\n            throw HttpException::invalidStatusCode($code);\n        }\n\n        $this->_status = $code;\n        if ($reasonPhrase === '' && isset($this->_statusCodes[$code])) {\n            $reasonPhrase = $this->_statusCodes[$code];\n        }\n        $this->_reasonPhrase = $reasonPhrase;\n\n        \/\/ Ces codes d'\u00e9tat n'ont pas de corps et ne peuvent pas avoir de types de contenu.\n        if (in_array($code, [304, 204], true)) {\n            $this->_clearHeader('Content-Type');\n        }\n    }\n\n    \/**\n     * Obtient la phrase de motif de r\u00e9ponse associ\u00e9e au code d'\u00e9tat.\n     *\n     * Parce qu'une phrase de raison n'est pas un \u00e9l\u00e9ment obligatoire dans une r\u00e9ponse\n     * ligne d'\u00e9tat, la valeur de la phrase de raison PEUT \u00eatre nulle. Impl\u00e9mentations MAI\n     * choisissez de renvoyer la phrase de raison recommand\u00e9e par d\u00e9faut RFC 7231 (ou celles\n     * r\u00e9pertori\u00e9 dans le registre des codes d'\u00e9tat HTTP IANA) pour la r\u00e9ponse\n     * code d'\u00e9tat.\n     *\n     * @see https:\/\/tools.ietf.org\/html\/rfc7231#section-6\n     * @see http:\/\/www.iana.org\/assignments\/http-status-codes\/http-status-codes.xhtml\n     *\/\n    public function getReasonPhrase(): string\n    {\n        return $this->_reasonPhrase;\n    }\n\n    \/**\n     * D\u00e9finit une d\u00e9finition de type de contenu dans la collection.\n     *\n     * Ex : setTypeMap('xhtml', ['application\/xhtml+xml', 'application\/xhtml'])\n     *\n     * Ceci est n\u00e9cessaire pour RequestHandlerComponent et la reconnaissance des types.\n     *\n     * @param string          $type     Type de contenu.\n     * @param string|string[] $mimeType D\u00e9finition du type mime.\n     *\/\n    public function setTypeMap(string $type, $mimeType): void\n    {\n        $this->_mimeTypes[$type] = $mimeType;\n    }\n\n    \/**\n     * Renvoie le type de contenu actuel.\n     *\/\n    public function getType(): string\n    {\n        $header = $this->getHeaderLine('Content-Type');\n        if (strpos($header, ';') !== false) {\n            return explode(';', $header)[0];\n        }\n\n        return $header;\n    }\n\n    \/**\n     * Obtenez une r\u00e9ponse mise \u00e0 jour avec le type de contenu d\u00e9fini.\n     *\n     * Si vous tentez de d\u00e9finir le type sur une r\u00e9ponse de code d'\u00e9tat 304 ou 204, le\n     * Le type de contenu ne prendra pas effet car ces codes d'\u00e9tat n'ont pas de types de contenu.\n     *\n     * @param string $contentType Soit une extension de fichier qui sera mapp\u00e9e \u00e0 un type MIME, soit un type MIME concret.\n     *\/\n    public function withType(string $contentType): static\n    {\n        $mappedType = $this->resolveType($contentType);\n        $new        = clone $this;\n        $new->_setContentType($mappedType);\n\n        return $new;\n    }\n\n    \/**\n     * Traduire et valider les types de contenu.\n     *\n     * @param string $contentType Type de contenu ou alias de type.\n     *\n     * @throws InvalidArgumentException Lorsqu'un type de contenu ou un alias non valide est utilis\u00e9.\n     *\n     * @return string Le type de contenu r\u00e9solu\n     *\/\n    protected function resolveType(string $contentType): string\n    {\n        $mapped = $this->getMimeType($contentType);\n        if ($mapped) {\n            return is_array($mapped) ? current($mapped) : $mapped;\n        }\n        if (strpos($contentType, '\/') === false) {\n            throw new InvalidArgumentException(sprintf('\"%s\" is an invalid content type.', $contentType));\n        }\n\n        return $contentType;\n    }\n\n    \/**\n     * Renvoie la d\u00e9finition du type mime pour un alias\n     *\n     * par exemple `getMimeType('pdf'); \/\/ renvoie 'application\/pdf'`\n     *\n     * @param string $alias l'alias du type de contenu \u00e0 mapper\n     *\n     * @return array|false|string Type mime mapp\u00e9 en cha\u00eene ou false si $alias n'est pas mapp\u00e9\n     *\/\n    public function getMimeType(string $alias)\n    {\n        return $this->_mimeTypes[$alias] ?? false;\n    }\n\n    \/**\n     * Mappe un type de contenu vers un alias\n     *\n     * par exemple `mapType('application\/pdf'); \/\/ renvoie 'pdf'`\n     *\n     * @param array|string $ctype Soit un type de contenu de cha\u00eene \u00e0 mapper, soit un tableau de types.\n     *\n     * @return array|string|null Alias pour les types fournis.\n     *\/\n    public function mapType($ctype)\n    {\n        if (is_array($ctype)) {\n            return array_map([$this, 'mapType'], $ctype);\n        }\n\n        foreach ($this->_mimeTypes as $alias => $types) {\n            if (in_array($ctype, (array) $types, true)) {\n                return $alias;\n            }\n        }\n\n        return null;\n    }\n\n    \/**\n     * Renvoie le jeu de caract\u00e8res actuel.\n     *\/\n    public function getCharset(): string\n    {\n        return $this->_charset;\n    }\n\n    \/**\n     * Obtenez une nouvelle instance avec un jeu de caract\u00e8res mis \u00e0 jour.\n     *\/\n    public function withCharset(string $charset): static\n    {\n        $new           = clone $this;\n        $new->_charset = $charset;\n        $new->_setContentType($this->getType());\n\n        return $new;\n    }\n\n    \/**\n     * Cr\u00e9ez une nouvelle instance avec des en-t\u00eates pour indiquer au client de ne pas mettre en cache la r\u00e9ponse\n     *\/\n    public function withDisabledCache(): static\n    {\n        return $this->withHeader('Expires', 'Mon, 26 Jul 1997 05:00:00 GMT')\n            ->withHeader('Last-Modified', gmdate(DATE_RFC7231))\n            ->withHeader('Cache-Control', 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0');\n    }\n\n    \/**\n     * Cr\u00e9ez une nouvelle instance avec les en-t\u00eates pour activer la mise en cache du client.\n     *\n     * @param int|string $since un temps valide depuis que le texte de la r\u00e9ponse n'a pas \u00e9t\u00e9 modifi\u00e9\n     * @param int|string $time  une heure valide pour l'expiration du cache\n     *\/\n    public function withCache($since, $time = '+1 day'): static\n    {\n        if (! is_int($time)) {\n            $time = strtotime($time);\n            if ($time === false) {\n                throw new InvalidArgumentException(\n                    'Invalid time parameter. Ensure your time value can be parsed by strtotime'\n                );\n            }\n        }\n\n        return $this\n            ->withModified($since)\n            ->withExpires($time)\n            ->withSharable(true)\n            ->withMaxAge($time - time())\n            ->withHeader('Date', gmdate(DATE_RFC7231, time()));\n    }\n\n    \/**\n     * Cr\u00e9ez une nouvelle instance avec le jeu de directives public\/priv\u00e9 Cache-Control.\n     *\n     * @param bool     $public Si d\u00e9fini sur true, l'en-t\u00eate Cache-Control sera d\u00e9fini comme public\n     *                         si d\u00e9fini sur false, la r\u00e9ponse sera d\u00e9finie sur priv\u00e9.\n     * @param int|null $time   temps en secondes apr\u00e8s lequel la r\u00e9ponse ne doit plus \u00eatre consid\u00e9r\u00e9e comme fra\u00eeche.\n     *\/\n    public function withSharable(bool $public, ?int $time = null): static\n    {\n        $new = clone $this;\n        unset($new->_cacheDirectives['private'], $new->_cacheDirectives['public']);\n\n        $key                         = $public ? 'public' : 'private';\n        $new->_cacheDirectives[$key] = true;\n\n        if ($time !== null) {\n            $new->_cacheDirectives['max-age'] = $time;\n        }\n        $new->_setCacheControl();\n\n        return $new;\n    }\n\n    \/**\n     * Cr\u00e9ez une nouvelle instance avec la directive Cache-Control s-maxage.\n     *\n     * Le max-age est le nombre de secondes apr\u00e8s lesquelles la r\u00e9ponse ne doit plus \u00eatre prise en compte\n     * un bon candidat pour \u00eatre extrait d'un cache partag\u00e9 (comme dans un serveur proxy).\n     *\n     * @param int $seconds Le nombre de secondes pour max-age partag\u00e9\n     *\/\n    public function withSharedMaxAge(int $seconds): static\n    {\n        $new                               = clone $this;\n        $new->_cacheDirectives['s-maxage'] = $seconds;\n        $new->_setCacheControl();\n\n        return $new;\n    }\n\n    \/**\n     * Cr\u00e9ez une instance avec l'ensemble de directives Cache-Control max-age.\n     *\n     * Le max-age est le nombre de secondes apr\u00e8s lesquelles la r\u00e9ponse ne doit plus \u00eatre prise en compte\n     * un bon candidat \u00e0 r\u00e9cup\u00e9rer dans le cache local (client).\n     *\n     * @param int $seconds Les secondes pendant lesquelles une r\u00e9ponse mise en cache peut \u00eatre consid\u00e9r\u00e9e comme valide\n     *\/\n    public function withMaxAge(int $seconds): static\n    {\n        $new                              = clone $this;\n        $new->_cacheDirectives['max-age'] = $seconds;\n        $new->_setCacheControl();\n\n        return $new;\n    }\n\n    \/**\n     * Cr\u00e9ez une instance avec le jeu de directives must-revalidate de Cache-Control.\n     *\n     * D\u00e9finit la directive Cache-Control must-revalidate.\n     * must-revalidate indique que la r\u00e9ponse ne doit pas \u00eatre servie\n     * obsol\u00e8te par un cache en toutes circonstances sans revalidation pr\u00e9alable\n     * avec l'origine.\n     *\n     * @param bool $enable active ou d\u00e9sactive la directive.\n     *\/\n    public function withMustRevalidate(bool $enable): static\n    {\n        $new = clone $this;\n        if ($enable) {\n            $new->_cacheDirectives['must-revalidate'] = true;\n        } else {\n            unset($new->_cacheDirectives['must-revalidate']);\n        }\n        $new->_setCacheControl();\n\n        return $new;\n    }\n\n    \/**\n     * M\u00e9thode d'assistance pour g\u00e9n\u00e9rer un en-t\u00eate Cache-Control valide \u00e0 partir du jeu d'options\n     * dans d'autres m\u00e9thodes\n     *\/\n    protected function _setCacheControl(): void\n    {\n        $control = '';\n\n        foreach ($this->_cacheDirectives as $key => $val) {\n            $control .= $val === true ? $key : sprintf('%s=%s', $key, $val);\n            $control .= ', ';\n        }\n        $control = rtrim($control, ', ');\n        $this->_setHeader('Cache-Control', $control);\n    }\n\n    \/**\n     * Cr\u00e9ez une nouvelle instance avec l'ensemble d'en-t\u00eate Expires.\n     *\n     * ### Exemples:\n     *\n     * ```\n     * \/\/ Va expirer le cache de r\u00e9ponse maintenant\n     * $response->withExpires('maintenant')\n     *\n     * \/\/ D\u00e9finira l'expiration dans les prochaines 24 heures\n     * $response->withExpires(new DateTime('+1 jour'))\n     * ```\n     *\n     * @param DateTimeInterface|int|string|null $time Cha\u00eene d'heure valide ou instance de \\DateTime.\n     *\/\n    public function withExpires($time): static\n    {\n        $date = $this->_getUTCDate($time);\n\n        return $this->withHeader('Expires', $date->format(DATE_RFC7231));\n    }\n\n    \/**\n     * Cr\u00e9ez une nouvelle instance avec le jeu d'en-t\u00eate Last-Modified.\n     *\n     * ### Exemples:\n     *\n     * ```\n     * \/\/ Va expirer le cache de r\u00e9ponse maintenant\n     * $response->withModified('now')\n     *\n     * \/\/ D\u00e9finira l'expiration dans les prochaines 24 heures\n     * $response->withModified(new DateTime('+1 jour'))\n     * ```\n     *\n     * @param DateTimeInterface|int|string $time Cha\u00eene d'heure valide ou instance de \\DateTime.\n     *\/\n    public function withModified($time): static\n    {\n        $date = $this->_getUTCDate($time);\n\n        return $this->withHeader('Last-Modified', $date->format(DATE_RFC7231));\n    }\n\n    \/**\n     * D\u00e9finit la r\u00e9ponse comme non modifi\u00e9e en supprimant tout contenu du corps\n     * d\u00e9finir le code d'\u00e9tat sur \"304 Non modifi\u00e9\" et supprimer tous\n     * en-t\u00eates contradictoires\n     *\n     * *Avertissement* Cette m\u00e9thode modifie la r\u00e9ponse sur place et doit \u00eatre \u00e9vit\u00e9e.\n     *\/\n    public function notModified(): void\n    {\n        $this->_createStream();\n        $this->_setStatus(StatusCode::NOT_MODIFIED);\n\n        $remove = [\n            'Allow',\n            'Content-Encoding',\n            'Content-Language',\n            'Content-Length',\n            'Content-MD5',\n            'Content-Type',\n            'Last-Modified',\n        ];\n\n        foreach ($remove as $header) {\n            $this->_clearHeader($header);\n        }\n    }\n\n    \/**\n     * Cr\u00e9er une nouvelle instance comme \"non modifi\u00e9e\"\n     *\n     * Cela supprimera tout contenu du corps d\u00e9fini le code d'\u00e9tat\n     * \u00e0 \"304\" et en supprimant les en-t\u00eates qui d\u00e9crivent\n     * un corps de r\u00e9ponse.\n     *\/\n    public function withNotModified(): static\n    {\n        $new = $this->withStatus(StatusCode::NOT_MODIFIED);\n        $new->_createStream();\n        $remove = [\n            'Allow',\n            'Content-Encoding',\n            'Content-Language',\n            'Content-Length',\n            'Content-MD5',\n            'Content-Type',\n            'Last-Modified',\n        ];\n\n        foreach ($remove as $header) {\n            $new = $new->withoutHeader($header);\n        }\n\n        return $new;\n    }\n\n    \/**\n     * Cr\u00e9ez une nouvelle instance avec l'ensemble d'en-t\u00eate Vary.\n     *\n     * Si un tableau est pass\u00e9, les valeurs seront implos\u00e9es dans une virgule\n     * cha\u00eene s\u00e9par\u00e9e. Si aucun param\u00e8tre n'est pass\u00e9, alors un\n     * le tableau avec la valeur actuelle de l'en-t\u00eate Vary est renvoy\u00e9\n     *\n     * @param string|string[] $cacheVariances Une seule cha\u00eene Vary ou un tableau contenant la liste des \u00e9carts.\n     *\/\n    public function withVary($cacheVariances): static\n    {\n        return $this->withHeader('Vary', (array) $cacheVariances);\n    }\n\n    \/**\n     * Cr\u00e9ez une nouvelle instance avec l'ensemble d'en-t\u00eate Etag.\n     *\n     * Les Etags sont une indication forte qu'une r\u00e9ponse peut \u00eatre mise en cache par un\n     * Client HTTP. Une mauvaise fa\u00e7on de g\u00e9n\u00e9rer des Etags est de cr\u00e9er un hachage de\n     * la sortie de la r\u00e9ponse, g\u00e9n\u00e8re \u00e0 la place un hachage unique du\n     * composants uniques qui identifient une demande, comme un\n     * l'heure de modification, un identifiant de ressource et tout ce que vous consid\u00e9rez\n     * qui rend la r\u00e9ponse unique.\n     *\n     * Le deuxi\u00e8me param\u00e8tre est utilis\u00e9 pour informer les clients que le contenu a\n     * modifi\u00e9, mais s\u00e9mantiquement, il est \u00e9quivalent aux valeurs mises en cache existantes. Envisager\n     * une page avec un compteur de visites, deux pages vues diff\u00e9rentes sont \u00e9quivalentes, mais\n     * ils diff\u00e8rent de quelques octets. Cela permet au client de d\u00e9cider s'il doit\n     * utiliser les donn\u00e9es mises en cache.\n     *\n     * @param string $hash Le hachage unique qui identifie cette r\u00e9ponse\n     * @param bool   $weak Si la r\u00e9ponse est s\u00e9mantiquement la m\u00eame que\n     *                     autre avec le m\u00eame hash ou non. La valeur par d\u00e9faut est false\n     *\/\n    public function withEtag(string $hash, bool $weak = false): static\n    {\n        $hash = sprintf('%s\"%s\"', $weak ? 'W\/' : '', $hash);\n\n        return $this->withHeader('Etag', $hash);\n    }\n\n    \/**\n     * Renvoie un objet DateTime initialis\u00e9 au param\u00e8tre $time et utilisant UTC\n     * comme fuseau horaire\n     *\n     * @param DateTimeInterface|int|string|null $time Cha\u00eene d'heure valide ou instance de \\DateTimeInterface.\n     *\/\n    protected function _getUTCDate($time = null): DateTimeInterface\n    {\n        if ($time instanceof DateTimeInterface) {\n            $result = clone $time;\n        } elseif (is_int($time)) {\n            $result = new DateTime(date('Y-m-d H:i:s', $time));\n        } else {\n            $result = new DateTime($time ?? 'now');\n        }\n\n        \/** @psalm-suppress UndefinedInterfaceMethod *\/\n        return $result->setTimezone(new DateTimeZone('UTC')); \/\/ @phpstan-ignore-line\n    }\n\n    \/**\n     * D\u00e9finit le bon gestionnaire de mise en m\u00e9moire tampon de sortie pour envoyer une r\u00e9ponse compress\u00e9e.\n     * Les r\u00e9ponses seront compress\u00e9 avec zlib, si l'extension est disponible.\n     *\n     * @return bool false si le client n'accepte pas les r\u00e9ponses compress\u00e9es ou si aucun gestionnaire n'est disponible, true sinon\n     *\/\n    public function compress(): bool\n    {\n        $compressionEnabled = ini_get('zlib.output_compression') !== '1'\n            && extension_loaded('zlib')\n            && (strpos((string) env('HTTP_ACCEPT_ENCODING'), 'gzip') !== false);\n\n        return $compressionEnabled && ob_start('ob_gzhandler');\n    }\n\n    \/**\n     * Retourne VRAI si la sortie r\u00e9sultante sera compress\u00e9e par PHP\n     *\/\n    public function outputCompressed(): bool\n    {\n        return strpos((string) env('HTTP_ACCEPT_ENCODING'), 'gzip') !== false\n            && (ini_get('zlib.output_compression') === '1' || in_array('ob_gzhandler', ob_list_handlers(), true));\n    }\n\n    \/**\n     * Cr\u00e9ez une nouvelle instance avec l'ensemble d'en-t\u00eate Content-Disposition.\n     *\n     * @param string $filename Le nom du fichier car le navigateur t\u00e9l\u00e9chargera la r\u00e9ponse\n     *\/\n    public function withDownload(string $filename): static\n    {\n        return $this->withHeader('Content-Disposition', 'attachment; filename=\"' . $filename . '\"');\n    }\n\n    \/**\n     * Cr\u00e9ez une nouvelle r\u00e9ponse avec l'ensemble d'en-t\u00eate Content-Length.\n     *\n     * @param int|string $bytes Nombre d'octets\n     *\/\n    public function withLength($bytes): static\n    {\n        return $this->withHeader('Content-Length', (string) $bytes);\n    }\n\n    \/**\n     * Cr\u00e9ez une nouvelle r\u00e9ponse avec l'ensemble d'en-t\u00eate de lien.\n     *\n     * ### Exemples\n     *\n     * ```\n     * $response = $response->withAddedLink('http:\/\/example.com?page=1', ['rel' => 'prev'])\n     * ->withAddedLink('http:\/\/example.com?page=3', ['rel' => 'next']);\n     * ```\n     *\n     * G\u00e9n\u00e9rera :\n     *\n     * ```\n     * Link : <http:\/\/example.com?page=1> ; rel=\"prev\"\n     * Link : <http:\/\/example.com?page=3> ; rel=\"suivant\"\n     * ```\n     *\n     * @param string               $url     L'URL LinkHeader.\n     * @param array<string, mixed> $options Les param\u00e8tres LinkHeader.\n     *\/\n    public function withAddedLink(string $url, array $options = []): static\n    {\n        $params = [];\n\n        foreach ($options as $key => $option) {\n            $params[] = $key . '=\"' . $option . '\"';\n        }\n\n        $param = '';\n        if ($params) {\n            $param = '; ' . implode('; ', $params);\n        }\n\n        return $this->withAddedHeader('Link', '<' . $url . '>' . $param);\n    }\n\n    \/**\n     * V\u00e9rifie si une r\u00e9ponse n'a pas \u00e9t\u00e9 modifi\u00e9e selon le 'If-None-Match'\n     * (Etags) et requ\u00eate 'If-Modified-Since' (derni\u00e8re modification)\n     * en-t\u00eates. Si la r\u00e9ponse est d\u00e9tect\u00e9e comme n'\u00e9tant pas modifi\u00e9e, elle\n     * est marqu\u00e9 comme tel afin que le client puisse en \u00eatre inform\u00e9.\n     *\n     * Pour marquer une r\u00e9ponse comme non modifi\u00e9e, vous devez d\u00e9finir au moins\n     * l'en-t\u00eate de r\u00e9ponse etag Last-Modified avant d'appeler cette m\u00e9thode. Autrement\n     * une comparaison ne sera pas possible.\n     *\n     * *Avertissement* Cette m\u00e9thode modifie la r\u00e9ponse sur place et doit \u00eatre \u00e9vit\u00e9e.\n     *\n     * @param ServerRequest $request Objet de requ\u00eate\n     *\n     * @return bool Indique si la r\u00e9ponse a \u00e9t\u00e9 marqu\u00e9e comme non modifi\u00e9e ou non.\n     *\/\n    public function checkNotModified(ServerRequest $request): bool\n    {\n        $etags       = preg_split('\/\\s*,\\s*\/', $request->getHeaderLine('If-None-Match'), 0, PREG_SPLIT_NO_EMPTY);\n        $responseTag = $this->getHeaderLine('Etag');\n        $etagMatches = null;\n        if ($responseTag) {\n            $etagMatches = in_array('*', $etags, true) || in_array($responseTag, $etags, true);\n        }\n\n        $modifiedSince = $request->getHeaderLine('If-Modified-Since');\n        $timeMatches   = null;\n        if ($modifiedSince && $this->hasHeader('Last-Modified')) {\n            $timeMatches = strtotime($this->getHeaderLine('Last-Modified')) === strtotime($modifiedSince);\n        }\n        if ($etagMatches === null && $timeMatches === null) {\n            return false;\n        }\n        $notModified = $etagMatches !== false && $timeMatches !== false;\n        if ($notModified) {\n            $this->notModified();\n        }\n\n        return $notModified;\n    }\n\n    \/**\n     * Conversion de cha\u00eenes. R\u00e9cup\u00e8re le corps de la r\u00e9ponse sous forme de cha\u00eene.\n     * N'envoie *pas* d'en-t\u00eates.\n     * Si body est un appelable, une cha\u00eene vide est renvoy\u00e9e.\n     *\/\n    public function __toString(): string\n    {\n        $this->stream->rewind();\n\n        return $this->stream->getContents();\n    }\n\n    \/**\n     * Cr\u00e9ez une nouvelle r\u00e9ponse avec un jeu de cookies.\n     *\n     * ### Exemple\n     *\n     * ```\n     * \/\/ ajouter un objet cookie\n     * $response = $response->withCookie(new Cookie('remember_me', 1));\n     *\/\n    public function withCookie(CookieInterface $cookie): static\n    {\n        $new           = clone $this;\n        $new->_cookies = $new->_cookies->add($cookie);\n\n        return $new;\n    }\n\n    \/**\n     * Cr\u00e9ez une nouvelle r\u00e9ponse avec un jeu de cookies expir\u00e9.\n     *\n     * ### Exemple\n     *\n     * ```\n     * \/\/ ajouter un objet cookie\n     * $response = $response->withExpiredCookie(new Cookie('remember_me'));\n     *\/\n    public function withExpiredCookie(CookieInterface $cookie): static\n    {\n        $cookie = $cookie->withExpired();\n\n        $new           = clone $this;\n        $new->_cookies = $new->_cookies->add($cookie);\n\n        return $new;\n    }\n\n    \/**\n     * Lire un seul cookie \u00e0 partir de la r\u00e9ponse.\n     *\n     * Cette m\u00e9thode fournit un acc\u00e8s en lecture aux cookies en attente. Ce sera\n     * ne lit pas l'en-t\u00eate `Set-Cookie` s'il est d\u00e9fini.\n     *\n     * @param string $name Le nom du cookie que vous souhaitez lire.\n     *\n     * @return array|null Soit les donn\u00e9es du cookie, soit null\n     *\/\n    public function getCookie(string $name): ?array\n    {\n        if (! $this->_cookies->has($name)) {\n            return null;\n        }\n\n        return $this->_cookies->get($name)->toArray();\n    }\n\n    \/**\n     * Obtenez tous les cookies dans la r\u00e9ponse.\n     *\n     * Renvoie un tableau associatif de nom de cookie => donn\u00e9es de cookie.\n     *\/\n    public function getCookies(): array\n    {\n        $out = [];\n        \/** @var array<\\BlitzPHP\\Http\\Cookie\\Cookie> $cookies *\/\n        $cookies = $this->_cookies;\n\n        foreach ($cookies as $cookie) {\n            $out[$cookie->getName()] = $cookie->toArray();\n        }\n\n        return $out;\n    }\n\n    \/**\n     * Obtenez la CookieCollection \u00e0 partir de la r\u00e9ponse\n     *\/\n    public function getCookieCollection(): CookieCollection\n    {\n        return $this->_cookies;\n    }\n\n    \/**\n     * Obtenez une nouvelle instance avec la collection de cookies fournie.\n     *\/\n    public function withCookieCollection(CookieCollection $cookieCollection): static\n    {\n        $new           = clone $this;\n        $new->_cookies = $cookieCollection;\n\n        return $new;\n    }\n\n    \/**\n     * Cr\u00e9ez une nouvelle instance bas\u00e9e sur un fichier.\n     *\n     * Cette m\u00e9thode augmentera \u00e0 la fois le corps et un certain nombre d'en-t\u00eates associ\u00e9s.\n     *\n     * Si `$_SERVER['HTTP_RANGE']` est d\u00e9fini, une tranche du fichier sera\n     * retourn\u00e9 au lieu du fichier entier.\n     *\n     * ### Touches d'options\n     *\n     * - nom : autre nom de t\u00e9l\u00e9chargement\n     * - download : si `true` d\u00e9finit l'en-t\u00eate de t\u00e9l\u00e9chargement et force le fichier \u00e0\n     * \u00eatre t\u00e9l\u00e9charg\u00e9 plut\u00f4t qu'affich\u00e9 en ligne.\n     *\n     * @param string               $path    Chemin d'acc\u00e8s absolu au fichier.\n     * @param array<string, mixed> $options Options Voir ci-dessus.\n     *\n     * @throws LoadException\n     *\/\n    public function withFile(string $path, array $options = []): static\n    {\n        $file = $this->validateFile($path);\n        $options += [\n            'name'     => null,\n            'download' => null,\n        ];\n\n        $extension = strtolower($file->getExtension());\n        $mapped    = $this->getMimeType($extension);\n        if ((! $extension || ! $mapped) && $options['download'] === null) {\n            $options['download'] = true;\n        }\n\n        $new = clone $this;\n        if ($mapped) {\n            $new = $new->withType($extension);\n        }\n\n        $fileSize = $file->getSize();\n        if ($options['download']) {\n            $agent = (string) env('HTTP_USER_AGENT');\n\n            if ($agent && preg_match('%Opera([\/ ])([0-9].[0-9]{1,2})%', $agent)) {\n                $contentType = 'application\/octet-stream';\n            } elseif ($agent && preg_match('\/MSIE ([0-9].[0-9]{1,2})\/', $agent)) {\n                $contentType = 'application\/force-download';\n            }\n\n            if (isset($contentType)) {\n                $new = $new->withType($contentType);\n            }\n            $name = $options['name'] ?: $file->getFileName();\n            $new  = $new->withDownload($name)\n                ->withHeader('Content-Transfer-Encoding', 'binary');\n        }\n\n        $new       = $new->withHeader('Accept-Ranges', 'bytes');\n        $httpRange = (string) env('HTTP_RANGE');\n        if ($httpRange) {\n            $new->_fileRange($file, $httpRange);\n        } else {\n            $new = $new->withHeader('Content-Length', (string) $fileSize);\n        }\n        $new->_file  = $file;\n        $new->stream = new Stream(Utils::tryFopen($file->getPathname(), 'rb'));\n\n        return $new;\n    }\n\n    \/**\n     * M\u00e9thode pratique pour d\u00e9finir une cha\u00eene dans le corps de la r\u00e9ponse\n     *\n     * @param string|null $string La cha\u00eene \u00e0 envoyer\n     *\/\n    public function withStringBody(?string $string): static\n    {\n        $new = clone $this;\n        $new->_createStream();\n        $new->stream->write((string) $string);\n\n        return $new;\n    }\n\n    \/**\n     * Valider qu'un chemin de fichier est un corps de r\u00e9ponse valide.\n     *\n     * @throws LoadException\n     *\/\n    protected function validateFile(string $path): SplFileInfo\n    {\n        if (strpos($path, '..\/') !== false || strpos($path, '..\\\\') !== false) {\n            throw new LoadException('The requested file contains `..` and will not be read.');\n        }\n        if (! is_file($path)) {\n            $path = APP_PATH . $path;  \/\/ @phpstan-ignore-line\n        }\n\n        $file = new SplFileInfo($path);\n        if (! $file->isFile() || ! $file->isReadable()) {\n            if (on_dev()) {\n                throw new LoadException(sprintf('The requested file %s was not found or not readable', $path));\n            }\n\n            throw new LoadException('The requested file was not found');\n        }\n\n        return $file;\n    }\n\n    \/**\n     * Obtenir le fichier actuel s'il en existe un.\n     *\n     * @return SplFileInfo|null Le fichier \u00e0 utiliser dans la r\u00e9ponse ou null\n     *\/\n    public function getFile(): ?SplFileInfo\n    {\n        return $this->_file;\n    }\n\n    \/**\n     * Appliquez une plage de fichiers \u00e0 un fichier et d\u00e9finissez le d\u00e9calage de fin.\n     *\n     * Si une plage non valide est demand\u00e9e, un code d'\u00e9tat 416 sera utilis\u00e9\n     * dans la r\u00e9ponse.\n     *\n     * @param SplFileInfo $file      Le fichier sur lequel d\u00e9finir une plage.\n     * @param string      $httpRange La plage \u00e0 utiliser.\n     *\/\n    protected function _fileRange(SplFileInfo $file, string $httpRange): void\n    {\n        $fileSize = $file->getSize();\n        $lastByte = $fileSize - 1;\n        $start    = 0;\n        $end      = $lastByte;\n\n        preg_match('\/^bytes\\s*=\\s*(\\d+)?\\s*-\\s*(\\d+)?$\/', $httpRange, $matches);\n        if ($matches) {\n            $start = $matches[1];\n            $end   = $matches[2] ?? '';\n        }\n\n        if ($start === '') {\n            $start = $fileSize - (int) $end;\n            $end   = $lastByte;\n        }\n        if ($end === '') {\n            $end = $lastByte;\n        }\n\n        if ($start > $end || $end > $lastByte || $start > $lastByte) {\n            $this->_setStatus(416);\n            $this->_setHeader('Content-Range', 'bytes 0-' . $lastByte . '\/' . $fileSize);\n\n            return;\n        }\n\n        \/** @psalm-suppress PossiblyInvalidOperand *\/\n        $this->_setHeader('Content-Length', (string) ($end - $start + 1));\n        $this->_setHeader('Content-Range', 'bytes ' . $start . '-' . $end . '\/' . $fileSize);\n        $this->_setStatus(206);\n        \/**\n         * @var int $start\n         * @var int $end\n         *\/\n        $this->_fileRange = [$start, $end];\n    }\n\n    \/**\n     * Retourne un tableau qui peut \u00eatre utilis\u00e9 pour d\u00e9crire l'\u00e9tat interne de cet objet.\n     *\n     * @return array<string, mixed>\n     *\/\n    public function __debugInfo(): array\n    {\n        return [\n            'status'          => $this->_status,\n            'contentType'     => $this->getType(),\n            'headers'         => $this->headers,\n            'file'            => $this->_file,\n            'fileRange'       => $this->_fileRange,\n            'cookies'         => $this->_cookies,\n            'cacheDirectives' => $this->_cacheDirectives,\n            'body'            => (string) $this->getBody(),\n        ];\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,0,null,0,null,0,null,null,null,0,null,null,null,0,null,null,null,0,null,0,null,0,null,0,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,null,0,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,0,0,null,null,null,null,null,null,null,null,null,0,null,0,null,0,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,0,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,0,null,0,null,null,null,null,null,null,null,null,0,null,null,0,0,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,null,0,0,null,0,null,null,0,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,0,0,null,0,null,null,0,null,0,null,null,0,null,0,null,null,0,null,0,null,null,null,0,null,0,null,0,null,null,0,0,null,0,null,0,null,0,0,null,0,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,0,null,0,0,null,null,null,0,0,null,null,0,null,null,null,0,0,null,0,null,null,null,0,0,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null]},{"name":"src\\Http\\ResponseEmitter.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Http;\n\nuse GuzzleHttp\\Psr7\\LimitStream;\n\n\/**\n * \u00c9metteur de r\u00e9ponse\n *\n * \u00c9met une r\u00e9ponse \u00e0 l'API du serveur PHP.\n *\n * Cet \u00e9metteur offre quelques changements par rapport aux \u00e9metteurs propos\u00e9s par\n * diactors :\n *\n * - Les cookies sont \u00e9mis en utilisant setcookie() pour ne pas entrer en conflit avec ext\/session\n * - Pour les serveurs fastcgi avec PHP-FPM, session_write_close() est appel\u00e9 simplement\n * avant fastcgi_finish_request() pour s'assurer que les donn\u00e9es de session sont enregistr\u00e9es\n * correctement (en particulier sur les backends de session plus lents).\n *\n * @credit      CakePHP 4.0 (Cake\\Http\\ResponseEmitter)\n *\/\nclass ResponseEmitter\n{\n    public function emit(Response $response, int $maxBufferLength = 8192)\n    {\n        $file = $line = null;\n        if (headers_sent($file, $line)) {\n            $message = \"Unable to emit headers. Headers sent in file={$file} line={$line}\";\n            if (on_dev()) {\n                trigger_error($message, E_USER_WARNING);\n            }\n\n            logger()->warning($message);\n        }\n\n        $this->emitStatusLine($response);\n        $this->emitHeaders($response);\n        $this->flush();\n\n        $range = $this->parseContentRange($response->getHeaderLine('Content-Range'));\n        if (is_array($range)) {\n            $this->emitBodyRange($range, $response, $maxBufferLength);\n        } else {\n            $this->emitBody($response, $maxBufferLength);\n        }\n\n        if (function_exists('fastcgi_finish_request')) {\n            session_write_close();\n            fastcgi_finish_request();\n        }\n    }\n\n    \/**\n     * \u00c9mettre des en-t\u00eates de r\u00e9ponse.\n     *\n     * Boucle \u00e0 travers chaque en-t\u00eate, \u00e9mettant chacun ; si la valeur d'en-t\u00eate\n     * est un tableau avec plusieurs valeurs, garantit que chacune est envoy\u00e9e\n     * de mani\u00e8re \u00e0 cr\u00e9er des en-t\u00eates agr\u00e9g\u00e9s (au lieu de remplacer\n     * la pr\u00e9c\u00e9dente).\n     *\n     * @return void\n     *\/\n    public function emitHeaders(Response $response)\n    {\n        $cookies = [];\n        if (method_exists($response, 'getCookies')) {\n            $cookies = $response->getCookies();\n        }\n\n        foreach ($response->getHeaders() as $name => $values) {\n            if (strtolower($name) === 'set-cookie') {\n                $cookies = array_merge($cookies, $values);\n\n                continue;\n            }\n            $first = true;\n\n            foreach ($values as $value) {\n                header(sprintf(\n                    '%s: %s',\n                    $name,\n                    $value\n                ), $first);\n                $first = false;\n            }\n        }\n\n        $this->emitCookies($cookies);\n    }\n\n    \/**\n     * Emet le corps de la requ\u00eate\n     *\n     * @param int $maxBufferLength La taille du bloc \u00e0 \u00e9mettre\n     *\n     * @return void\n     *\/\n    protected function emitBody(Response $response, int $maxBufferLength)\n    {\n        if (in_array($response->getStatusCode(), [204, 304], true)) {\n            return;\n        }\n        $body = $response->getBody();\n\n        if (! $body->isSeekable()) {\n            echo $body;\n\n            return;\n        }\n\n        $body->rewind();\n\n        while (! $body->eof()) {\n            echo $body->read($maxBufferLength);\n        }\n    }\n\n    \/**\n     * \u00c9mettre une plage du corps du message.\n     *\n     * @param array $range           La plage de donn\u00e9es \u00e0 \u00e9mettre\n     * @param int   $maxBufferLength La taille du bloc \u00e0 \u00e9mettre\n     *\n     * @return void\n     *\/\n    protected function emitBodyRange(array $range, Response $response, int $maxBufferLength)\n    {\n        [$unit, $first, $last, $length] = $range;\n\n        $body = $response->getBody();\n\n        if (! $body->isSeekable()) {\n            $contents = $body->getContents();\n            echo substr($contents, $first, $last - $first + 1);\n\n            return;\n        }\n\n        $body = new LimitStream($body, -1, $first);\n        $body->rewind();\n        $pos    = 0;\n        $length = $last - $first + 1;\n\n        while (! $body->eof() && $pos < $length) {\n            if (($pos + $maxBufferLength) > $length) {\n                echo $body->read($length - $pos);\n                break;\n            }\n\n            echo $body->read($maxBufferLength);\n            $pos = $body->tell();\n        }\n    }\n\n    \/**\n     * \u00c9mettre la ligne d'\u00e9tat.\n     *\n     * \u00c9met la ligne d'\u00e9tat en utilisant la version du protocole et le code d'\u00e9tat de\n     * la r\u00e9ponse; si une expression de raison est disponible, elle est \u00e9galement \u00e9mise.\n     *\n     * @return void\n     *\/\n    protected function emitStatusLine(Response $response)\n    {\n        $reasonPhrase = $response->getReasonPhrase();\n        header(sprintf(\n            'HTTP\/%s %d%s',\n            $response->getProtocolVersion(),\n            $response->getStatusCode(),\n            ($reasonPhrase ? ' ' . $reasonPhrase : '')\n        ));\n    }\n\n    \/**\n     * \u00e9mettre des cookies en utilisant setcookie()\n     *\n     * @param array $cookies Un tableau d'en-t\u00eates Set-Cookie.\n     *\n     * @return void\n     *\/\n    protected function emitCookies(array $cookies)\n    {\n        foreach ($cookies as $cookie) {\n            if (is_array($cookie)) {\n                setcookie(\n                    $cookie['name'],\n                    $cookie['value'],\n                    $cookie['expire'],\n                    $cookie['path'],\n                    $cookie['domain'],\n                    $cookie['secure'],\n                    $cookie['httpOnly']\n                );\n\n                continue;\n            }\n\n            if (strpos($cookie, '\";\"') !== false) {\n                $cookie = str_replace('\";\"', '{__cookie_replace__}', $cookie);\n                $parts  = str_replace('{__cookie_replace__}', '\";\"', explode(';', $cookie));\n            } else {\n                $parts = preg_split('\/\\;[ \\t]*\/', $cookie);\n            }\n\n            [$name, $value] = explode('=', array_shift($parts), 2);\n            $data           = [\n                'name'     => urldecode($name),\n                'value'    => urldecode($value),\n                'expires'  => 0,\n                'path'     => '',\n                'domain'   => '',\n                'secure'   => false,\n                'httponly' => false,\n            ];\n\n            foreach ($parts as $part) {\n                if (strpos($part, '=') !== false) {\n                    [$key, $value] = explode('=', $part);\n                } else {\n                    $key   = $part;\n                    $value = true;\n                }\n\n                $key        = strtolower($key);\n                $data[$key] = $value;\n            }\n            if (! empty($data['expires'])) {\n                $data['expires'] = strtotime($data['expires']);\n            }\n            setcookie(\n                $data['name'],\n                $data['value'],\n                $data['expires'],\n                $data['path'],\n                $data['domain'],\n                $data['secure'],\n                $data['httponly']\n            );\n        }\n    }\n\n    \/**\n     * Boucle \u00e0 travers le tampon de sortie, en vidant chacun, avant d'\u00e9mettre\n     * la r\u00e9ponse.\n     *\n     * @param int|null $maxBufferLevel Vide jusqu'\u00e0 ce niveau de tampon.\n     *\n     * @return void\n     *\/\n    protected function flush(?int $maxBufferLevel = null)\n    {\n        if (null === $maxBufferLevel) {\n            $maxBufferLevel = ob_get_level();\n        }\n\n        while (ob_get_level() > $maxBufferLevel) {\n            ob_end_flush();\n        }\n    }\n\n    \/**\n     * Analyser l'en-t\u00eate de la plage de contenu\n     * https:\/\/www.w3.org\/Protocols\/rfc2616\/rfc2616-sec14.html#sec14.16\n     *\n     * @param string $header L'en-t\u00eate Content-Range \u00e0 analyser.\n     *\n     * @return array|false [unit\u00e9, premier, dernier, longueur] ; renvoie faux si non\n     *                     une plage de contenu ou une plage de contenu non valide est fournie\n     *\/\n    protected function parseContentRange(string $header)\n    {\n        if (preg_match('\/(?P<unit>[\\w]+)\\s+(?P<first>\\d+)-(?P<last>\\d+)\\\/(?P<length>\\d+|\\*)\/', $header, $matches)) {\n            return [\n                $matches['unit'],\n                (int) $matches['first'],\n                (int) $matches['last'],\n                $matches['length'] === '*' ? '*' : (int) $matches['length'],\n            ];\n        }\n\n        return false;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,0,null,null,0,0,0,null,0,null,0,null,0,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,0,null,0,null,0,null,null,null,null,null,null,0,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,0,null,0,null,null,0,0,0,0,null,null,null,0,0,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,0,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,0,null,0,0,null,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null]},{"name":"src\\Http\\ServerRequest.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Http;\n\nuse BadMethodCallException;\nuse BlitzPHP\\Exceptions\\FrameworkException;\nuse BlitzPHP\\Exceptions\\HttpException;\nuse BlitzPHP\\Http\\Cookie\\CookieCollection;\nuse BlitzPHP\\Utilities\\Arr;\nuse GuzzleHttp\\Psr7\\ServerRequest as Psr7ServerRequest;\nuse GuzzleHttp\\Psr7\\Stream;\nuse GuzzleHttp\\Psr7\\UploadedFile;\nuse InvalidArgumentException;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Psr\\Http\\Message\\StreamInterface;\nuse Psr\\Http\\Message\\UploadedFileInterface;\nuse Psr\\Http\\Message\\UriInterface;\n\n\/**\n * Une classe qui aide \u00e0 envelopper les informations de la requ\u00eate et les d\u00e9tails d'une seule requ\u00eate.\n * Fournit des m\u00e9thodes couramment utilis\u00e9es pour effectuer une introspection sur les en-t\u00eates et le corps de la requ\u00eate.\n *\/\nclass ServerRequest implements ServerRequestInterface\n{\n    \/**\n     * Array of parameters parsed from the URL.\n     *\n     * @var array\n     *\/\n    protected $params = [\n        'plugin'     => null,\n        'controller' => null,\n        'action'     => null,\n        '_ext'       => null,\n        'pass'       => [],\n    ];\n\n    \/**\n     * Array of POST data. Will contain form data as well as uploaded files.\n     * In PUT\/PATCH\/DELETE requests this property will contain the form-urlencoded\n     * data.\n     *\n     * @var array|object|null\n     *\/\n    protected $data = [];\n\n    \/**\n     * Array of query string arguments\n     *\n     * @var array\n     *\/\n    protected $query = [];\n\n    \/**\n     * Array of cookie data.\n     *\n     * @var array\n     *\/\n    protected $cookies = [];\n\n    \/**\n     * Array of environment data.\n     *\n     * @var array\n     *\/\n    protected $_environment = [];\n\n    \/**\n     * Base URL path.\n     *\n     * @var string\n     *\/\n    protected $base;\n\n    \/**\n     * webroot path segment for the request.\n     *\n     * @var string\n     *\/\n    protected $webroot = '\/';\n\n    \/**\n     * Whether to trust HTTP_X headers set by most load balancers.\n     * Only set to true if your application runs behind load balancers\/proxies\n     * that you control.\n     *\n     * @var bool\n     *\/\n    public $trustProxy = false;\n\n    \/**\n     * Trusted proxies list\n     *\n     * @var array<string>\n     *\/\n    protected $trustedProxies = [];\n\n    \/**\n     * The built in detectors used with `is()` can be modified with `addDetector()`.\n     *\n     * There are several ways to specify a detector, see \\Cake\\Http\\ServerRequest::addDetector() for the\n     * various formats and ways to define detectors.\n     *\n     * @var array<array|callable>\n     *\/\n    protected static $_detectors = [\n        'get'     => ['env' => 'REQUEST_METHOD', 'value' => 'GET'],\n        'post'    => ['env' => 'REQUEST_METHOD', 'value' => 'POST'],\n        'put'     => ['env' => 'REQUEST_METHOD', 'value' => 'PUT'],\n        'patch'   => ['env' => 'REQUEST_METHOD', 'value' => 'PATCH'],\n        'delete'  => ['env' => 'REQUEST_METHOD', 'value' => 'DELETE'],\n        'head'    => ['env' => 'REQUEST_METHOD', 'value' => 'HEAD'],\n        'options' => ['env' => 'REQUEST_METHOD', 'value' => 'OPTIONS'],\n        'ssl'     => ['env' => 'HTTPS', 'options' => [1, 'on']],\n        'ajax'    => ['env' => 'HTTP_X_REQUESTED_WITH', 'value' => 'XMLHttpRequest'],\n        'json'    => ['accept' => ['application\/json'], 'param' => '_ext', 'value' => 'json'],\n        'xml'     => ['accept' => ['application\/xml', 'text\/xml'], 'param' => '_ext', 'value' => 'xml'],\n    ];\n\n    \/**\n     * Instance cache for results of is(something) calls\n     *\n     * @var array\n     *\/\n    protected $_detectorCache = [];\n\n    \/**\n     * Request body stream. Contains php:\/\/input unless `input` constructor option is used.\n     *\n     * @var \\Psr\\Http\\Message\\StreamInterface\n     *\/\n    protected $stream;\n\n    \/**\n     * Uri instance\n     *\n     * @var \\Psr\\Http\\Message\\UriInterface\n     *\/\n    protected $uri;\n\n    \/**\n     * Instance of a Session object relative to this request\n     *\n     * @var Session\n     *\/\n    protected $session;\n\n    \/**\n     * Store the additional attributes attached to the request.\n     *\n     * @var array\n     *\/\n    protected $attributes = [];\n\n    \/**\n     * A list of properties that emulated by the PSR7 attribute methods.\n     *\n     * @var array<string>\n     *\/\n    protected $emulatedAttributes = ['session', 'flash', 'webroot', 'base', 'params', 'here'];\n\n    \/**\n     * Array of Psr\\Http\\Message\\UploadedFileInterface objects.\n     *\n     * @var array\n     *\/\n    protected $uploadedFiles = [];\n\n    \/**\n     * The HTTP protocol version used.\n     *\n     * @var string|null\n     *\/\n    protected $protocol;\n\n    \/**\n     * The request target if overridden\n     *\n     * @var string|null\n     *\/\n    protected $requestTarget;\n\n    \/**\n     * Create a new request object.\n     *\n     * You can supply the data as either an array or as a string. If you use\n     * a string you can only supply the URL for the request. Using an array will\n     * let you provide the following keys:\n     *\n     * - `post` POST data or non query string data\n     * - `query` Additional data from the query string.\n     * - `files` Uploaded files in a normalized structure, with each leaf an instance of UploadedFileInterface.\n     * - `cookies` Cookies for this request.\n     * - `environment` $_SERVER and $_ENV data.\n     * - `url` The URL without the base path for the request.\n     * - `uri` The PSR7 UriInterface object. If null, one will be created from `url` or `environment`.\n     * - `base` The base URL for the request.\n     * - `webroot` The webroot directory for the request.\n     * - `input` The data that would come from php:\/\/input this is useful for simulating\n     *   requests with put, patch or delete data.\n     * - `session` An instance of a Session object\n     *\n     * @param array<string, mixed> $config An array of request data to create a request with.\n     *\/\n    public function __construct(array $config = [])\n    {\n        $config += [\n            'params'      => $this->params,\n            'query'       => [],\n            'post'        => [],\n            'files'       => [],\n            'cookies'     => [],\n            'environment' => [],\n            'url'         => '',\n            'uri'         => null,\n            'base'        => '',\n            'webroot'     => '',\n            'input'       => null,\n        ];\n\n        $this->_setConfig($config);\n    }\n\n    \/**\n     * Traitez les donn\u00e9es de configuration\/param\u00e8tres dans les propri\u00e9t\u00e9s.\n     *\n     * @param array<string, mixed> $config\n     *\/\n    protected function _setConfig(array $config): void\n    {\n        if (empty($config['session'])) {\n            $config['session'] = new Session([\n                'cookiePath' => $config['base'],\n            ]);\n        }\n\n        if (empty($config['environment']['REQUEST_METHOD'])) {\n            $config['environment']['REQUEST_METHOD'] = 'GET';\n        }\n\n        $this->cookies = $config['cookies'];\n\n        if (isset($config['uri'])) {\n            if (! $config['uri'] instanceof UriInterface) {\n                throw new FrameworkException('The `uri` key must be an instance of ' . UriInterface::class);\n            }\n            $uri = $config['uri'];\n        } else {\n            if ($config['url'] !== '') {\n                $config = $this->processUrlOption($config);\n            }\n            $uri = Psr7ServerRequest::getUriFromGlobals();\n        }\n\n        $this->_environment = $config['environment'];\n\n        $this->uri     = $uri;\n        $this->base    = $config['base'];\n        $this->webroot = $config['webroot'];\n\n        if (isset($config['input'])) {\n            $stream = new Stream(\\GuzzleHttp\\Psr7\\Utils::tryFopen('php:\/\/memory', 'rw'));\n            $stream->write($config['input']);\n            $stream->rewind();\n        } else {\n            $stream = new Stream(\\GuzzleHttp\\Psr7\\Utils::tryFopen('php:\/\/input', 'r'));\n        }\n        $this->stream = $stream;\n\n        $this->data          = $config['post'];\n        $this->uploadedFiles = $config['files'];\n        $this->query         = $config['query'];\n        $this->params        = $config['params'];\n        $this->session       = $config['session'];\n    }\n\n    \/**\n     * D\u00e9finissez les variables d'environnement en fonction de l'option `url` pour faciliter la g\u00e9n\u00e9ration d'instance UriInterface.\n     *\n     * L'option `query` est \u00e9galement mise \u00e0 jour en fonction de la cha\u00eene de requ\u00eate de l'URL.\n     *\/\n    protected function processUrlOption(array $config): array\n    {\n        if ($config['url'][0] !== '\/') {\n            $config['url'] = '\/' . $config['url'];\n        }\n\n        if (strpos($config['url'], '?') !== false) {\n            [$config['url'], $config['environment']['QUERY_STRING']] = explode('?', $config['url']);\n\n            parse_str($config['environment']['QUERY_STRING'], $queryArgs);\n            $config['query'] += $queryArgs;\n        }\n\n        $config['environment']['REQUEST_URI'] = $config['url'];\n\n        return $config;\n    }\n\n    \/**\n     * Obtenez le type de contenu utilis\u00e9 dans cette requ\u00eate.\n     *\/\n    public function contentType(): ?string\n    {\n        $type = $this->getEnv('CONTENT_TYPE');\n        if ($type) {\n            return $type;\n        }\n\n        return $this->getEnv('HTTP_CONTENT_TYPE');\n    }\n\n    \/**\n     * Renvoie l'instance de l'objet Session pour cette requ\u00eate\n     *\/\n    public function getSession(): Session\n    {\n        return $this->session;\n    }\n\n    \/**\n     * Obtenez l'adresse IP que le client utilise ou dit qu'il utilise.\n     *\/\n    public function clientIp(): string\n    {\n        if ($this->trustProxy && $this->getEnv('HTTP_X_FORWARDED_FOR')) {\n            $addresses = array_map('trim', explode(',', (string) $this->getEnv('HTTP_X_FORWARDED_FOR')));\n            $trusted   = (count($this->trustedProxies) > 0);\n            $n         = count($addresses);\n\n            if ($trusted) {\n                $trusted = array_diff($addresses, $this->trustedProxies);\n                $trusted = (count($trusted) === 1);\n            }\n\n            if ($trusted) {\n                return $addresses[0];\n            }\n\n            return $addresses[$n - 1];\n        }\n\n        if ($this->trustProxy && $this->getEnv('HTTP_X_REAL_IP')) {\n            $ipaddr = $this->getEnv('HTTP_X_REAL_IP');\n        } elseif ($this->trustProxy && $this->getEnv('HTTP_CLIENT_IP')) {\n            $ipaddr = $this->getEnv('HTTP_CLIENT_IP');\n        } else {\n            $ipaddr = $this->getEnv('REMOTE_ADDR');\n        }\n\n        return trim((string) $ipaddr);\n    }\n\n    \/**\n     * Enregistrer des proxys de confiance\n     *\n     * @param string[] $proxies ips liste des proxys de confiance\n     *\/\n    public function setTrustedProxies(array $proxies): void\n    {\n        $this->trustedProxies = $proxies;\n        $this->trustProxy     = true;\n    }\n\n    \/**\n     * Obtenez les proxys de confiance\n     *\/\n    public function getTrustedProxies(): array\n    {\n        return $this->trustedProxies;\n    }\n\n    \/**\n     * Renvoie le r\u00e9f\u00e9rent qui a r\u00e9f\u00e9r\u00e9 cette requ\u00eate.\n     *\n     * @param bool $local Tentative de renvoi d'une adresse locale.\n     *                    Les adresses locales ne contiennent pas de noms d'h\u00f4tes..\n     *\/\n    public function referer(bool $local = true): ?string\n    {\n        $ref = $this->getEnv('HTTP_REFERER');\n\n        $base = \/* Configure::read('App.fullBaseUrl') .  *\/ $this->webroot;\n        if (! empty($ref) && ! empty($base)) {\n            if ($local && strpos($ref, $base) === 0) {\n                $ref = substr($ref, strlen($base));\n                if ($ref === '' || strpos($ref, '\/\/') === 0) {\n                    $ref = '\/';\n                }\n                if ($ref[0] !== '\/') {\n                    $ref = '\/' . $ref;\n                }\n\n                return $ref;\n            }\n            if (! $local) {\n                return $ref;\n            }\n        }\n\n        return null;\n    }\n\n    \/**\n     * Gestionnaire de m\u00e9thodes manquant, les poign\u00e9es enveloppent les anciennes m\u00e9thodes de type isAjax()\n     *\n     * @throws BadMethodCallException lorsqu'une m\u00e9thode invalide est appel\u00e9e.\n     *\n     * @return bool\n     *\/\n    public function __call(string $name, array $params)\n    {\n        if (strpos($name, 'is') === 0) {\n            $type = strtolower(substr($name, 2));\n\n            array_unshift($params, $type);\n\n            return $this->is(...$params);\n        }\n\n        throw new BadMethodCallException(sprintf('Method \"%s()\" does not exist', $name));\n    }\n\n    \/**\n     * V\u00e9rifiez si une demande est d'un certain type.\n     *\n     * Utilise les r\u00e8gles de d\u00e9tection int\u00e9gr\u00e9es ainsi que des r\u00e8gles suppl\u00e9mentaires\n     * d\u00e9fini avec {@link \\BlitzPHP\\Http\\ServerRequest::addDetector()}. Tout d\u00e9tecteur peut \u00eatre appel\u00e9\n     * comme `is($type)` ou `is$Type()`.\n     *\n     * @param string|string[] $type Le type de requ\u00eate que vous souhaitez v\u00e9rifier. S'il s'agit d'un tableau, cette m\u00e9thode renverra true si la requ\u00eate correspond \u00e0 n'importe quel type.\n     *\n     * @return bool Si la demande est du type que vous v\u00e9rifiez.\n     *\/\n    public function is($type, ...$args): bool\n    {\n        if (is_array($type)) {\n            foreach ($type as $_type) {\n                if ($this->is($_type)) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        $type = strtolower($type);\n        if (! isset(static::$_detectors[$type])) {\n            return false;\n        }\n        if ($args) {\n            return $this->_is($type, $args);\n        }\n\n        return $this->_detectorCache[$type] = $this->_detectorCache[$type] ?? $this->_is($type, $args);\n    }\n\n    \/**\n     * Efface le cache du d\u00e9tecteur d'instance, utilis\u00e9 par la fonction is()\n     *\/\n    public function clearDetectorCache(): void\n    {\n        $this->_detectorCache = [];\n    }\n\n    \/**\n     * Worker pour la fonction publique is()\n     *\n     * @param string $type Le type de requ\u00eate que vous souhaitez v\u00e9rifier.\n     * @param array  $args Tableau d'arguments de d\u00e9tecteur personnalis\u00e9s.\n     *\n     * @return bool Si la demande est du type que vous v\u00e9rifiez.\n     *\/\n    protected function _is(string $type, array $args): bool\n    {\n        $detect = static::$_detectors[$type];\n        if (is_callable($detect)) {\n            array_unshift($args, $this);\n\n            return $detect(...$args);\n        }\n        if (isset($detect['env']) && $this->_environmentDetector($detect)) {\n            return true;\n        }\n        if (isset($detect['header']) && $this->_headerDetector($detect)) {\n            return true;\n        }\n        if (isset($detect['accept']) && $this->_acceptHeaderDetector($detect)) {\n            return true;\n        }\n\n        return (bool) (isset($detect['param']) && $this->_paramDetector($detect));\n    }\n\n    \/**\n     * D\u00e9tecte si un en-t\u00eate d'acceptation sp\u00e9cifique est pr\u00e9sent.\n     *\n     * @param array $detect Tableau d'options du d\u00e9tecteur.\n     *\n     * @return bool Si la demande est du type que vous v\u00e9rifiez.\n     *\/\n    protected function _acceptHeaderDetector(array $detect): bool\n    {\n        $acceptHeaders = explode(',', (string) $this->getEnv('HTTP_ACCEPT'));\n\n        foreach ($detect['accept'] as $header) {\n            if (in_array($header, $acceptHeaders, true)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    \/**\n     * D\u00e9tecte si un en-t\u00eate sp\u00e9cifique est pr\u00e9sent.\n     *\n     * @param array $detect Tableau d'options du d\u00e9tecteur.\n     *\n     * @return bool Si la demande est du type que vous v\u00e9rifiez.\n     *\/\n    protected function _headerDetector(array $detect): bool\n    {\n        foreach ($detect['header'] as $header => $value) {\n            $header = $this->getEnv('http_' . $header);\n            if ($header !== null) {\n                if (! is_string($value) && ! is_bool($value) && is_callable($value)) {\n                    return $value($header);\n                }\n\n                return $header === $value;\n            }\n        }\n\n        return false;\n    }\n\n    \/**\n     * D\u00e9tecte si un param\u00e8tre de requ\u00eate sp\u00e9cifique est pr\u00e9sent.\n     *\n     * @param array $detect Tableau d'options du d\u00e9tecteur.\n     *\n     * @return bool Si la demande est du type que vous v\u00e9rifiez.\n     *\/\n    protected function _paramDetector(array $detect): bool\n    {\n        $key = $detect['param'];\n        if (isset($detect['value'])) {\n            $value = $detect['value'];\n\n            return isset($this->params[$key]) ? $this->params[$key] === $value : false;\n        }\n        if (isset($detect['options'])) {\n            return isset($this->params[$key]) ? in_array($this->params[$key], $detect['options'], true) : false;\n        }\n\n        return false;\n    }\n\n    \/**\n     * D\u00e9tecte si une variable d'environnement sp\u00e9cifique est pr\u00e9sente.\n     *\n     * @param array $detect Tableau d'options du d\u00e9tecteur.\n     *\n     * @return bool Si la demande est du type que vous v\u00e9rifiez.\n     *\/\n    protected function _environmentDetector(array $detect): bool\n    {\n        if (isset($detect['env'])) {\n            if (isset($detect['value'])) {\n                return $this->getEnv($detect['env']) === $detect['value'];\n            }\n            if (isset($detect['pattern'])) {\n                return (bool) preg_match($detect['pattern'], (string) $this->getEnv($detect['env']));\n            }\n            if (isset($detect['options'])) {\n                $pattern = '\/' . implode('|', $detect['options']) . '\/i';\n\n                return (bool) preg_match($pattern, (string) $this->getEnv($detect['env']));\n            }\n        }\n\n        return false;\n    }\n\n    \/**\n     * V\u00e9rifier qu'une requ\u00eate correspond \u00e0 tous les types donn\u00e9s.\n     *\n     * Vous permet de tester plusieurs types et d'unir les r\u00e9sultats.\n     * Voir Request::is() pour savoir comment ajouter des types suppl\u00e9mentaires et le\n     * types int\u00e9gr\u00e9s.\n     *\n     * @param string[] $types Les types \u00e0 v\u00e9rifier.\n     *\n     * @see \\BlitzPHP\\Http\\ServerRequest::is()\n     *\/\n    public function isAll(array $types): bool\n    {\n        foreach ($types as $type) {\n            if (! $this->is($type)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * Ajouter un nouveau d\u00e9tecteur \u00e0 la liste des d\u00e9tecteurs qu'une requ\u00eate peut utiliser.\n     * Il existe plusieurs types de d\u00e9tecteurs diff\u00e9rents qui peuvent \u00eatre r\u00e9gl\u00e9s.\n     *\n     * ### Comparaison des rappels\n     *\n     * Les d\u00e9tecteurs de rappel vous permettent de fournir un callable pour g\u00e9rer le ch\u00e8que.\n     * Le rappel recevra l'objet de requ\u00eate comme seul param\u00e8tre.\n     *\n     * ```\n     * addDetector('custom', function ($request) { \/\/Renvoyer un bool\u00e9en });\n     * ```\n     *\n     * ### Comparaison des valeurs d'environnement\n     *\n     * Une comparaison de valeur d'environnement, compare une valeur extraite de `env()` \u00e0 une valeur connue\n     * la valeur d'environnement est l'\u00e9galit\u00e9 v\u00e9rifi\u00e9e par rapport \u00e0 la valeur fournie.\n     *\n     * ```\n     * addDetector('post', ['env' => 'REQUEST_METHOD', 'value' => 'POST']);\n     * ```\n     *\n     * ### Comparaison des param\u00e8tres de demande\n     *\n     * Permet des d\u00e9tecteurs personnalis\u00e9s sur les param\u00e8tres de demande.\n     *\n     * ```\n     * addDetector('admin', ['param' => 'prefix', 'value' => 'admin']);\n     * ```\n     *\n     * ### Accepter la comparaison\n     *\n     * Permet au d\u00e9tecteur de comparer avec la valeur d'en-t\u00eate Accepter.\n     *\n     * ```\n     * addDetector('csv', ['accept' => 'text\/csv']);\n     * ```\n     *\n     * ### Comparaison d'en-t\u00eate\n     *\n     * Permet de comparer un ou plusieurs en-t\u00eates.\n     *\n     * ```\n     * addDetector('fancy', ['header' => ['X-Fancy' => 1]);\n     * ```\n     *\n     * Les types `param`, `env` et de comparaison permettent ce qui suit\n     * options de comparaison de valeur :\n     *\n     * ### Comparaison des valeurs de mod\u00e8le\n     *\n     * La comparaison de valeurs de mod\u00e8les vous permet de comparer une valeur extraite de `env()` \u00e0 une expression r\u00e9guli\u00e8re.\n     *\n     * ```\n     * addDetector('iphone', ['env' => 'HTTP_USER_AGENT', 'pattern' => '\/iPhone\/i']);\n     * ```\n     *\n     * ### Comparaison bas\u00e9e sur les options\n     *\n     * Les comparaisons bas\u00e9es sur des options utilisent une liste d'options pour cr\u00e9er une expression r\u00e9guli\u00e8re. Appels ult\u00e9rieurs\n     * ajouter un d\u00e9tecteur d'options d\u00e9j\u00e0 d\u00e9fini fusionnera les options.\n     *\n     * ```\n     * addDetector('mobile', ['env' => 'HTTP_USER_AGENT', 'options' => ['Fennec']]);\n     * ```\n     *\n     * Vous pouvez \u00e9galement comparer plusieurs valeurs\n     * en utilisant la touche `options`. Ceci est utile lorsque vous souhaitez v\u00e9rifier\n     * si une valeur de requ\u00eate se trouve dans une liste d'options.\n     *\n     * `addDetector('extension', ['param' => '_ext', 'options' => ['pdf', 'csv']]`\n     *\n     * @param array|callable $detector Un callback ou tableau d'options pour la d\u00e9finition du d\u00e9tecteur.\n     *\/\n    public static function addDetector(string $name, $detector): void\n    {\n        $name = strtolower($name);\n        if (is_callable($detector)) {\n            static::$_detectors[$name] = $detector;\n\n            return;\n        }\n        if (isset(static::$_detectors[$name], $detector['options'])) {\n            \/** @psalm-suppress PossiblyInvalidArgument *\/\n            $detector = Arr::merge(static::$_detectors[$name], $detector);\n        }\n        static::$_detectors[$name] = $detector;\n    }\n\n    \/**\n     * Normaliser un nom d'en-t\u00eate dans la version SERVER.\n     *\/\n    protected function normalizeHeaderName(string $name): string\n    {\n        $name = str_replace('-', '_', strtoupper($name));\n        if (! in_array($name, ['CONTENT_LENGTH', 'CONTENT_TYPE'], true)) {\n            $name = 'HTTP_' . $name;\n        }\n\n        return $name;\n    }\n\n    \/**\n     * Obtenez tous les en-t\u00eates de la requ\u00eate.\n     *\n     * Renvoie un tableau associatif o\u00f9 les noms d'en-t\u00eate sont\n     * les cl\u00e9s et les valeurs sont une liste de valeurs d'en-t\u00eate.\n     *\n     * Bien que les noms d'en-t\u00eate ne soient pas sensibles \u00e0 la casse, getHeaders() normalisera\n     * les en-t\u00eates.\n     *\n     * @return array<string[]> Un tableau associatif d'en-t\u00eates et leurs valeurs.\n     *\n     * @see http:\/\/www.php-fig.org\/psr\/psr-7\/ Cette m\u00e9thode fait partie de l'interface de requ\u00eate du serveur PSR-7.\n     *\/\n    public function getHeaders(): array\n    {\n        $headers = [];\n\n        foreach ($this->_environment as $key => $value) {\n            $name = null;\n            if (strpos($key, 'HTTP_') === 0) {\n                $name = substr($key, 5);\n            }\n            if (strpos($key, 'CONTENT_') === 0) {\n                $name = $key;\n            }\n            if ($name !== null) {\n                $name           = str_replace('_', ' ', strtolower($name));\n                $name           = str_replace(' ', '-', ucwords($name));\n                $headers[$name] = (array) $value;\n            }\n        }\n\n        return $headers;\n    }\n\n    \/**\n     * V\u00e9rifiez si un en-t\u00eate est d\u00e9fini dans la requ\u00eate.\n     *\n     * @param string $name L'en-t\u00eate que vous souhaitez obtenir (insensible \u00e0 la casse)\n     *\n     * @see http:\/\/www.php-fig.org\/psr\/psr-7\/ Cette m\u00e9thode fait partie de l'interface de requ\u00eate du serveur PSR-7.\n     *\/\n    public function hasHeader($name): bool\n    {\n        $name = $this->normalizeHeaderName($name);\n\n        return isset($this->_environment[$name]);\n    }\n\n    \/**\n     * Obtenez un seul en-t\u00eate de la requ\u00eate.\n     *\n     * Renvoie la valeur de l'en-t\u00eate sous forme de tableau. Si l'en-t\u00eate\n     * n'est pas pr\u00e9sent, un tableau vide sera retourn\u00e9.\n     *\n     * @param string $name L'en-t\u00eate que vous souhaitez obtenir (insensible \u00e0 la casse)\n     *\n     * @return string[] Un tableau associatif d'en-t\u00eates et leurs valeurs.\n     *                  Si l'en-t\u00eate n'existe pas, un tableau vide sera retourn\u00e9.\n     *\n     * @see http:\/\/www.php-fig.org\/psr\/psr-7\/ Cette m\u00e9thode fait partie de l'interface de requ\u00eate du serveur PSR-7.\n     *\/\n    public function getHeader($name): array\n    {\n        $name = $this->normalizeHeaderName($name);\n        if (isset($this->_environment[$name])) {\n            return (array) $this->_environment[$name];\n        }\n\n        return [];\n    }\n\n    \/**\n     * Obtenez un seul en-t\u00eate sous forme de cha\u00eene \u00e0 partir de la requ\u00eate.\n     *\n     * @param string $name L'en-t\u00eate que vous souhaitez obtenir (insensible \u00e0 la casse)\n     *\n     * @return string Les valeurs d'en-t\u00eate sont r\u00e9duites \u00e0 une cha\u00eene s\u00e9par\u00e9e par des virgules.\n     *\n     * @see http:\/\/www.php-fig.org\/psr\/psr-7\/ Cette m\u00e9thode fait partie de l'interface de requ\u00eate du serveur PSR-7.\n     *\/\n    public function getHeaderLine($name): string\n    {\n        $value = $this->getHeader($name);\n\n        return implode(', ', $value);\n    }\n\n    \/**\n     * Obtenez une demande modifi\u00e9e avec l'en-t\u00eate fourni.\n     *\n     * @param array|string $value\n     * @param mixed        $name\n     *\n     * @see http:\/\/www.php-fig.org\/psr\/psr-7\/ Cette m\u00e9thode fait partie de l'interface de requ\u00eate du serveur PSR-7.\n     *\/\n    public function withHeader($name, $value): self\n    {\n        $new                      = clone $this;\n        $name                     = $this->normalizeHeaderName($name);\n        $new->_environment[$name] = $value;\n\n        return $new;\n    }\n\n    \/**\n     * Obtenez une demande modifi\u00e9e avec l'en-t\u00eate fourni.\n     *\n     * Les valeurs d'en-t\u00eate existantes seront conserv\u00e9es. La valeur fournie\n     * sera ajout\u00e9 aux valeurs existantes.\n     *\n     * @param string       $name\n     * @param array|string $value\n     *\n     * @see http:\/\/www.php-fig.org\/psr\/psr-7\/ Cette m\u00e9thode fait partie de l'interface de requ\u00eate du serveur PSR-7.\n     *\/\n    public function withAddedHeader($name, $value): self\n    {\n        $new      = clone $this;\n        $name     = $this->normalizeHeaderName($name);\n        $existing = [];\n        if (isset($new->_environment[$name])) {\n            $existing = (array) $new->_environment[$name];\n        }\n        $existing                 = array_merge($existing, (array) $value);\n        $new->_environment[$name] = $existing;\n\n        return $new;\n    }\n\n    \/**\n     * Obtenez une demande modifi\u00e9e sans en-t\u00eate fourni.\n     *\n     * @see http:\/\/www.php-fig.org\/psr\/psr-7\/ Cette m\u00e9thode fait partie de l'interface de requ\u00eate du serveur PSR-7.\n     *\n     * @param mixed $name\n     *\/\n    public function withoutHeader($name): self\n    {\n        $new  = clone $this;\n        $name = $this->normalizeHeaderName($name);\n        unset($new->_environment[$name]);\n\n        return $new;\n    }\n\n    \/**\n     * Obtenez la m\u00e9thode HTTP utilis\u00e9e pour cette requ\u00eate.\n     * Il existe plusieurs mani\u00e8res de sp\u00e9cifier une m\u00e9thode.\n     *\n     * - Si votre client le prend en charge, vous pouvez utiliser des m\u00e9thodes HTTP natives.\n     * - Vous pouvez d\u00e9finir l'en-t\u00eate HTTP-X-Method-Override.\n     * - Vous pouvez soumettre une entr\u00e9e avec le nom `_method`\n     *\n     * Chacune de ces 3 approches peut \u00eatre utilis\u00e9e pour d\u00e9finir la m\u00e9thode HTTP utilis\u00e9e\n     * par BlitzPHP en interne, et affectera le r\u00e9sultat de cette m\u00e9thode.\n     *\n     * @see http:\/\/www.php-fig.org\/psr\/psr-7\/ Cette m\u00e9thode fait partie de l'interface de requ\u00eate du serveur PSR-7.\n     *\/\n    public function getMethod(): string\n    {\n        return (string) $this->getEnv('REQUEST_METHOD');\n    }\n\n    \/**\n     * Mettez \u00e0 jour la m\u00e9thode de requ\u00eate et obtenez une nouvelle instance.\n     *\n     * @see http:\/\/www.php-fig.org\/psr\/psr-7\/ Cette m\u00e9thode fait partie de l'interface de requ\u00eate du serveur PSR-7.\n     *\n     * @param mixed $method\n     *\/\n    public function withMethod($method): self\n    {\n        $new = clone $this;\n\n        if (\n            ! is_string($method)\n            || ! preg_match('\/^[!#$%&\\'*+.^_`\\|~0-9a-z-]+$\/i', $method)\n        ) {\n            throw new InvalidArgumentException(sprintf(\n                'Unsupported HTTP method \"%s\" provided',\n                $method\n            ));\n        }\n        $new->_environment['REQUEST_METHOD'] = $method;\n\n        return $new;\n    }\n\n    \/**\n     * Obtenez tous les param\u00e8tres de l'environnement du serveur.\n     *\n     * Lire toutes les donn\u00e9es 'environnement' ou 'serveur' qui ont \u00e9t\u00e9\n     * utilis\u00e9 pour cr\u00e9er cette requ\u00eate.\n     *\n     * @see http:\/\/www.php-fig.org\/psr\/psr-7\/ Cette m\u00e9thode fait partie de l'interface de requ\u00eate du serveur PSR-7.\n     *\/\n    public function getServerParams(): array\n    {\n        return $this->_environment;\n    }\n\n    \/**\n     * Obtenez tous les param\u00e8tres de requ\u00eate conform\u00e9ment aux sp\u00e9cifications PSR-7. Pour lire des valeurs de requ\u00eate sp\u00e9cifiques\n     * utilisez la m\u00e9thode alternative getQuery().\n     *\n     * @see http:\/\/www.php-fig.org\/psr\/psr-7\/ Cette m\u00e9thode fait partie de l'interface de requ\u00eate du serveur PSR-7.\n     *\/\n    public function getQueryParams(): array\n    {\n        return $this->query;\n    }\n\n    \/**\n     * Mettez \u00e0 jour les donn\u00e9es de la cha\u00eene de requ\u00eate et obtenez une nouvelle instance.\n     *\n     * @param array $query Les donn\u00e9es de la cha\u00eene de requ\u00eate \u00e0 utiliser\n     *\n     * @see http:\/\/www.php-fig.org\/psr\/psr-7\/ Cette m\u00e9thode fait partie de l'interface de requ\u00eate du serveur PSR-7.\n     *\/\n    public function withQueryParams(array $query): self\n    {\n        $new        = clone $this;\n        $new->query = $query;\n\n        return $new;\n    }\n\n    \/**\n     * Obtenez l'h\u00f4te sur lequel la demande a \u00e9t\u00e9 trait\u00e9e.\n     *\/\n    public function host(): ?string\n    {\n        if ($this->trustProxy && $this->getEnv('HTTP_X_FORWARDED_HOST')) {\n            return $this->getEnv('HTTP_X_FORWARDED_HOST');\n        }\n\n        return $this->getEnv('HTTP_HOST');\n    }\n\n    \/**\n     * Obtenez le port sur lequel la demande a \u00e9t\u00e9 trait\u00e9e.\n     *\/\n    public function port(): ?string\n    {\n        if ($this->trustProxy && $this->getEnv('HTTP_X_FORWARDED_PORT')) {\n            return $this->getEnv('HTTP_X_FORWARDED_PORT');\n        }\n\n        return $this->getEnv('SERVER_PORT');\n    }\n\n    \/**\n     * Obtenez le sch\u00e9ma d'URL actuel utilis\u00e9 pour la demande.\n     *\n     * par exemple. 'http' ou 'https'\n     *\/\n    public function scheme(): ?string\n    {\n        if ($this->trustProxy && $this->getEnv('HTTP_X_FORWARDED_PROTO')) {\n            return $this->getEnv('HTTP_X_FORWARDED_PROTO');\n        }\n\n        return $this->getEnv('HTTPS') ? 'https' : 'http';\n    }\n\n    \/**\n     * Obtenez le nom de domaine et incluez les segments $tldLength du tld.\n     *\n     * @param int $tldLength Nombre de segments que contient votre tld. Par exemple : `example.com` contient 1 tld.\n     *                       Alors que `example.co.uk` contient 2.\n     *\n     * @return string Nom de domaine sans sous-domaines.\n     *\/\n    public function domain(int $tldLength = 1): string\n    {\n        $host = $this->host();\n        if (empty($host)) {\n            return '';\n        }\n\n        $segments = explode('.', $host);\n        $domain   = array_slice($segments, -1 * ($tldLength + 1));\n\n        return implode('.', $domain);\n    }\n\n    \/**\n     * Obtenez les sous-domaines d'un h\u00f4te.\n     *\n     * @param int $tldLength Nombre de segments que contient votre tld. Par exemple : `example.com` contient 1 tld.\n     *                       Alors que `example.co.uk` contient 2.\n     *\n     * @return string[] Un tableau de sous-domaines.\n     *\/\n    public function subdomains(int $tldLength = 1): array\n    {\n        $host = $this->host();\n        if (empty($host)) {\n            return [];\n        }\n\n        $segments = explode('.', $host);\n\n        return array_slice($segments, 0, -1 * ($tldLength + 1));\n    }\n\n    \/**\n     * D\u00e9couvrez quels types de contenu le client accepte ou v\u00e9rifiez s'il accepte un\n     * type particulier de contenu.\n     *\n     * #### Obtenir tous les types :\n     *\n     * ```\n     * $this->request->accepts();\n     * ```\n     *\n     * #### V\u00e9rifier un seul type :\n     *\n     * ```\n     * $this->request->accepts('application\/json');\n     * ```\n     *\n     * Cette m\u00e9thode ordonnera les types de contenu renvoy\u00e9s par les valeurs de pr\u00e9f\u00e9rence indiqu\u00e9es\n     * par le client.\n     *\n     * @param string|null $type Le type de contenu \u00e0 v\u00e9rifier. Laissez null pour obtenir tous les types qu'un client accepte.\n     *\n     * @return bool|string[] Soit un tableau de tous les types accept\u00e9s par le client, soit un bool\u00e9en s'il accepte le type fourni.\n     *\/\n    public function accepts(?string $type = null)\n    {\n        $raw    = $this->parseAccept();\n        $accept = [];\n\n        foreach ($raw as $types) {\n            $accept = array_merge($accept, $types);\n        }\n        if ($type === null) {\n            return $accept;\n        }\n\n        return in_array($type, $accept, true);\n    }\n\n    \/**\n     * Analyser l'en-t\u00eate HTTP_ACCEPT et renvoyer un tableau tri\u00e9 avec les types de contenu\n     * comme cl\u00e9s et valeurs pref comme valeurs.\n     *\n     * G\u00e9n\u00e9ralement, vous souhaitez utiliser {@link \\BlitzPHP\\Http\\ServerRequest::accepts()} pour obtenir une liste simple\n     * des types de contenu accept\u00e9s.\n     *\n     * @return array Un tableau de `prefValue => [contenu\/types]`\n     *\/\n    public function parseAccept(): array\n    {\n        return $this->_parseAcceptWithQualifier($this->getHeaderLine('Accept'));\n    }\n\n    \/**\n     * Obtenez les langues accept\u00e9es par le client ou v\u00e9rifiez si une langue sp\u00e9cifique est accept\u00e9e.\n     *\n     * Obtenez la liste des langues accept\u00e9es :\n     *\n     * ``` \\BlitzPHP\\Http\\ServerRequest::acceptLanguage(); ```\n     *\n     * V\u00e9rifiez si une langue sp\u00e9cifique est accept\u00e9e :\n     *\n     * ``` \\BlitzPHP\\Http\\ServerRequest::acceptLanguage('es-es'); ```\n     *\n     * @return array|bool Si un $language est fourni, un bool\u00e9en. Sinon, le tableau des langues accept\u00e9es.\n     *\/\n    public function acceptLanguage(?string $language = null)\n    {\n        $raw    = $this->_parseAcceptWithQualifier($this->getHeaderLine('Accept-Language'));\n        $accept = [];\n\n        foreach ($raw as $languages) {\n            foreach ($languages as &$lang) {\n                if (strpos($lang, '_')) {\n                    $lang = str_replace('_', '-', $lang);\n                }\n                $lang = strtolower($lang);\n            }\n            $accept = array_merge($accept, $languages);\n        }\n        if ($language === null) {\n            return $accept;\n        }\n\n        return in_array(strtolower($language), $accept, true);\n    }\n\n    \/**\n     * Analysez les en-t\u00eates Accept* avec les options de qualificateur.\n     *\n     * Seuls les qualificatifs seront extraits, toutes les autres extensions accept\u00e9es seront\n     * jet\u00e9s car ils ne sont pas fr\u00e9quemment utilis\u00e9s.\n     *\/\n    protected function _parseAcceptWithQualifier(string $header): array\n    {\n        $accept  = [];\n        $headers = explode(',', $header);\n\n        foreach (array_filter($headers) as $value) {\n            $prefValue = '1.0';\n            $value     = trim($value);\n\n            $semiPos = strpos($value, ';');\n            if ($semiPos !== false) {\n                $params = explode(';', $value);\n                $value  = trim($params[0]);\n\n                foreach ($params as $param) {\n                    $qPos = strpos($param, 'q=');\n                    if ($qPos !== false) {\n                        $prefValue = substr($param, $qPos + 2);\n                    }\n                }\n            }\n\n            if (! isset($accept[$prefValue])) {\n                $accept[$prefValue] = [];\n            }\n            if ($prefValue) {\n                $accept[$prefValue][] = $value;\n            }\n        }\n        krsort($accept);\n\n        return $accept;\n    }\n\n    \/**\n     * Lire une valeur de requ\u00eate sp\u00e9cifique ou un chemin en pointill\u00e9s.\n     *\n     * Les d\u00e9veloppeurs sont encourag\u00e9s \u00e0 utiliser getQueryParams() s'ils ont besoin de tout le tableau de requ\u00eate,\n     * car il est compatible PSR-7, et cette m\u00e9thode ne l'est pas. En utilisant Hash::get(), vous pouvez \u00e9galement obtenir des param\u00e8tres uniques.\n     *\n     * ### Alternative PSR-7\n     *\n     * ```\n     * $value = Arr::get($request->getQueryParams(), 'Post.id');\n     * ```\n     *\n     * @param string|null $name    Le nom ou le chemin en pointill\u00e9 vers le param\u00e8tre de requ\u00eate ou null pour tout lire.\n     * @param mixed       $default La valeur par d\u00e9faut si le param\u00e8tre nomm\u00e9 n'est pas d\u00e9fini et que $name n'est pas nul.\n     *\n     * @return array|string|null Requ\u00eate de donn\u00e9es.\n     *\n     * @see ServerRequest::getQueryParams()\n     *\/\n    public function getQuery(?string $name = null, $default = null)\n    {\n        if ($name === null) {\n            return $this->query;\n        }\n\n        return Arr::get($this->query, $name, $default);\n    }\n\n    \/**\n     * Fournit un accesseur s\u00e9curis\u00e9 pour les donn\u00e9es de requ\u00eate. Permet\n     * vous permet d'utiliser des chemins compatibles Arr::get().\n     *\n     * ### Lecture des valeurs.\n     *\n     * ```\n     * \/\/ r\u00e9cup\u00e8re toutes les donn\u00e9es\n     * $request->getData();\n     *\n     * \/\/ Lire un champ sp\u00e9cifique.\n     * $request->getData('Post.title');\n     *\n     * \/\/ Avec une valeur par d\u00e9faut.\n     * $request->getData('Post.not there', 'default value');\n     * ```\n     *\n     * Lors de la lecture des valeurs, vous obtiendrez `null` pour les cl\u00e9s\/valeurs qui n'existent pas.\n     *\n     * Les d\u00e9veloppeurs sont encourag\u00e9s \u00e0 utiliser getParsedBody() s'ils ont besoin de tout le tableau de donn\u00e9es,\n     * car il est compatible PSR-7, et cette m\u00e9thode ne l'est pas. En utilisant Hash::get(), vous pouvez \u00e9galement obtenir des param\u00e8tres uniques.\n     *\n     * ### Alternative PSR-7\n     *\n     * ```\n     * $value = Arr::get($request->getParsedBody(), 'Post.id');\n     * ```\n     *\n     * @param string|null $name    Nom s\u00e9par\u00e9 par un point de la valeur \u00e0 lire. Ou null pour lire toutes les donn\u00e9es.\n     * @param mixed       $default Les donn\u00e9es par d\u00e9faut.\n     *\n     * @return mixed La valeur en cours de lecture.\n     *\/\n    public function getData(?string $name = null, $default = null)\n    {\n        if ($name === null) {\n            return $this->data;\n        }\n        if (! is_array($this->data) && $name) {\n            return $default;\n        }\n\n        \/** @psalm-suppress PossiblyNullArgument *\/\n        return Arr::get($this->data, $name, $default);\n    }\n\n    \/**\n     * Lire les donn\u00e9es de cookie \u00e0 partir des donn\u00e9es de cookie de la demande.\n     *\n     * @param string            $key     La cl\u00e9 ou le chemin en pointill\u00e9s que vous voulez lire.\n     * @param array|string|null $default La valeur par d\u00e9faut si le cookie n'est pas d\u00e9fini.\n     *\n     * @return array|string|null Soit la valeur du cookie, soit null si la valeur n'existe pas.\n     *\/\n    public function getCookie(string $key, $default = null)\n    {\n        return Arr::get($this->cookies, $key, $default);\n    }\n\n    \/**\n     * Obtenir une collection de cookies bas\u00e9e sur les cookies de la requ\u00eate\n     *\n     * La CookieCollection vous permet d'interagir avec les cookies de demande en utilisant\n     * Objets `\\BlitzPHP\\Http\\Cookie\\Cookie` et peut faire des cookies de demande de conversion\n     * dans les cookies de r\u00e9ponse plus facile.\n     *\n     * Cette m\u00e9thode cr\u00e9era une nouvelle collection de cookies \u00e0 chaque appel.\n     * Il s'agit d'une optimisation qui permet d'allouer moins d'objets jusqu'\u00e0\n     * plus la CookieCollection est n\u00e9cessaire. En g\u00e9n\u00e9ral, vous devriez pr\u00e9f\u00e9rer\n     * `getCookie()` et `getCookieParams()` sur cette m\u00e9thode. Utilisation d'une collection de cookies\n     * est id\u00e9al si vos cookies contiennent des donn\u00e9es complexes encod\u00e9es en JSON.\n     *\/\n    public function getCookieCollection(): CookieCollection\n    {\n        return CookieCollection::createFromServerRequest($this);\n    }\n\n    \/**\n     * Remplacez les cookies de la requ\u00eate par ceux contenus dans\n     * la CookieCollection fournie.\n     *\/\n    public function withCookieCollection(CookieCollection $cookies): self\n    {\n        $new    = clone $this;\n        $values = [];\n\n        foreach ($cookies as $cookie) {\n            $values[$cookie->getName()] = $cookie->getValue();\n        }\n        $new->cookies = $values;\n\n        return $new;\n    }\n\n    \/**\n     * Obtenez toutes les donn\u00e9es de cookie de la requ\u00eate.\n     *\n     * @return array Un tableau de donn\u00e9es de cookie.\n     *\/\n    public function getCookieParams(): array\n    {\n        return $this->cookies;\n    }\n\n    \/**\n     * Remplacez les cookies et obtenez une nouvelle instance de requ\u00eate.\n     *\n     * @param array $cookies Les nouvelles donn\u00e9es de cookie \u00e0 utiliser.\n     *\/\n    public function withCookieParams(array $cookies): self\n    {\n        $new          = clone $this;\n        $new->cookies = $cookies;\n\n        return $new;\n    }\n\n    \/**\n     * Obtenez les donn\u00e9es de corps de requ\u00eate analys\u00e9es.\n     *\n     * Si la requ\u00eate Content-Type est soit application\/x-www-form-urlencoded\n     * ou multipart\/form-data, et la m\u00e9thode de requ\u00eate est POST, ce sera le\n     * publier des donn\u00e9es. Pour les autres types de contenu, il peut s'agir de la requ\u00eate d\u00e9s\u00e9rialis\u00e9e\n     * corps.\n     *\n     * @return array|object|null Les param\u00e8tres de corps d\u00e9s\u00e9rialis\u00e9s, le cas \u00e9ch\u00e9ant.\n     *                           Il s'agira g\u00e9n\u00e9ralement d'un tableau.\n     *\/\n    public function getParsedBody()\n    {\n        return $this->data;\n    }\n\n    \/**\n     * Mettez \u00e0 jour le corps analys\u00e9 et obtenez une nouvelle instance.\n     *\n     * @param array|object|null $data Les donn\u00e9es de corps d\u00e9s\u00e9rialis\u00e9es. Cette volont\u00e9\n     *                                \u00eatre g\u00e9n\u00e9ralement dans un tableau ou un objet.\n     *\/\n    public function withParsedBody($data): self\n    {\n        $new       = clone $this;\n        $new->data = $data;\n\n        return $new;\n    }\n\n    \/**\n     * R\u00e9cup\u00e8re la version du protocole HTTP sous forme de cha\u00eene.\n     *\n     * @return string Version du protocole HTTP.\n     *\/\n    public function getProtocolVersion(): string\n    {\n        if ($this->protocol) {\n            return $this->protocol;\n        }\n\n        \/\/ Remplissez paresseusement ces donn\u00e9es car elles ne sont g\u00e9n\u00e9ralement pas utilis\u00e9es.\n        preg_match('\/^HTTP\\\/([\\d.]+)$\/', (string) $this->getEnv('SERVER_PROTOCOL'), $match);\n        $protocol = '1.1';\n        if (isset($match[1])) {\n            $protocol = $match[1];\n        }\n        $this->protocol = $protocol;\n\n        return $this->protocol;\n    }\n\n    \/**\n     * Renvoie une instance avec la version de protocole HTTP sp\u00e9cifi\u00e9e.\n     *\n     * La cha\u00eene de version DOIT contenir uniquement le num\u00e9ro de version HTTP (par exemple,\n     * \"1.1\", \"1.0\").\n     *\n     * @param string $version Version du protocole HTTP\n     *\/\n    public function withProtocolVersion($version): self\n    {\n        if (! preg_match('\/^(1\\.[01]|2)$\/', $version)) {\n            throw new InvalidArgumentException(\"Unsupported protocol version '{$version}' provided\");\n        }\n        $new           = clone $this;\n        $new->protocol = $version;\n\n        return $new;\n    }\n\n    \/**\n     * Obtenez une valeur \u00e0 partir des donn\u00e9es d'environnement de la demande.\n     * Se replier sur env() si la cl\u00e9 n'est pas d\u00e9finie dans la propri\u00e9t\u00e9 $environment.\n     *\n     * @param string      $key     La cl\u00e9 \u00e0 partir de laquelle vous voulez lire.\n     * @param string|null $default Valeur par d\u00e9faut lors de la tentative de r\u00e9cup\u00e9ration d'un environnement\n     *                             valeur de la variable qui n'existe pas.\n     *\n     * @return string|null Soit la valeur de l'environnement, soit null si la valeur n'existe pas.\n     *\/\n    public function getEnv(string $key, ?string $default = null): ?string\n    {\n        $key = strtoupper($key);\n        if (! array_key_exists($key, $this->_environment)) {\n            $this->_environment[$key] = env($key);\n        }\n\n        return $this->_environment[$key] !== null ? (string) $this->_environment[$key] : $default;\n    }\n\n    \/**\n     * Mettez \u00e0 jour la demande avec un nouvel \u00e9l\u00e9ment de donn\u00e9es d'environnement.\n     *\n     * Renvoie un objet de requ\u00eate mis \u00e0 jour. Cette m\u00e9thode retourne\n     * un *nouvel* objet de requ\u00eate et ne mute pas la requ\u00eate sur place.\n     *\/\n    public function withEnv(string $key, string $value): self\n    {\n        $new                     = clone $this;\n        $new->_environment[$key] = $value;\n        $new->clearDetectorCache();\n\n        return $new;\n    }\n\n    \/**\n     * Autoriser uniquement certaines m\u00e9thodes de requ\u00eate HTTP, si la m\u00e9thode de requ\u00eate ne correspond pas\n     * une erreur 405 s'affichera et l'en-t\u00eate de r\u00e9ponse \"Autoriser\" requis sera d\u00e9fini.\n     *\n     * Exemple:\n     *\n     * $this->request->allowMethod('post');\n     * ou alors\n     * $this->request->allowMethod(['post', 'delete']);\n     *\n     * Si la requ\u00eate est GET, l'en-t\u00eate de r\u00e9ponse \"Autoriser : POST, SUPPRIMER\" sera d\u00e9fini\n     * et une erreur 405 sera renvoy\u00e9e.\n     *\n     * @param string|string[] $methods M\u00e9thodes de requ\u00eate HTTP autoris\u00e9es.\n     *\n     * @throws HttpException\n     *\/\n    public function allowMethod($methods): bool\n    {\n        $methods = (array) $methods;\n\n        foreach ($methods as $method) {\n            if ($this->is($method)) {\n                return true;\n            }\n        }\n        $allowed = strtoupper(implode(', ', $methods));\n\n        throw HttpException::methodNotAllowed($allowed);\n    }\n\n    \/**\n     * Mettez \u00e0 jour la demande avec un nouvel \u00e9l\u00e9ment de donn\u00e9es de demande.\n     *\n     * Renvoie un objet de requ\u00eate mis \u00e0 jour. Cette m\u00e9thode retourne\n     * un *nouvel* objet de requ\u00eate et ne mute pas la requ\u00eate sur place.\n     *\n     * Utilisez `withParsedBody()` si vous devez remplacer toutes les donn\u00e9es de la requ\u00eate.\n     *\n     * @param string $name  Le chemin s\u00e9par\u00e9 par des points o\u00f9 ins\u00e9rer $value.\n     * @param mixed  $value\n     *\/\n    public function withData(string $name, $value): self\n    {\n        $copy = clone $this;\n\n        if (is_array($copy->data)) {\n            $copy->data = Arr::insert($copy->data, $name, $value);\n        }\n\n        return $copy;\n    }\n\n    \/**\n     * Mettre \u00e0 jour la demande en supprimant un \u00e9l\u00e9ment de donn\u00e9es.\n     *\n     * Renvoie un objet de requ\u00eate mis \u00e0 jour. Cette m\u00e9thode retourne\n     * un *nouvel* objet de requ\u00eate et ne mute pas la requ\u00eate sur place.\n     *\n     * @param string $name Le chemin s\u00e9par\u00e9 par des points \u00e0 supprimer.\n     *\/\n    public function withoutData(string $name): self\n    {\n        $copy = clone $this;\n\n        if (is_array($copy->data)) {\n            $copy->data = Arr::remove($copy->data, $name);\n        }\n\n        return $copy;\n    }\n\n    \/**\n     * Mettre \u00e0 jour la requ\u00eate avec un nouveau param\u00e8tre de routage\n     *\n     * Renvoie un objet de requ\u00eate mis \u00e0 jour. Cette m\u00e9thode retourne\n     * un *nouvel* objet de requ\u00eate et ne mute pas la requ\u00eate sur place.\n     *\n     * @param string $name  Le chemin s\u00e9par\u00e9 par des points o\u00f9 ins\u00e9rer $value.\n     * @param mixed  $value\n     *\/\n    public function withParam(string $name, $value): self\n    {\n        $copy         = clone $this;\n        $copy->params = Arr::insert($copy->params, $name, $value);\n\n        return $copy;\n    }\n\n    \/**\n     * Acc\u00e9dez en toute s\u00e9curit\u00e9 aux valeurs dans $this->params.\n     *\n     * @param mixed|null $default\n     *\/\n    public function getParam(string $name, $default = null)\n    {\n        return Arr::get($this->params, $name, $default);\n    }\n\n    \/**\n     * Renvoie une instance avec l'attribut de requ\u00eate sp\u00e9cifi\u00e9.\n     *\n     * @param string $name  Le nom de l'attribut.\n     * @param mixed  $value La valeur de l'attribut.\n     *\/\n    public function withAttribute($name, $value): self\n    {\n        $new = clone $this;\n        if (in_array($name, $this->emulatedAttributes, true)) {\n            $new->{$name} = $value;\n        } else {\n            $new->attributes[$name] = $value;\n        }\n\n        return $new;\n    }\n\n    \/**\n     * Renvoie une instance sans l'attribut de requ\u00eate sp\u00e9cifi\u00e9.\n     *\n     * @param string $name Le nom de l'attribut.\n     *\n     * @throws InvalidArgumentException\n     *\/\n    public function withoutAttribute($name): self\n    {\n        $new = clone $this;\n        if (in_array($name, $this->emulatedAttributes, true)) {\n            throw new InvalidArgumentException(\n                \"You cannot unset '{$name}'. It is a required BlitzPHP attribute.\"\n            );\n        }\n        unset($new->attributes[$name]);\n\n        return $new;\n    }\n\n    \/**\n     * Lire un attribut de la requ\u00eate ou obtenir la valeur par d\u00e9faut\n     *\n     * @param string     $name    Le nom de l'attribut.\n     * @param mixed|null $default La valeur par d\u00e9faut si l'attribut n'a pas \u00e9t\u00e9 d\u00e9fini.\n     *\n     * @return mixed\n     *\/\n    public function getAttribute($name, $default = null)\n    {\n        if (in_array($name, $this->emulatedAttributes, true)) {\n            if ($name === 'here') {\n                return $this->base . $this->uri->getPath();\n            }\n\n            return $this->{$name};\n        }\n        if (array_key_exists($name, $this->attributes)) {\n            return $this->attributes[$name];\n        }\n\n        return $default;\n    }\n\n    \/**\n     * Obtenez tous les attributs de la requ\u00eate.\n     *\n     * Cela inclura les attributs params, webroot, base et here fournis par BlitzPHP.\n     *\/\n    public function getAttributes(): array\n    {\n        $emulated = [\n            'params'  => $this->params,\n            'webroot' => $this->webroot,\n            'base'    => $this->base,\n            'here'    => $this->base . $this->uri->getPath(),\n        ];\n\n        return $this->attributes + $emulated;\n    }\n\n    \/**\n     * Obtenez le fichier t\u00e9l\u00e9charg\u00e9 \u00e0 partir d'un chemin en pointill\u00e9s.\n     *\n     * @param string $path Le chemin s\u00e9par\u00e9 par des points vers le fichier que vous voulez.\n     *\n     * @return UploadedFileInterface|UploadedFileInterface[]|null\n     *\/\n    public function getUploadedFile(string $path)\n    {\n        $file = Arr::get($this->uploadedFiles, $path);\n        if (is_array($file)) {\n            foreach ($file as $f) {\n                if (! ($f instanceof UploadedFile)) {\n                    return null;\n                }\n            }\n\n            return $file;\n        }\n\n        if (! ($file instanceof UploadedFile)) {\n            return null;\n        }\n\n        return $file;\n    }\n\n    \/**\n     * Obtenez le tableau des fichiers t\u00e9l\u00e9charg\u00e9s \u00e0 partir de la requ\u00eate.\n     *\/\n    public function getUploadedFiles(): array\n    {\n        return $this->uploadedFiles;\n    }\n\n    \/**\n     * Mettez \u00e0 jour la demande en rempla\u00e7ant les fichiers et en cr\u00e9ant une nouvelle instance.\n     *\n     * @param array $uploadedFiles Un tableau d'objets de fichiers t\u00e9l\u00e9charg\u00e9s.\n     *\n     * @throws InvalidArgumentException lorsque $files contient un objet invalide.\n     *\/\n    public function withUploadedFiles(array $uploadedFiles): self\n    {\n        $this->validateUploadedFiles($uploadedFiles, '');\n        $new                = clone $this;\n        $new->uploadedFiles = $uploadedFiles;\n\n        return $new;\n    }\n\n    \/**\n     * Validez de mani\u00e8re r\u00e9cursive les donn\u00e9es de fichier t\u00e9l\u00e9charg\u00e9es.\n     *\n     * @param array  $uploadedFiles Le nouveau tableau de fichiers \u00e0 valider.\n     * @param string $path          Le chemin jusqu'ici.\n     *\n     * @throws InvalidArgumentException Si des \u00e9l\u00e9ments feuilles ne sont pas des fichiers valides.\n     *\/\n    protected function validateUploadedFiles(array $uploadedFiles, string $path): void\n    {\n        foreach ($uploadedFiles as $key => $file) {\n            if (is_array($file)) {\n                $this->validateUploadedFiles($file, $key . '.');\n\n                continue;\n            }\n\n            if (! $file instanceof UploadedFileInterface) {\n                throw new InvalidArgumentException(\"Invalid file at '{$path}{$key}'\");\n            }\n        }\n    }\n\n    \/**\n     * Obtient le corps du message.\n     *\/\n    public function getBody(): StreamInterface\n    {\n        return $this->stream;\n    }\n\n    \/**\n     * Renvoie une instance avec le corps de message sp\u00e9cifi\u00e9.\n     *\/\n    public function withBody(StreamInterface $body): self\n    {\n        $new         = clone $this;\n        $new->stream = $body;\n\n        return $new;\n    }\n\n    \/**\n     * R\u00e9cup\u00e8re l'instance d'URI.\n     *\/\n    public function getUri(): UriInterface\n    {\n        return $this->uri;\n    }\n\n    \/**\n     * Renvoie une instance avec l'uri sp\u00e9cifi\u00e9\n     *\n     * *Attention* Remplacer l'Uri ne mettra pas \u00e0 jour la `base`, `webroot`,\n     * et les attributs `url`.\n     *\n     * @param bool $preserveHost Indique si l'h\u00f4te doit \u00eatre conserv\u00e9.\n     *\/\n    public function withUri(UriInterface $uri, $preserveHost = false): self\n    {\n        $new      = clone $this;\n        $new->uri = $uri;\n\n        if ($preserveHost && $this->hasHeader('Host')) {\n            return $new;\n        }\n\n        $host = $uri->getHost();\n        if (! $host) {\n            return $new;\n        }\n        $port = $uri->getPort();\n        if ($port) {\n            $host .= ':' . $port;\n        }\n        $new->_environment['HTTP_HOST'] = $host;\n\n        return $new;\n    }\n\n    \/**\n     * Cr\u00e9ez une nouvelle instance avec une cible de demande sp\u00e9cifique.\n     *\n     * Vous pouvez utiliser cette m\u00e9thode pour \u00e9craser la cible de la demande qui est\n     * d\u00e9duit de l'Uri de la requ\u00eate. Cela vous permet \u00e9galement de modifier la demande\n     * la forme de la cible en une forme absolue, une forme d'autorit\u00e9 ou une forme d'ast\u00e9risque\n     *\n     * @see https:\/\/tools.ietf.org\/html\/rfc7230#section-2.7 (pour les diff\u00e9rentes formes de demande-cible autoris\u00e9es dans les messages de demande)\n     *\n     * @param string $requestTarget La cible de la requ\u00eate.\n     * @psalm-suppress MoreSpecificImplementedParamType\n     *\/\n    public function withRequestTarget($requestTarget): self\n    {\n        $new                = clone $this;\n        $new->requestTarget = $requestTarget;\n\n        return $new;\n    }\n\n    \/**\n     * R\u00e9cup\u00e8re la cible de la requ\u00eate.\n     *\n     * R\u00e9cup\u00e8re la cible de la demande du message soit telle qu'elle a \u00e9t\u00e9 demand\u00e9e,\n     * ou comme d\u00e9fini avec `withRequestTarget()`. Par d\u00e9faut, cela renverra le\n     * chemin relatif de l'application sans r\u00e9pertoire de base et la cha\u00eene de requ\u00eate\n     * d\u00e9fini dans l'environnement SERVER.\n     *\/\n    public function getRequestTarget(): string\n    {\n        if ($this->requestTarget !== null) {\n            return $this->requestTarget;\n        }\n\n        $target = $this->uri->getPath();\n        if ($this->uri->getQuery()) {\n            $target .= '?' . $this->uri->getQuery();\n        }\n\n        if (empty($target)) {\n            $target = '\/';\n        }\n\n        return $target;\n    }\n\n    \/**\n     * R\u00e9cup\u00e8re le chemin de la requ\u00eate en cours.\n     *\/\n    public function getPath(): string\n    {\n        if ($this->requestTarget === null) {\n            return $this->uri->getPath();\n        }\n\n        [$path] = explode('?', $this->requestTarget);\n\n        return $path;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,2,null,null,2,null,null,null,0,null,0,null,null,2,null,2,null,null,2,null,2,2,2,null,null,2,0,0,null,2,null,2,null,2,2,2,2,2,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,0,0,null,null,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,0,0,null,null,0,0,null,null,null,0,null,null,0,null,null,null,0,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,0,null,null,0,null,null,0,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,null,0,null,null,0,0,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,0,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,0,null,0,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,0,null,0,null,0,0,null,null,0,null,0,null,null,null,null,null,0,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,0,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,0,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,null,2,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,null,null,0,null,0,null,0,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,null,null]},{"name":"src\\Http\\Session.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Http;\n\nuse BlitzPHP\\Core\\App;\nuse BlitzPHP\\Utilities\\Arr;\nuse InvalidArgumentException;\nuse RuntimeException;\nuse SessionHandlerInterface;\n\n\/**\n * Cette classe est un wrapper pour les fonctions de session PHP natives. Il offre\n * plusieurs valeurs par d\u00e9faut pour la configuration de session la plus courante\n * via des gestionnaires externes et aide \u00e0 utiliser la session dans la CLI sans aucun avertissement.\n *\n * Les sessions peuvent \u00eatre cr\u00e9\u00e9es \u00e0 partir des valeurs par d\u00e9faut en utilisant `Session ::create()` ou vous pouvez obtenir\n * une instance d'une nouvelle session en instanciant simplement cette classe et en passant le\n * options que vous souhaitez utiliser.\n *\n * Lorsque des options sp\u00e9cifiques sont omises, cette classe prendra ses valeurs par d\u00e9faut de la configuration\n * valeurs des directives `session.*` dans php.ini. Cette classe modifiera \u00e9galement ces\n * directives lorsque des valeurs de configuration sont fournies.\n *\n * @credit <a href=\"http:\/\/https:\/\/api.cakephp.org\/4.3\/namespace-Cake.Http.Session.html\">CakePHP - Http\\Session<\/a>\n *\/\n\/** @phpstan-consistent-constructor *\/\nclass Session\n{\n    \/**\n     * L'instance du gestionnaire de session utilis\u00e9e comme moteur pour conserver les donn\u00e9es de session.\n     *\n     * @var SessionHandlerInterface\n     *\/\n    protected $_engine;\n\n    \/**\n     * Indique si les sessions ont d\u00e9j\u00e0 commenc\u00e9\n     *\n     * @var bool\n     *\/\n    protected $_started;\n\n    \/**\n     * La dur\u00e9e en secondes pendant laquelle la session sera valide\n     *\n     * @var int\n     *\/\n    protected $_lifetime;\n\n    \/**\n     * Si cette session s'ex\u00e9cute dans un environnement CLI\n     *\n     * @var bool\n     *\/\n    protected $_isCLI = false;\n\n    \/**\n     * Renvoie une nouvelle instance d'une session apr\u00e8s avoir cr\u00e9\u00e9 un bundle de configuration pour celle-ci.\n     * Cette fonction permet d'avoir un tableau d'options qui sera utilis\u00e9 pour configurer la session\n     * et le gestionnaire \u00e0 utiliser. La cl\u00e9 la plus importante dans le tableau de configuration est\n     * `defaults`, qui indique l'ensemble des configurations dont h\u00e9riter, les\n     * les valeurs par d\u00e9faut sont :\n     *\n     * - php : utilisez simplement la session telle que configur\u00e9e dans php.ini\n     * - cache : utilisez le syst\u00e8me de mise en cache de BlitzPHP comme stockage pour la session, vous aurez besoin\n     * pour passer la cl\u00e9 `config` avec le nom d'un moteur de cache d\u00e9j\u00e0 configur\u00e9.\n     * - base de donn\u00e9es : Utilisez l'ORM BlitzPHP pour persister et g\u00e9rer les sessions. Par d\u00e9faut, cela n\u00e9cessite\n     * une table dans votre base de donn\u00e9es nomm\u00e9e `sessions` ou une cl\u00e9 `model` dans la configuration\n     * pour indiquer quel objet Table utiliser.\n     * - blitz : Utilisez des fichiers pour stocker les sessions, mais laissez BlitzPHP les g\u00e9rer et d\u00e9cider\n     * o\u00f9 les stocker.\n     *\n     * La liste compl\u00e8te des options suit :\n     *\n     * - default : soit 'php', 'database', 'cache' ou 'blitz' comme expliqu\u00e9 ci-dessus.\n     * - handler : un tableau contenant la configuration du gestionnaire\n     * - ini : une liste de directives php.ini \u00e0 d\u00e9finir avant le d\u00e9marrage de la session.\n     * - timeout : Le temps en minutes pendant lequel la session doit rester active\n     *\/\n    public static function create(array $sessionConfig = [])\n    {\n        if (isset($sessionConfig['defaults'])) {\n            $defaults = static::_defaultConfig($sessionConfig['defaults']);\n            if ($defaults) {\n                $sessionConfig = Arr::merge($defaults, $sessionConfig);\n            }\n        }\n\n        if (\n            ! isset($sessionConfig['ini']['session.cookie_secure'])\n            && env('HTTPS')\n            && ini_get('session.cookie_secure') !== 1\n        ) {\n            $sessionConfig['ini']['session.cookie_secure'] = 1;\n        }\n\n        if (\n            ! isset($sessionConfig['ini']['session.name'])\n            && isset($sessionConfig['cookie'])\n        ) {\n            $sessionConfig['ini']['session.name'] = $sessionConfig['cookie'];\n        }\n\n        if (! isset($sessionConfig['ini']['session.use_strict_mode']) && ini_get('session.use_strict_mode') !== 1) {\n            $sessionConfig['ini']['session.use_strict_mode'] = 1;\n        }\n\n        if (! isset($sessionConfig['ini']['session.cookie_httponly']) && ini_get('session.cookie_httponly') !== 1) {\n            $sessionConfig['ini']['session.cookie_httponly'] = 1;\n        }\n\n        return new static($sessionConfig);\n    }\n\n    \/**\n     * Obtenez l'une des configurations de session par d\u00e9faut pr\u00e9d\u00e9finies.\n     *\n     * @return array|false\n     *\/\n    protected static function _defaultConfig(string $name)\n    {\n        $tmp      = defined('TEMP_PATH') ? TEMP_PATH : sys_get_temp_dir() . DIRECTORY_SEPARATOR;\n        $defaults = [\n            'php' => [\n                'ini' => [\n                    'session.use_trans_sid' => 0,\n                ],\n            ],\n            'blitz' => [\n                'ini' => [\n                    'session.use_trans_sid'     => 0,\n                    'session.serialize_handler' => 'php',\n                    'session.use_cookies'       => 1,\n                    'session.save_path'         => $tmp . 'sessions',\n                    'session.save_handler'      => 'files',\n                ],\n            ],\n            'cache' => [\n                'ini' => [\n                    'session.use_trans_sid' => 0,\n                    'session.use_cookies'   => 1,\n                ],\n                'handler' => [\n                    'engine' => 'CacheSession',\n                    'config' => 'default',\n                ],\n            ],\n            'database' => [\n                'ini' => [\n                    'session.use_trans_sid'     => 0,\n                    'session.use_cookies'       => 1,\n                    'session.serialize_handler' => 'php',\n                ],\n                'handler' => [\n                    'engine' => 'DatabaseSession',\n                ],\n            ],\n        ];\n\n        if (isset($defaults[$name])) {\n            if (\n                PHP_VERSION_ID >= 70300\n                && ($name !== 'php' || empty(ini_get('session.cookie_samesite')))\n            ) {\n                $defaults['php']['ini']['session.cookie_samesite'] = 'Lax';\n            }\n\n            return $defaults[$name];\n        }\n\n        return false;\n    }\n\n    \/**\n     * Constructor.\n     *\n     * ### Configuration:\n     *\n     * - timeout : dur\u00e9e en minutes pendant laquelle la session doit \u00eatre valide.\n     * - cookiePath : Le chemin d'URL pour lequel le cookie de session est d\u00e9fini. Cartes vers le\n     * `session.cookie_path` configuration php.ini. Par d\u00e9faut, le chemin de base de l'application.\n     * - ini : Une liste de directives php.ini \u00e0 modifier avant le d\u00e9marrage de la session.\n     * - handler : Un tableau contenant au moins la cl\u00e9 `engine`. A utiliser comme s\u00e9ance\n     * moteur de persistance des donn\u00e9es. Le reste des cl\u00e9s du tableau sera transmis comme\n     * le tableau de configuration du moteur. Vous pouvez d\u00e9finir la cl\u00e9 `engine` sur une cl\u00e9 d\u00e9j\u00e0\n     * objet gestionnaire de session instanci\u00e9.\n     *\n     * @param array<string, mixed> $config La configuration \u00e0 appliquer \u00e0 cet objet de session\n     *\/\n    public function __construct(array $config = [])\n    {\n        $config += [\n            'timeout' => null,\n            'cookie'  => null,\n            'ini'     => [],\n            'handler' => [],\n        ];\n\n        if ($config['timeout']) {\n            $config['ini']['session.gc_maxlifetime'] = 60 * $config['timeout'];\n        }\n\n        if ($config['cookie']) {\n            $config['ini']['session.name'] = $config['cookie'];\n        }\n\n        if (! isset($config['ini']['session.cookie_path'])) {\n            $cookiePath                           = empty($config['cookiePath']) ? '\/' : $config['cookiePath'];\n            $config['ini']['session.cookie_path'] = $cookiePath;\n        }\n\n        $this->options($config['ini']);\n\n        if (! empty($config['handler'])) {\n            $class = $config['handler']['engine'];\n            unset($config['handler']['engine']);\n            $this->engine($class, $config['handler']);\n        }\n\n        $this->_lifetime = (int) ini_get('session.gc_maxlifetime');\n        $this->_isCLI    = (PHP_SAPI === 'cli' || PHP_SAPI === 'phpdbg');\n        session_register_shutdown();\n    }\n\n    \/**\n     * D\u00e9finit l'instance du gestionnaire de session \u00e0 utiliser pour cette session.\n     * Si une cha\u00eene est pass\u00e9e pour le premier argument, elle sera trait\u00e9e comme le\n     * le nom de la classe et le deuxi\u00e8me argument seront pass\u00e9s comme premier argument\n     * dans le constructeur.\n     *\n     * Si une instance de SessionHandlerInterface est fournie comme premier argument,\n     * le gestionnaire y sera d\u00e9fini.\n     *\n     * Si aucun argument n'est pass\u00e9, il renverra l'instance de gestionnaire actuellement configur\u00e9e\n     * ou null s'il n'en existe pas.\n     *\n     * @param SessionHandlerInterface|string|null $class   Le gestionnaire de session \u00e0 utiliser\n     * @param array<string, mixed>                $options les options \u00e0 passer au constructeur SessionHandler\n     *\n     * @throws InvalidArgumentException\n     *\/\n    public function engine($class = null, array $options = []): ?SessionHandlerInterface\n    {\n        if ($class === null) {\n            return $this->_engine;\n        }\n        if ($class instanceof SessionHandlerInterface) {\n            return $this->setEngine($class);\n        }\n        $className = App::className($class, 'Http\/Session');\n\n        if (! $className) {\n            throw new InvalidArgumentException(\n                sprintf('The class \"%s\" does not exist and cannot be used as a session engine', $class)\n            );\n        }\n\n        $handler = new $className($options);\n        if (! ($handler instanceof SessionHandlerInterface)) {\n            throw new InvalidArgumentException(\n                'The chosen SessionHandler does not implement SessionHandlerInterface, it cannot be used as an engine.'\n            );\n        }\n\n        return $this->setEngine($handler);\n    }\n\n    \/**\n     * D\u00e9finissez la propri\u00e9t\u00e9 du moteur et mettez \u00e0 jour le gestionnaire de session en PHP.\n     *\/\n    protected function setEngine(SessionHandlerInterface $handler): SessionHandlerInterface\n    {\n        if (! headers_sent() && session_status() !== \\PHP_SESSION_ACTIVE) {\n            session_set_save_handler($handler, false);\n        }\n\n        return $this->_engine = $handler;\n    }\n\n    \/**\n     * Appelle ini_set pour chacune des cl\u00e9s dans `$options` et les d\u00e9finit\n     * \u00e0 la valeur respective dans le tableau pass\u00e9.\n     *\n     * ### Example:\n     *\n     * ```\n     * $session->options(['session.use_cookies' => 1]);\n     * ```\n     *\n     * @param array<string, mixed> $options Options ini \u00e0 d\u00e9finir.\n     *\n     * @throws RuntimeException si aucune directive n'a pu \u00eatre d\u00e9finie\n     *\/\n    public function options(array $options): void\n    {\n        if (session_status() === \\PHP_SESSION_ACTIVE || headers_sent()) {\n            return;\n        }\n\n        foreach ($options as $setting => $value) {\n            if (ini_set($setting, (string) $value) === false) {\n                throw new RuntimeException(\n                    sprintf('Unable to configure the session, setting %s failed.', $setting)\n                );\n            }\n        }\n    }\n\n    \/**\n     * D\u00e9marre la session.\n     *\n     * @throws RuntimeException si la session a d\u00e9j\u00e0 commenc\u00e9\n     *\n     * @return bool Vrai si la session a \u00e9t\u00e9 d\u00e9marr\u00e9e\n     *\/\n    public function start(): bool\n    {\n        if ($this->_started) {\n            return true;\n        }\n\n        if ($this->_isCLI) {\n            $_SESSION = [];\n            $this->id('cli');\n\n            return $this->_started = true;\n        }\n\n        if (session_status() === \\PHP_SESSION_ACTIVE) {\n            throw new RuntimeException('Session was already started');\n        }\n\n        if (ini_get('session.use_cookies') && headers_sent()) {\n            return false;\n        }\n\n        if (! session_start()) {\n            throw new RuntimeException('Could not start the session');\n        }\n\n        $this->_started = true;\n\n        if ($this->_timedOut()) {\n            $this->destroy();\n\n            return $this->start();\n        }\n\n        return $this->_started;\n    }\n\n    \/**\n     * \u00c9crire des donn\u00e9es et fermer la session\n     *\/\n    public function close(): bool\n    {\n        if (! $this->_started) {\n            return true;\n        }\n\n        if ($this->_isCLI) {\n            $this->_started = false;\n\n            return true;\n        }\n\n        if (! session_write_close()) {\n            throw new RuntimeException('Could not close the session');\n        }\n\n        $this->_started = false;\n\n        return true;\n    }\n\n    \/**\n     * D\u00e9terminez si la session a d\u00e9j\u00e0 \u00e9t\u00e9 d\u00e9marr\u00e9e..\n     *\/\n    public function started(): bool\n    {\n        return $this->_started || session_status() === \\PHP_SESSION_ACTIVE;\n    }\n\n    \/**\n     * Renvoie true si le nom de variable donn\u00e9 est d\u00e9fini dans la session.\n     *\/\n    public function check(?string $name = null): bool\n    {\n        if ($this->_hasSession() && ! $this->started()) {\n            $this->start();\n        }\n\n        if (! isset($_SESSION)) {\n            return false;\n        }\n\n        if ($name === null) {\n            return (bool) $_SESSION;\n        }\n\n        return Arr::get($_SESSION, $name) !== null;\n    }\n\n    \/**\n     * Renvoie la variable de session donn\u00e9e, ou toutes, si aucun param\u00e8tre n'est donn\u00e9.\n     *\n     * @param string|null $name    Le nom de la variable de session (ou un chemin tel qu'envoy\u00e9 \u00e0 Hash.extract)\n     * @param mixed       $default La valeur de retour lorsque le chemin n'existe pas\n     *\n     * @return mixed|null La valeur de la variable de session, ou la valeur par d\u00e9faut si une session\n     *                    n'est pas disponible, ne peut pas \u00eatre d\u00e9marr\u00e9 ou \u00e0 condition que $name ne soit pas trouv\u00e9 dans la session.\n     *\/\n    public function read(?string $name = null, $default = null)\n    {\n        if ($this->_hasSession() && ! $this->started()) {\n            $this->start();\n        }\n\n        if (! isset($_SESSION)) {\n            return $default;\n        }\n\n        if ($name === null) {\n            return $_SESSION ?: [];\n        }\n\n        return Arr::get($_SESSION, $name, $default);\n    }\n\n    \/**\n     * Renvoie la variable de session donn\u00e9e ou l\u00e8ve une exception si elle n'est pas trouv\u00e9e.\n     *\n     * @param string $name Le nom de la variable de session (ou un chemin tel qu'envoy\u00e9 \u00e0 Arr.extract)\n     *\n     * @throws RuntimeException\n     *\n     * @return mixed|null\n     *\/\n    public function readOrFail(string $name)\n    {\n        if (! $this->check($name)) {\n            throw new RuntimeException(sprintf('Expected session key \"%s\" not found.', $name));\n        }\n\n        return $this->read($name);\n    }\n\n    \/**\n     * Lit et supprime une variable de la session.\n     *\n     * @param string $name La cl\u00e9 \u00e0 lire et \u00e0 supprimer (ou un chemin tel qu'envoy\u00e9 \u00e0 Hash.extract).\n     *\n     * @return mixed|null La valeur de la variable de session, null si session non disponible,\n     *                    session non d\u00e9marr\u00e9e ou nom fourni introuvable dans la session.\n     *\/\n    public function consume(string $name)\n    {\n        if (empty($name)) {\n            return null;\n        }\n        $value = $this->read($name);\n        if ($value !== null) {\n            \/** @psalm-suppress InvalidScalarArgument *\/\n            $this->_overwrite($_SESSION, Arr::remove($_SESSION, $name));\n        }\n\n        return $value;\n    }\n\n    \/**\n     * \u00c9crit la valeur dans le nom de variable de session donn\u00e9.\n     *\n     * @param array|string $name  Nom de la variable\n     * @param mixed|null   $value\n     *\/\n    public function write($name, $value = null): void\n    {\n        if (! $this->started()) {\n            $this->start();\n        }\n\n        if (! is_array($name)) {\n            $name = [$name => $value];\n        }\n\n        $data = $_SESSION ?? [];\n\n        foreach ($name as $key => $val) {\n            $data = Arr::insert($data, $key, $val);\n        }\n\n        \/** @psalm-suppress PossiblyNullArgument *\/\n        $this->_overwrite($_SESSION, $data);\n    }\n\n    \/**\n     * Renvoie l'identifiant de la session.\n     * L'appel de cette m\u00e9thode ne d\u00e9marrera pas automatiquement la session. Vous devrez peut-\u00eatre manuellement\n     * revendiquer une session d\u00e9marr\u00e9e.\n     *\n     * En y passant un identifiant, vous pouvez \u00e9galement remplacer l'identifiant de session si la session\n     * n'a pas encore \u00e9t\u00e9 lanc\u00e9.\n     * Notez que selon le gestionnaire de session, tous les caract\u00e8res ne sont pas autoris\u00e9s\n     * dans l'identifiant de session. Par exemple, le gestionnaire de session de fichiers autorise uniquement\n     * caract\u00e8res dans la plage a-z A-Z 0-9 , (virgule) et - (moins).\n     *\n     * @param string|null $id Id pour remplacer l'identifiant de la session en cours\n     *\/\n    public function id(?string $id = null): string\n    {\n        if ($id !== null && ! headers_sent()) {\n            session_id($id);\n        }\n\n        return session_id();\n    }\n\n    \/**\n     * Supprime une variable de la session.\n     *\/\n    public function delete(string $name): void\n    {\n        if ($this->check($name)) {\n            \/** @psalm-suppress InvalidScalarArgument *\/\n            $this->_overwrite($_SESSION, Arr::remove($_SESSION, $name));\n        }\n    }\n\n    \/**\n     * Utilis\u00e9 pour \u00e9crire de nouvelles donn\u00e9es dans _SESSION, car PHP n'aime pas que nous d\u00e9finissions la variable _SESSION elle-m\u00eame.\n     *\n     * @param array $old Ensemble d'anciennes variables => valeurs\n     * @param array $new Nouvel ensemble de variable => valeur\n     *\/\n    protected function _overwrite(array &$old, array $new): void\n    {\n        if (! empty($old)) {\n            foreach ($old as $key => $var) {\n                if (! isset($new[$key])) {\n                    unset($old[$key]);\n                }\n            }\n        }\n\n        foreach ($new as $key => $var) {\n            $old[$key] = $var;\n        }\n    }\n\n    \/**\n     * M\u00e9thode d'assistance pour d\u00e9truire les sessions invalides.\n     *\/\n    public function destroy(): void\n    {\n        if ($this->_hasSession() && ! $this->started()) {\n            $this->start();\n        }\n\n        if (! $this->_isCLI && session_status() === \\PHP_SESSION_ACTIVE) {\n            session_destroy();\n        }\n\n        $_SESSION       = [];\n        $this->_started = false;\n    }\n\n    \/**\n     * Efface la session.\n     *\n     * En option, il efface \u00e9galement l'identifiant de session et renouvelle la session.\n     *\n     * @param bool $renew Si la session doit \u00e9galement \u00eatre renouvel\u00e9e. La valeur par d\u00e9faut est false.\n     *\/\n    public function clear(bool $renew = false): void\n    {\n        $_SESSION = [];\n        if ($renew) {\n            $this->renew();\n        }\n    }\n\n    \/**\n     * Retourne si une session existe\n     *\/\n    protected function _hasSession(): bool\n    {\n        return ! ini_get('session.use_cookies')\n            || isset($_COOKIE[session_name()])\n            || $this->_isCLI\n            || (ini_get('session.use_trans_sid') && isset($_GET[session_name()]));\n    }\n\n    \/**\n     * Red\u00e9marre cette session.\n     *\/\n    public function renew(): void\n    {\n        if (! $this->_hasSession() || $this->_isCLI) {\n            return;\n        }\n\n        $this->start();\n        $params = session_get_cookie_params();\n        setcookie(\n            session_name(),\n            '',\n            time() - 42000,\n            $params['path'],\n            $params['domain'],\n            $params['secure'],\n            $params['httponly']\n        );\n\n        if (session_id() !== '') {\n            session_regenerate_id(true);\n        }\n    }\n\n    \/**\n     * Renvoie true si la session n'est plus valide car la derni\u00e8re fois qu'elle a \u00e9t\u00e9\n     * l'acc\u00e8s s'est fait apr\u00e8s le d\u00e9lai d'attente configur\u00e9.\n     *\/\n    protected function _timedOut(): bool\n    {\n        $time   = $this->read('Config.time');\n        $result = false;\n\n        $checkTime = $time !== null && $this->_lifetime > 0;\n        if ($checkTime && (time() - (int) $time > $this->_lifetime)) {\n            $result = true;\n        }\n\n        $this->write('Config.time', time());\n\n        return $result;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,2,null,null,null,2,null,null,null,2,2,null,null,2,null,null,2,0,0,null,null,2,2,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,null,null,null,0,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,0,null,0,null,null,null,0,null,null,null,0,null,null,null,0,null,null,0,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,0,null,0,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,0,null,0,null,null,0,null,0,null,null,null]},{"name":"src\\Http\\Uri.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Http;\n\nuse BlitzPHP\\Exceptions\\FrameworkException;\nuse InvalidArgumentException;\nuse Psr\\Http\\Message\\UriInterface;\n\n\/**\n * Abstraction pour un identificateur de ressource uniforme (URI).\n *\n * @credit CodeIgniter 4 <a href=\"https:\/\/codeigniter.com\">CodeIgniter\\HTTP\\URI<\/a>\n *\/\nclass Uri implements UriInterface\n{\n    \/**\n     * Sous-d\u00e9limiteurs utilis\u00e9s dans les cha\u00eenes de requ\u00eate et les fragments.\n     *\/\n    public const CHAR_SUB_DELIMS = '!\\$&\\'\\(\\)\\*\\+,;=';\n\n    \/**\n     * Caract\u00e8res non r\u00e9serv\u00e9s utilis\u00e9s dans les chemins, les cha\u00eenes de requ\u00eate et les fragments.\n     *\/\n    public const CHAR_UNRESERVED = 'a-zA-Z0-9_\\-\\.~';\n\n    \/**\n     * Cha\u00eene d'URI actuelle\n     *\n     * @var string\n     *\/\n    protected $uriString;\n\n    \/**\n     * Liste des segments d'URI.\n     *\n     * Commence \u00e0 1 au lieu de 0\n     *\n     * @var array\n     *\/\n    protected $segments = [];\n\n    \/**\n     * Sch\u00e9ma\n     *\n     * @var string\n     *\/\n    protected $scheme = 'http';\n\n    \/**\n     * Informations utilisateur\n     *\n     * @var string\n     *\/\n    protected $user = '';\n\n    \/**\n     * Mot de passe\n     *\n     * @var string\n     *\/\n    protected $password = '';\n\n    \/**\n     * H\u00f4te\n     *\n     * @var string\n     *\/\n    protected $host = '';\n\n    \/**\n     * Port\n     *\n     * @var int\n     *\/\n    protected $port = 80;\n\n    \/**\n     * Chemin.\n     *\n     * @var string\n     *\/\n    protected $path = '';\n\n    \/**\n     * Le nom de n'importe quel fragment.\n     *\n     * @var string\n     *\/\n    protected $fragment = '';\n\n    \/**\n     * La cha\u00eene de requ\u00eate.\n     *\n     * @var array\n     *\/\n    protected $query = [];\n\n    \/**\n     * Default schemes\/ports.\n     *\n     * @var array\n     *\/\n    protected $defaultPorts = [\n        'http'  => 80,\n        'https' => 443,\n        'ftp'   => 21,\n        'sftp'  => 22,\n    ];\n\n    \/**\n     * Indique si les mots de passe doivent \u00eatre affich\u00e9s dans les appels userInfo\/authority.\n     * La valeur par d\u00e9faut est false car les URI apparaissent souvent dans les journaux\n     *\n     * @var bool\n     *\/\n    protected $showPassword = false;\n\n    \/**\n     * Constructeur.\n     *\n     * @throws InvalidArgumentException\n     *\/\n    public function __construct(?string $uri = null)\n    {\n        $this->setURI($uri);\n        $this->port = $_SERVER['SERVER_PORT'] ?? 80;\n    }\n\n    \/**\n     * D\u00e9finit et \u00e9crase toute information URI actuelle.\n     *\/\n    public function setURI(?string $uri = null): self\n    {\n        if (null !== $uri) {\n            $parts = parse_url($uri);\n\n            if ($parts === false) {\n                throw new FrameworkException('Impossible de parser l\\'URI \"' . $uri . '\"');\n            }\n\n            $this->applyParts($parts);\n        }\n\n        return $this;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getScheme(): string\n    {\n        return $this->scheme;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getAuthority(bool $ignorePort = false): string\n    {\n        if (empty($this->host)) {\n            return '';\n        }\n\n        $authority = $this->host;\n\n        if (! empty($this->getUserInfo())) {\n            $authority = $this->getUserInfo() . '@' . $authority;\n        }\n\n        if (! empty($this->port) && ! $ignorePort) {\n            \/\/ N'ajoute pas de port s'il s'agit d'un port standard pour ce sch\u00e9ma\n            if ($this->port !== $this->defaultPorts[$this->scheme]) {\n                $authority .= ':' . $this->port;\n            }\n        }\n\n        $this->showPassword = false;\n\n        return $authority;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getUserInfo()\n    {\n        $userInfo = $this->user;\n\n        if ($this->showPassword === true && ! empty($this->password)) {\n            $userInfo .= ':' . $this->password;\n        }\n\n        return $userInfo;\n    }\n\n    \/**\n     * D\u00e9finit temporairement l'URI pour afficher un mot de passe dans userInfo.\n     * Se r\u00e9initialisera apr\u00e8s le premier appel \u00e0 l'autorit\u00e9().\n     *\/\n    public function showPassword(bool $val = true): self\n    {\n        $this->showPassword = $val;\n\n        return $this;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getHost(): string\n    {\n        return $this->host;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getPort()\n    {\n        return $this->port;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getPath(): string\n    {\n        return (null === $this->path) ? '' : $this->path;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getQuery(array $options = []): string\n    {\n        $vars = $this->query;\n\n        if (array_key_exists('except', $options)) {\n            if (! is_array($options['except'])) {\n                $options['except'] = [$options['except']];\n            }\n\n            foreach ($options['except'] as $var) {\n                unset($vars[$var]);\n            }\n        } elseif (array_key_exists('only', $options)) {\n            $temp = [];\n\n            if (! is_array($options['only'])) {\n                $options['only'] = [$options['only']];\n            }\n\n            foreach ($options['only'] as $var) {\n                if (array_key_exists($var, $vars)) {\n                    $temp[$var] = $vars[$var];\n                }\n            }\n\n            $vars = $temp;\n        }\n\n        return empty($vars) ? '' : http_build_query($vars);\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function getFragment(): string\n    {\n        return null === $this->fragment ? '' : $this->fragment;\n    }\n\n    \/**\n     * Renvoie les segments du chemin sous forme de tableau.\n     *\/\n    public function getSegments(): array\n    {\n        return $this->segments;\n    }\n\n    \/**\n     * Renvoie la valeur d'un segment sp\u00e9cifique du chemin URI.\n     *\n     * @return string La valeur du segment. Si aucun segment n'est trouv\u00e9, lance InvalidArgumentError\n     *\/\n    public function getSegment(int $number): string\n    {\n        \/\/ Le segment doit traiter le tableau comme bas\u00e9 sur 1 pour l'utilisateur\n        \/\/ mais nous devons encore g\u00e9rer un tableau de base z\u00e9ro.\n        $number--;\n\n        if ($number > count($this->segments)) {\n            throw new FrameworkException('Le segment \"' . $number . '\" n\\'est pas dans l\\'interval de segment disponible');\n        }\n\n        return $this->segments[$number] ?? '';\n    }\n\n    \/**\n     * D\u00e9finissez la valeur d'un segment sp\u00e9cifique du chemin URI.\n     * Permet de d\u00e9finir uniquement des segments existants ou d'en ajouter un nouveau.\n     *\n     * @param mixed $value (string ou int)\n     *\/\n    public function setSegment(int $number, $value)\n    {\n        \/\/ Le segment doit traiter le tableau comme bas\u00e9 sur 1 pour l'utilisateur\n        \/\/ mais nous devons encore g\u00e9rer un tableau de base z\u00e9ro.\n        $number--;\n\n        if ($number > count($this->segments) + 1) {\n            throw new FrameworkException('Le segment \"' . $number . '\" n\\'est pas dans l\\'interval de segment disponible');\n        }\n\n        $this->segments[$number] = $value;\n        $this->refreshPath();\n\n        return $this;\n    }\n\n    \/**\n     * Renvoie le nombre total de segments.\n     *\/\n    public function getTotalSegments(): int\n    {\n        return count($this->segments);\n    }\n\n    \/**\n     * Autoriser la sortie de l'URI sous forme de cha\u00eene en le convertissant simplement en cha\u00eene\n     * ou en \u00e9cho.\n     *\/\n    public function __toString(): string\n    {\n        return static::createURIString(\n            $this->getScheme(),\n            $this->getAuthority(),\n            $this->getPath(), \/\/ Les URI absolus doivent utiliser un \"\/\" pour un chemin vide\n            $this->getQuery(),\n            $this->getFragment()\n        );\n    }\n\n    \/**\n     * Construit une repr\u00e9sentation de la cha\u00eene \u00e0 partir des parties du composant.\n     *\/\n    public static function createURIString(?string $scheme = null, ?string $authority = null, ?string $path = null, ?string $query = null, ?string $fragment = null): string\n    {\n        $uri = '';\n        if (! empty($scheme)) {\n            $uri .= $scheme . ':\/\/';\n        }\n\n        if (! empty($authority)) {\n            $uri .= $authority;\n        }\n\n        if ($path) {\n            $uri .= substr($uri, -1, 1) !== '\/' ? '\/' . ltrim($path, '\/') : $path;\n        }\n\n        if ($query) {\n            $uri .= '?' . $query;\n        }\n\n        if ($fragment) {\n            $uri .= '#' . $fragment;\n        }\n\n        return $uri;\n    }\n\n    \/**\n     * Analyse la cha\u00eene donn\u00e9e et enregistre les pi\u00e8ces d'autorit\u00e9 appropri\u00e9es.\n     *\/\n    public function setAuthority(string $str): self\n    {\n        $parts = parse_url($str);\n\n        if (empty($parts['host']) && ! empty($parts['path'])) {\n            $parts['host'] = $parts['path'];\n            unset($parts['path']);\n        }\n\n        $this->applyParts($parts);\n\n        return $this;\n    }\n\n    \/**\n     * D\u00e9finit le sch\u00e9ma pour cet URI.\n     *\n     * En raison du grand nombre de sch\u00e9mas valides, nous ne pouvons pas limiter ce\n     * uniquement sur http ou https.\n     *\n     * @see https:\/\/www.iana.org\/assignments\/uri-schemes\/uri-schemes.xhtml\n     *\/\n    public function setScheme(string $str): self\n    {\n        $str = strtolower($str);\n        $str = preg_replace('#:(\/\/)?$#', '', $str);\n\n        $this->scheme = $str;\n\n        return $this;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function withScheme($scheme)\n    {\n        return $this->setScheme($scheme);\n    }\n\n    \/**\n     * D\u00e9finit la partie userInfo\/Authority de l'URI.\n     *\n     * @param string $user Le nom d'utilisateur de l'utilisateur\n     * @param string $pass Le mot de passe de l'utilisateur\n     *\/\n    public function setUserInfo(string $user, string $pass): self\n    {\n        $this->user     = trim($user);\n        $this->password = trim($pass);\n\n        return $this;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function withUserInfo($user, $password = null)\n    {\n        return $this->setUserInfo($user, $password);\n    }\n\n    \/**\n     * D\u00e9finit le nom d'h\u00f4te \u00e0 utiliser.\n     *\/\n    public function setHost(string $str): self\n    {\n        $this->host = trim($str);\n\n        return $this;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function withHost($host)\n    {\n        return $this->setHost($host);\n    }\n\n    \/**\n     * D\u00e9finit la partie port de l'URI.\n     *\/\n    public function setPort(?int $port = null): self\n    {\n        if (null === $port) {\n            return $this;\n        }\n\n        if ($port <= 0 || $port > 65535) {\n            throw new FrameworkException('Le port \"' . $port . '\" est invalide');\n        }\n\n        $this->port = $port;\n\n        return $this;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function withPort($port)\n    {\n        return $this->setPort($port);\n    }\n\n    \/**\n     * D\u00e9finit la partie chemin de l'URI.\n     *\/\n    public function setPath(string $path): self\n    {\n        $this->path = $this->filterPath($path);\n\n        $this->segments = explode('\/', $this->path);\n\n        return $this;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function withPath($path)\n    {\n        return $this->setPath($path);\n    }\n\n    \/**\n     * D\u00e9finit la partie chemin de l'URI en fonction des segments.\n     *\/\n    public function refreshPath(): self\n    {\n        $this->path = $this->filterPath(implode('\/', $this->segments));\n\n        $this->segments = explode('\/', $this->path);\n\n        return $this;\n    }\n\n    \/**\n     * D\u00e9finit la partie requ\u00eate de l'URI, tout en essayant\n     * de nettoyer les diff\u00e9rentes parties des cl\u00e9s et des valeurs de la requ\u00eate.\n     *\/\n    public function setQuery(string $query): self\n    {\n        if (strpos($query, '#') !== false) {\n            throw new FrameworkException('La chaine de requete est mal form\u00e9e');\n        }\n\n        \/\/ Ne peut pas avoir de d\u00e9but ?\n        if (! empty($query) && strpos($query, '?') === 0) {\n            $query = substr($query, 1);\n        }\n\n        parse_str($query, $this->query);\n\n        return $this;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function withQuery($query)\n    {\n        return $this->setQuery($query);\n    }\n\n    \/**\n     * Une m\u00e9thode pratique pour transmettre un tableau d'\u00e9l\u00e9ments en tant que requ\u00eate\n     * partie de l'URI.\n     *\/\n    public function setQueryArray(array $query): self\n    {\n        $query = http_build_query($query);\n\n        return $this->setQuery($query);\n    }\n\n    \/**\n     * Ajoute un seul nouvel \u00e9l\u00e9ment \u00e0 la requ\u00eate vars.\n     *\n     * @param mixed $value\n     *\/\n    public function addQuery(string $key, $value = null): self\n    {\n        $this->query[$key] = $value;\n\n        return $this;\n    }\n\n    \/**\n     * Supprime une ou plusieurs variables de requ\u00eate de l'URI.\n     *\n     * @param array ...$params\n     *\/\n    public function stripQuery(...$params): self\n    {\n        foreach ($params as $param) {\n            unset($this->query[$param]);\n        }\n\n        return $this;\n    }\n\n    \/**\n     * Filtre les variables de requ\u00eate afin que seules les cl\u00e9s transmises\n     * sont gard\u00e9s. Le reste est supprim\u00e9 de l'objet.\n     *\n     * @param array ...$params\n     *\/\n    public function keepQuery(...$params): self\n    {\n        $temp = [];\n\n        foreach ($this->query as $key => $value) {\n            if (! in_array($key, $params, true)) {\n                continue;\n            }\n\n            $temp[$key] = $value;\n        }\n\n        $this->query = $temp;\n\n        return $this;\n    }\n\n    \/**\n     * D\u00e9finit la partie fragment de l'URI.\n     *\n     * @see https:\/\/tools.ietf.org\/html\/rfc3986#section-3.5\n     *\/\n    public function setFragment(string $string): self\n    {\n        $this->fragment = trim($string, '# ');\n\n        return $this;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function withFragment($fragment)\n    {\n        return $this->setFragment($fragment);\n    }\n\n    \/**\n     * Encode tous les caract\u00e8res dangereux et supprime les segments de points.\n     * Bien que les segments de points aient des utilisations valides selon la sp\u00e9cification,\n     * cette classe ne les autorise pas.\n     *\/\n    protected function filterPath(?string $path = null): string\n    {\n        $orig = $path;\n\n        \/\/ D\u00e9code\/normalise les caract\u00e8res cod\u00e9s en pourcentage afin que\n        \/\/ nous pouissions toujours avoir une correspondance pour les routes, etc.\n        $path = urldecode($path);\n\n        \/\/ Supprimer les segments de points\n        $path = $this->removeDotSegments($path);\n\n        \/\/ Correction de certains cas de bord de barre oblique...\n        if (strpos($orig, '.\/') === 0) {\n            $path = '\/' . $path;\n        }\n        if (strpos($orig, '..\/') === 0) {\n            $path = '\/' . $path;\n        }\n\n        \/\/ Encode les caract\u00e8res\n        $path = preg_replace_callback(\n            '\/(?:[^' . static::CHAR_UNRESERVED . ':@&=\\+\\$,\\\/;%]+|%(?![A-Fa-f0-9]{2}))\/',\n            static fn (array $matches) => rawurlencode($matches[0]),\n            $path\n        );\n\n        return $path;\n    }\n\n    \/**\n     * Enregistre nos pi\u00e8ces \u00e0 partir d'un appel parse_url.\n     *\/\n    protected function applyParts(array $parts)\n    {\n        if (! empty($parts['host'])) {\n            $this->host = $parts['host'];\n        }\n        if (! empty($parts['user'])) {\n            $this->user = $parts['user'];\n        }\n        if (! empty($parts['path'])) {\n            $this->path = $this->filterPath($parts['path']);\n        }\n        if (! empty($parts['query'])) {\n            $this->setQuery($parts['query']);\n        }\n        if (! empty($parts['fragment'])) {\n            $this->fragment = $parts['fragment'];\n        }\n\n        if (isset($parts['scheme'])) {\n            $this->setScheme(rtrim($parts['scheme'], ':\/'));\n        } else {\n            $this->setScheme('http');\n        }\n\n        if (isset($parts['port'])) {\n            if (null !== $parts['port']) {\n                \/\/ Les num\u00e9ros de port valides sont appliqu\u00e9s par les pr\u00e9c\u00e9dents parse_url ou setPort()\n                $port       = $parts['port'];\n                $this->port = $port;\n            }\n        }\n\n        if (isset($parts['pass'])) {\n            $this->password = $parts['pass'];\n        }\n\n        if (! empty($parts['path'])) {\n            $this->segments = explode('\/', trim($parts['path'], '\/'));\n        }\n    }\n\n    \/**\n     * Combine une cha\u00eene d'URI avec celle-ci en fonction des r\u00e8gles d\u00e9finies dans\n     * RFC 3986 Section 2\n     *\n     * @see http:\/\/tools.ietf.org\/html\/rfc3986#section-5.2\n     *\/\n    public function resolveRelativeURI(string $uri): self\n    {\n        \/*\n         * REMARQUE : Nous n'utilisons pas removeDotSegments dans cet\n         * algorithme puisque c'est d\u00e9j\u00e0 fait par cette ligne !\n         *\/\n        $relative = new self();\n        $relative->setURI($uri);\n\n        if ($relative->getScheme() === $this->getScheme()) {\n            $relative->setScheme('');\n        }\n\n        $transformed = clone $relative;\n\n        \/\/ 5.2.2 Transformer les r\u00e9f\u00e9rences dans une m\u00e9thode non stricte (pas de sch\u00e9ma)\n        if (! empty($relative->getAuthority())) {\n            $transformed->setAuthority($relative->getAuthority())\n                ->setPath($relative->getPath())\n                ->setQuery($relative->getQuery());\n        } else {\n            if ($relative->getPath() === '') {\n                $transformed->setPath($this->getPath());\n\n                if ($relative->getQuery()) {\n                    $transformed->setQuery($relative->getQuery());\n                } else {\n                    $transformed->setQuery($this->getQuery());\n                }\n            } else {\n                if (strpos($relative->getPath(), '\/') === 0) {\n                    $transformed->setPath($relative->getPath());\n                } else {\n                    $transformed->setPath($this->mergePaths($this, $relative));\n                }\n\n                $transformed->setQuery($relative->getQuery());\n            }\n\n            $transformed->setAuthority($this->getAuthority());\n        }\n\n        $transformed->setScheme($this->getScheme());\n\n        $transformed->setFragment($relative->getFragment());\n\n        return $transformed;\n    }\n\n    \/**\n     * \u00c9tant donn\u00e9 2 chemins, les fusionnera conform\u00e9ment aux r\u00e8gles \u00e9nonc\u00e9es dans RFC 2986, section 5.2\n     *\n     * @see http:\/\/tools.ietf.org\/html\/rfc3986#section-5.2.3\n     *\/\n    protected function mergePaths(self $base, self $reference): string\n    {\n        if (! empty($base->getAuthority()) && empty($base->getPath())) {\n            return '\/' . ltrim($reference->getPath(), '\/ ');\n        }\n\n        $path = explode('\/', $base->getPath());\n\n        if (empty($path[0])) {\n            unset($path[0]);\n        }\n\n        array_pop($path);\n        $path[] = $reference->getPath();\n\n        return implode('\/', $path);\n    }\n\n    \/**\n     * Utilis\u00e9 lors de la r\u00e9solution et de la fusion de chemins pour interpr\u00e9ter et\n     * supprimer correctement les segments \u00e0 un ou deux points du chemin selon RFC 3986 Section 5.2.4\n     *\n     * @see http:\/\/tools.ietf.org\/html\/rfc3986#section-5.2.4\n     *\/\n    public static function removeDotSegments(string $path): string\n    {\n        if (empty($path) || $path === '\/') {\n            return $path;\n        }\n\n        $output = [];\n\n        $input = explode('\/', $path);\n\n        if (empty($input[0])) {\n            unset($input[0]);\n            $input = array_values($input);\n        }\n\n        \/\/ Ce n'est pas une repr\u00e9sentation parfaite de la\n        \/\/ RFC, mais correspond \u00e0 la plupart des cas et est joli\n        \/\/ beaucoup ce que Guzzle utilise. Devrait \u00eatre assez bon\n        \/\/ pour presque tous les cas d'utilisation r\u00e9els.\n        foreach ($input as $segment) {\n            if ($segment === '..') {\n                array_pop($output);\n            } elseif ($segment !== '.' && $segment !== '') {\n                $output[] = $segment;\n            }\n        }\n\n        $output = implode('\/', $output);\n        $output = ltrim($output, '\/ ');\n\n        if ($output !== '\/') {\n            \/\/ Ajouter une barre oblique au d\u00e9but si n\u00e9cessaire\n            if (strpos($path, '\/') === 0) {\n                $output = '\/' . $output;\n            }\n\n            \/\/ Ajouter une barre oblique \u00e0 la fin si n\u00e9cessaire\n            if (substr($path, -1, 1) === '\/') {\n                $output .= '\/';\n            }\n        }\n\n        return $output;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,0,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,0,null,null,0,null,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,null,null,0,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,0,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,0,null,0,null,null,null,null,null,0,0,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,null,null,0,null,null,null,null,null,0,null,null,0,null,null,0,null,0,null,null,null,0,null,0,null,null,0,null,null,0,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,null,0,0,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,0,null,null,null,null,0,null,null,null,null,0,null,null,null,0,null,null,null]},{"name":"src\\Loader\\DotEnv.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Loader;\n\nuse InvalidArgumentException;\n\n\/**\n * Environment-specific configuration\n *\/\nclass DotEnv\n{\n    \/**\n     * Le r\u00e9pertoire o\u00f9 se trouve le fichier .env.\n     *\n     * @var string\n     *\/\n    protected $path;\n\n    \/**\n     * @var self\n     *\/\n    private static $_instance;\n\n    \/**\n     * Construit le chemin vers notre fichier.\n     *\/\n    private function __construct(string $path, string $file = '.env')\n    {\n        $this->path = rtrim($path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR . $file;\n    }\n\n    \/**\n     * Singleton\n     *\/\n    private static function instance(string $path, string $file = '.env'): self\n    {\n        if (self::$_instance === null) {\n            self::$_instance = new self($path, $file);\n        }\n\n        return self::$_instance;\n    }\n\n    public static function init(string $path, string $file = '.env')\n    {\n        return self::instance($path, $file)->load();\n    }\n\n    \/**\n     * Le point d'entr\u00e9e principal chargera le fichier .env et le traitera\n     * pour que nous nous retrouvions avec tous les param\u00e8tres dans l'environnement PHP vars\n     * (c'est-\u00e0-dire getenv(), $_ENV et $_SERVER)\n     *\/\n    public function load(): bool\n    {\n        $vars = $this->parse();\n\n        if ($vars === null) {\n            return false;\n        }\n\n        foreach ($vars as $name => $value) {\n            $this->setVariable($name, $value);\n        }\n\n        return true; \/\/ notifie de la reussite de l'operation\n    }\n\n    \/**\n     * Parse the .env file into an array of key => value\n     *\/\n    public function parse(): ?array\n    {\n        \/\/ Nous ne voulons pas imposer la pr\u00e9sence d'un fichier .env, ils devraient \u00eatre facultatifs.\n        if (! is_file($this->path)) {\n            return null;\n        }\n\n        \/\/ Assurez-vous que le fichier est lisible\n        if (! is_readable($this->path)) {\n            throw new InvalidArgumentException(\"The .env file is not readable: {$this->path}\");\n        }\n\n        $vars = [];\n\n        $lines = file($this->path, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);\n\n        foreach ($lines as $line) {\n            \/\/ C'est un commentaire?\n            if (strpos(trim($line), '#') === 0) {\n                continue;\n            }\n\n            \/\/ S'il y a un signe \u00e9gal, alors nous savons que nous affectons une variable.\n            if (strpos($line, '=') !== false) {\n                [$name, $value] = $this->normaliseVariable($line);\n                $vars[$name]    = $value;\n            }\n        }\n\n        return $vars;\n    }\n\n    \/**\n     * D\u00e9finit la variable dans l'environnement. Analysera la cha\u00eene\n     * premier \u00e0 rechercher le mod\u00e8le {name}={value}, assurez-vous que imbriqu\u00e9\n     * les variables sont g\u00e9r\u00e9es et d\u00e9barrass\u00e9es des guillemets simples et doubles.\n     *\/\n    protected function setVariable(string $name, string $value = '')\n    {\n        if (! getenv($name, true)) {\n            putenv(\"{$name}={$value}\");\n        }\n        if (empty($_ENV[$name])) {\n            $_ENV[$name] = $value;\n        }\n        if (empty($_SERVER[$name])) {\n            $_SERVER[$name] = $value;\n        }\n    }\n\n    \/**\n     * Analyse l'affectation, nettoie le $name et la $value, et s'assure\n     * que les variables imbriqu\u00e9es sont g\u00e9r\u00e9es.\n     *\/\n    public function normaliseVariable(string $name, string $value = ''): array\n    {\n        \/\/ Divisez notre cha\u00eene compos\u00e9e en ses parties.\n        if (strpos($name, '=') !== false) {\n            [$name, $value] = explode('=', $name, 2);\n        }\n\n        $name  = trim($name);\n        $value = trim($value);\n\n        \/\/ Assainir le nom\n        $name = str_replace(['export', '\\'', '\"'], '', $name);\n\n        \/\/ Assainir la valeur\n        $value = $this->sanitizeValue($value);\n\n        $value = $this->resolveNestedVariables($value);\n\n        return [\n            $name,\n            $value,\n        ];\n    }\n\n    \/**\n     * Supprime les guillemets de la valeur de la variable d'environnement.\n     *\n     * Ceci a \u00e9t\u00e9 emprunt\u00e9 \u00e0 l'excellent phpdotenv avec tr\u00e8s peu de modifications.\n     * https:\/\/github.com\/vlucas\/phpdotenv\n     *\n     * @throws InvalidArgumentException\n     *\/\n    protected function sanitizeValue(string $value): string\n    {\n        if (! $value) {\n            return $value;\n        }\n\n        \/\/ Commence-t-il par une citation ?\n        if (strpbrk($value[0], '\"\\'') !== false) {\n            \/\/ la valeur commence par un guillemet\n            $quote        = $value[0];\n            $regexPattern = sprintf(\n                '\/^\n\t\t\t\t\t%1$s          # match a quote at the start of the value\n\t\t\t\t\t(             # capturing sub-pattern used\n\t\t\t\t\t\t\t\t  (?:          # we do not need to capture this\n\t\t\t\t\t\t\t\t   [^%1$s\\\\\\\\] # any character other than a quote or backslash\n\t\t\t\t\t\t\t\t   |\\\\\\\\\\\\\\\\   # or two backslashes together\n\t\t\t\t\t\t\t\t   |\\\\\\\\%1$s   # or an escaped quote e.g \\\"\n\t\t\t\t\t\t\t\t  )*           # as many characters that match the previous rules\n\t\t\t\t\t)             # end of the capturing sub-pattern\n\t\t\t\t\t%1$s          # and the closing quote\n\t\t\t\t\t.*$           # and discard any string after the closing quote\n\t\t\t\t\t\/mx',\n                $quote\n            );\n            $value = preg_replace($regexPattern, '$1', $value);\n            $value = str_replace(\"\\\\{$quote}\", $quote, $value);\n            $value = str_replace('\\\\\\\\', '\\\\', $value);\n        } else {\n            $parts = explode(' #', $value, 2);\n\n            $value = trim($parts[0]);\n\n            \/\/ Les valeurs sans guillemets ne peuvent pas contenir d'espaces\n            if (preg_match('\/\\s+\/', $value) > 0) {\n                throw new InvalidArgumentException('.env values containing spaces must be surrounded by quotes.');\n            }\n        }\n\n        return $value;\n    }\n\n    \/**\n     * R\u00e9solvez les variables imbriqu\u00e9es.\n     *\n     * Recherchez les mod\u00e8les ${varname} dans la valeur de la variable et remplacez-les par un existant\n     * variables d'environnement.\n     *\n     * Ceci a \u00e9t\u00e9 emprunt\u00e9 \u00e0 l'excellent phpdotenv avec tr\u00e8s peu de modifications.\n     * https:\/\/github.com\/vlucas\/phpdotenv\n     *\/\n    protected function resolveNestedVariables(string $value): string\n    {\n        if (strpos($value, '$') !== false) {\n            $loader = $this;\n\n            $value = preg_replace_callback(\n                '\/\\${([a-zA-Z0-9_]+)}\/',\n                static function ($matchedPatterns) use ($loader) {\n                    $nestedVariable = $loader->getVariable($matchedPatterns[1]);\n\n                    if (null === $nestedVariable) {\n                        return $matchedPatterns[0];\n                    }\n\n                    return $nestedVariable;\n                },\n                $value\n            );\n        }\n\n        return $value;\n    }\n\n    \/**\n     * Rechercher les diff\u00e9rents endroits pour les variables d'environnement et renvoyer la premi\u00e8re valeur trouv\u00e9e.\n     *\n     * Ceci a \u00e9t\u00e9 emprunt\u00e9 \u00e0 l'excellent phpdotenv avec tr\u00e8s peu de modifications.\n     * https:\/\/github.com\/vlucas\/phpdotenv\n     *\/\n    protected function getVariable(string $name): ?string\n    {\n        switch (true) {\n            case array_key_exists($name, $_ENV):\n                return $_ENV[$name];\n\n            case array_key_exists($name, $_SERVER):\n                return $_SERVER[$name];\n\n            default:\n                $value = getenv($name);\n\n                \/\/ passe la valeur par d\u00e9faut de getenv \u00e0 null\n                return $value === false ? null : $value;\n        }\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,0,null,0,null,null,null,null,0,null,null,null,null,0,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,0,null,null,0,null,null,0,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,0,null,0,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null]},{"name":"src\\Loader\\FileLocator.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Loader;\n\nuse BlitzPHP\\Exceptions\\LoadException;\nuse BlitzPHP\\Utilities\\Helpers;\n\nclass FileLocator\n{\n    \/**\n     * Charge un fichier de traduction\n     *\/\n    public static function lang(string $lang, string $locale): array\n    {\n        $file  = Helpers::ensureExt($lang, 'php');\n        $paths = [\n            \/\/ Path to system languages\n            SYST_PATH . 'Constants' . DS . 'language' . DS . config('app.language') . DS . $file,\n\n            \/\/ Path to app languages\n            LANG_PATH . config('app.language') . DS . $file,\n\n            \/\/ Path to system languages\n            SYST_PATH . 'Constants' . DS . 'language' . DS . $locale . DS . $file,\n\n            \/\/ Path to app languages\n            LANG_PATH . $locale . DS . $file,\n        ];\n        $file_exist = false;\n        $languages  = [];\n\n        foreach ($paths as $path) {\n            if (file_exists($path) && ! in_array($path, get_included_files(), true)) {\n                $languages  = array_merge($languages, (array) require($path));\n                $file_exist = true;\n            }\n        }\n\n        if (true !== $file_exist) {\n            throw LoadException::langNotFound($lang);\n        }\n\n        return $languages;\n    }\n\n    \/**\n     * Charge un fichier d'aide (helper)\n     *\n     * @return void\n     *\/\n    public static function helper(string $helper)\n    {\n        $file  = Helpers::ensureExt($helper, 'php');\n        $paths = [\n            \/\/ Helpers syst\u00e8me\n            SYST_PATH . 'Helpers' . DS . $file,\n\n            \/\/ Helpers de l'application\n            APP_PATH . 'Helpers' . DS . $file,\n        ];\n        $file_exist = false;\n\n        foreach ($paths as $path) {\n            if (file_exists($path)) {\n                require_once $path;\n                $file_exist = true;\n            }\n        }\n\n        if (true !== $file_exist) {\n            throw LoadException::helperNotFound($helper);\n        }\n    }\n\n    \/**\n     * Cree et renvoie une librairie donn\u00e9e\n     *\n     * @return mixed\n     *\/\n    public static function library(string $library)\n    {\n        $library = str_replace(DS, '\/', $library);\n        $library = explode('\/', $library);\n\n        $lib                          = ucfirst(end($library));\n        $library[count($library) - 1] = $lib;\n\n        $file  = Helpers::ensureExt(implode(DS, $library), 'php');\n        $paths = [\n            SYST_PATH . 'Libraries' . DS . $file,\n\n            APP_PATH . 'Libraries' . DS . $file,\n        ];\n        $file_syst = $file_exist = false;\n\n        if (file_exists($paths[0])) {\n            $lib       = \"BlitzPhp\\\\Libraries\\\\{$lib}\";\n            $file_syst = $file_exist = true;\n        } elseif (file_exists($paths[1])) {\n            require_once $paths[1];\n            $file_exist = true;\n        }\n\n        if (true !== $file_exist) {\n            throw LoadException::libraryNotFound($lib);\n        }\n\n        if (true !== $file_syst && ! class_exists($lib)) {\n            throw LoadException::libraryDontExist($lib);\n        }\n\n        return Injector::make($lib);\n    }\n\n    \/**\n     * Cree et renvoi un model donn\u00e9\n     *\n     * @return \\dFramework\\core\\Model\n     *\/\n    public static function model(string $model)\n    {\n        $model = str_replace(DS, '\/', $model);\n        $model = explode('\/', $model);\n\n        $mod                      = ucfirst(end($model));\n        $mod                      = (! preg_match('#Model$#', $mod)) ? $mod . 'Model' : $mod;\n        $model[count($model) - 1] = $mod;\n\n        foreach ($model as $key => &$value) {\n            if (preg_match('#^Models?$#i', $value)) {\n                unset($value, $model[$key]);\n            }\n        }\n\n        $path = MODEL_PATH . Helpers::ensureExt(implode(DS, $model), 'php');\n\n        if (! file_exists($path)) {\n            throw LoadException::modelNotFound($mod, $path);\n        }\n\n        require_once $path;\n\n        $class_namespaced = implode('\\\\', $model);\n\n        if (class_exists($class_namespaced, false)) {\n            return Injector::make($class_namespaced);\n        }\n        if (! class_exists($mod, false)) {\n            throw LoadException::modelDontExist($mod, $path);\n        }\n\n        return Injector::make($mod);\n    }\n\n    \/**\n     * Cree et renvoi un controleur donn\u00e9\n     *\n     * @return \\dFramework\\core\\controllers\\BaseController\n     *\/\n    public static function controller(string $controller)\n    {\n        $controller = str_replace(DS, '\/', $controller);\n        $controller = explode('\/', $controller);\n\n        $con                                = ucfirst(end($controller));\n        $con                                = (! preg_match('#Controller$#', $con)) ? $con . 'Controller' : $con;\n        $controller[count($controller) - 1] = $con;\n\n        foreach ($controller as $key => &$value) {\n            if (preg_match('#^Controllers?$#i', $value)) {\n                unset($value, $controller[$key]);\n            }\n        }\n\n        $path = CONTROLLER_PATH . Helpers::ensureExt(implode(DS, $controller), 'php');\n\n        if (! file_exists($path)) {\n            throw LoadException::controllerNotFound(str_replace('Controller', '', $con), $path);\n        }\n\n        require_once $path;\n\n        $class_namespaced = implode('\\\\', $controller);\n\n        if (class_exists($class_namespaced, false)) {\n            return Injector::make($class_namespaced);\n        }\n        if (! class_exists($con, false)) {\n            throw LoadException::controllerDontExist(str_replace('Controller', '', $con), $path);\n        }\n\n        return Injector::make($con);\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,null,null,0,0,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,0,0,null,null,null,0,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,0,null,0,0,null,0,null,null,null,null,0,0,null,null,0,0,null,0,0,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,0,0,0,null,null,null,0,null,null,null,0,null,null,0,null,null,0,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,0,0,0,null,null,null,0,null,null,null,0,null,null,0,null,null,0,null,0,null,null,0,null,null,0,null,null,0,null,null,null]},{"name":"src\\Loader\\Injector.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Loader;\n\nuse BlitzPHP\\Traits\\SingletonTrait;\nuse DI\\Container;\nuse DI\\ContainerBuilder;\n\n\/**\n * Injector\n *\n *  Conteneur d'Injection de Dependences\n *\/\nclass Injector\n{\n    use SingletonTrait;\n\n    \/**\n     * @var \\DI\\Container\n     *\/\n    private $container;\n\n    \/**\n     * @var ContainerBuilder\n     *\/\n    private $builder;\n\n    \/**\n     * Constructor\n     *\/\n    private function __construct()\n    {\n        $this->builder = new ContainerBuilder();\n        $this->builder->useAutowiring(true);\n\n        if (on_prod()) {\n            $this->builder->enableCompilation(SYST_PATH . 'Constants' . DS);\n        }\n\n        $this->container = new Container();\n    }\n\n    \/**\n     * Charge les definitions pour le container\n     *\/\n    private function loadProviders()\n    {\n        $providers = Load::providers();\n\n        $this->builder->addDefinitions($providers);\n\n        $this->container = $this->builder->build();\n    }\n\n    \/**\n     * Initialise le container d'injection de dependences\n     *\/\n    public static function init()\n    {\n        self::instance()->loadProviders();\n    }\n\n    \/**\n     * Renvoie l'instance du conteneur\n     *\/\n    public static function container(): Container\n    {\n        return self::instance()->container;\n    }\n\n    \/**\n     * Renvoie une entr\u00e9e du conteneur par son nom.\n     *\n     * @param string $name Entry name or a class name.\n     *\n     * @return mixed\n     *\/\n    public static function get(string $name)\n    {\n        return self::container()->get($name);\n    }\n\n    \/**\n     * Alias de self::get\n     *\/\n    public static function singleton(string $classname)\n    {\n        return self::get($classname);\n    }\n\n    \/**\n     * Construire une entr\u00e9e du conteneur par son nom.\n     *\n     * Cette m\u00e9thode se comporte comme singleton() sauf qu'elle r\u00e9sout \u00e0 nouveau l'entr\u00e9e \u00e0 chaque fois.\n     * Par exemple, si l'entr\u00e9e est une classe, une nouvelle instance sera cr\u00e9\u00e9e \u00e0 chaque fois.\n     *\n     * Cette m\u00e9thode fait que le conteneur se comporte comme une usine.\n     *\n     * @param string $name       Nom d'entr\u00e9e ou nom de classe.\n     * @param array  $parameters Param\u00e8tres facultatifs \u00e0 utiliser pour construire l'entr\u00e9e. Utilisez ceci pour forcer des param\u00e8tres sp\u00e9cifiques\n     *                           \u00e0 des valeurs sp\u00e9cifiques. Les param\u00e8tres non d\u00e9finis dans ce tableau seront r\u00e9solus en utilisant le conteneur.\n     *\n     * @return mixed\n     *\/\n    public static function make(string $name, array $parameters = [])\n    {\n        return self::container()->make($name, $parameters);\n    }\n\n    \/**\n     * Alias de self::make\n     *\/\n    public static function factory(string $classname, array $parameters = [])\n    {\n        return self::make($classname, $parameters);\n    }\n\n    \/**\n     * Appelez la fonction donn\u00e9e en utilisant les param\u00e8tres donn\u00e9s.\n     *\n     * Les param\u00e8tres manquants seront r\u00e9solus \u00e0 partir du conteneur.\n     *\n     * @param callable $callable Fonction \u00e0 appeler.\n     * @param array    $params   Param\u00e8tres \u00e0 utiliser. Peut \u00eatre index\u00e9 par les noms de param\u00e8tre\n     *                           ou non index\u00e9 (m\u00eame ordre que les param\u00e8tres).\n     *                           Le tableau peut \u00e9galement contenir des d\u00e9finitions DI, par ex. DI\\get().\n     *\n     * @return mixed Resultat de la fonction.\n     *\/\n    public static function call($callable, array $params = [])\n    {\n        return self::container()->call($callable, $params);\n    }\n\n    \/**\n     * Testez si le conteneur peut fournir quelque chose pour le nom donn\u00e9.\n     *\n     * @param string $name Nom d'entr\u00e9e ou nom de classe\n     *\/\n    public static function has(string $name): bool\n    {\n        return self::container()->has($name);\n    }\n\n    \/**\n     * D\u00e9finissez un objet ou une valeur dans le conteneur.\n     *\n     * @param string $name  Nom de l'entr\u00e9e\n     * @param mixed  $value utilisez les aides \u00e0 la d\u00e9finition pour d\u00e9finir les objets\n     *\/\n    public static function add(string $name, $value): void\n    {\n        self::container()->set($name, $value);\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null]},{"name":"src\\Loader\\Load.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Loader;\n\nuse BlitzPHP\\Exceptions\\LoadException;\n\nclass Load\n{\n    \/**\n     * @var array\n     *\/\n    private static $loads = [\n        'controllers' => [],\n        'helpers'     => [],\n        'langs'       => [],\n        'libraries'   => [],\n        'models'      => [],\n    ];\n\n    \/**\n     * Recupere toutes les definitions des services a injecter dans le container\n     *\/\n    public static function providers(): array\n    {\n        $providers = [];\n\n        \/\/ services syst\u00e8me\n        $filename = SYST_PATH . 'Constants' . DS . 'providers.php';\n        if (! file_exists($filename)) {\n            throw LoadException::providersDefinitionDontExist($filename);\n        }\n        if (! in_array($filename, get_included_files(), true)) {\n            $providers = array_merge($providers, require $filename);\n        }\n\n        \/\/ services de l'application\n        $filename = CONFIG_PATH . 'providers.php';\n        if (file_exists($filename) && ! in_array($filename, get_included_files(), true)) {\n            $providers = array_merge($providers, require $filename);\n        }\n\n        return $providers;\n    }\n\n    \/**\n     * Verifie si un element est charg\u00e9 dans la liste des modules\n     *\n     * @param $element\n     *\/\n    private static function is_loaded(string $module, $element): bool\n    {\n        if (! isset(self::$loads[$module]) || ! is_array(self::$loads[$module])) {\n            return false;\n        }\n\n        return in_array($element, self::$loads[$module], true);\n    }\n\n    \/**\n     * Ajoute un element aux elements charg\u00e9s\n     *\n     * @param string     $element\n     * @param mixed|null $value\n     *\/\n    private static function loaded(string $module, $element, $value = null): void\n    {\n        self::$loads[$module][$element] = $value;\n    }\n\n    \/**\n     * Renvoie un element charg\u00e9\n     *\n     * @param string $element\n     *\n     * @return mixed\n     *\/\n    private static function get_loaded(string $module, $element)\n    {\n        return self::$loads[$module][$element] ?? null;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,null,0,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null]},{"name":"src\\Loader\\Services.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Loader;\n\nuse BlitzPHP\\Cache\\Cache;\nuse BlitzPHP\\Config\\Config;\nuse BlitzPHP\\Debug\\Logger;\nuse BlitzPHP\\Debug\\Timer;\nuse BlitzPHP\\Event\\EventManager;\nuse BlitzPHP\\Http\\Negotiator;\nuse BlitzPHP\\HTTP\\Redirection;\nuse BlitzPHP\\Http\\Response;\nuse BlitzPHP\\Http\\ResponseEmitter;\nuse BlitzPHP\\Http\\ServerRequest;\nuse BlitzPHP\\Http\\Session;\nuse BlitzPHP\\Http\\Uri;\nuse BlitzPHP\\Output\\Language;\nuse BlitzPHP\\Router\\RouteCollection;\nuse BlitzPHP\\Router\\Router;\nuse BlitzPHP\\View\\View;\nuse DI\\NotFoundException;\n\n\/**\n * Service\n *\n * Les services sont simplement d'autres classes\/biblioth\u00e8ques que le syst\u00e8me utilise\n * pour faire son travail. Ceci est utilis\u00e9 par BlitzPHP pour permettre au coeur du\n * framework \u00e0 \u00e9changer facilement sans affecter l'utilisation \u00e0 l'int\u00e9rieur\n * le reste de votre application.\n *\n * Ceci est utilis\u00e9 \u00e0 la place d'un conteneur d'injection de d\u00e9pendance principalement\n * en raison de sa simplicit\u00e9, qui permet un meilleur entretien \u00e0 long terme\n * des applications construites sur BlitzPHP. Un effet secondaire bonus\n * est que les IDE sont capables de d\u00e9terminer quelle classe vous appelez\n * alors qu'avec les conteneurs DI, il n'y a g\u00e9n\u00e9ralement aucun moyen pour eux de le faire.\n *\/\nclass Services\n{\n    \/**\n     * @return Injector\n     *\/\n    public static function injector()\n    {\n        return Injector::instance();\n    }\n\n    \/**\n     * @return \\DI\\Container\n     *\/\n    public static function container()\n    {\n        return Injector::container();\n    }\n\n    \/**\n     * La classe de cache fournit un moyen simple de stocker et de r\u00e9cup\u00e9rer\n     * donn\u00e9es complexes pour plus tard\n     *\/\n    public static function cache(bool $shared = true): Cache\n    {\n        $config = Config::get('cache');\n\n        if (true === $shared) {\n            return self::singleton(Cache::class)->setConfig($config);\n        }\n\n        return self::factory(Cache::class, [$config]);\n    }\n\n    \/**\n     * \u00c9metteur de r\u00e9ponse au client\n     *\/\n    public static function emitter(bool $shared = true): ResponseEmitter\n    {\n        if (true === $shared) {\n            return self::singleton(ResponseEmitter::class);\n        }\n\n        return self::factory(ResponseEmitter::class);\n    }\n\n    \/**\n     * Gestionnaire d'evenement\n     *\/\n    public static function event(bool $shared = true): EventManager\n    {\n        if (true === $shared) {\n            return self::singleton(EventManager::class);\n        }\n\n        return self::factory(EventManager::class);\n    }\n\n    \/**\n     * Responsable du chargement des traductions des cha\u00eenes de langue.\n     *\/\n    public static function language(?string $locale = null, bool $shared = true): Language\n    {\n        if (true === $shared) {\n            return self::singleton(Language::class)->setLocale($locale);\n        }\n\n        return self::factory(Language::class)->setLocale($locale);\n    }\n\n    \/**\n     * La classe Logger est une classe Logging compatible PSR-3 qui prend en charge\n     * plusieurs gestionnaires qui traitent la journalisation r\u00e9elle.\n     *\/\n    public static function logger(bool $shared = true): Logger\n    {\n        if ($shared) {\n            return self::singleton(Logger::class);\n        }\n\n        return self::factory(Logger::class);\n    }\n\n    \/**\n     * La classe Input g\u00e9n\u00e9rale mod\u00e9lise une requ\u00eate HTTP.\n     *\/\n    public static function negotiator(?ServerRequest $request = null, bool $shared = true): Negotiator\n    {\n        if (empty($request)) {\n            $request = static::request(true);\n        }\n\n        if (true === $shared) {\n            return self::singleton(Negotiator::class)->setRequest($request);\n        }\n\n        return self::factory(Negotiator::class, [$request]);\n    }\n\n    \/**\n     * La classe des redirections HTTP\n     *\/\n    public static function redirection(bool $shared = true): Redirection\n    {\n        if (true === $shared) {\n            return self::singleton(Redirection::class);\n        }\n\n        return self::factory(Redirection::class);\n    }\n\n    \/**\n     * La classe Resquest mod\u00e9lise une req\u00fbete HTTP.\n     *\/\n    public static function request(bool $shared = true): ServerRequest\n    {\n        if (true === $shared) {\n            return self::singleton(ServerRequest::class);\n        }\n\n        return self::factory(ServerRequest::class);\n    }\n\n    \/**\n     * La classe Response mod\u00e9lise une r\u00e9ponse HTTP.\n     *\/\n    public static function response(bool $shared = true): Response\n    {\n        if (true === $shared) {\n            return self::singleton(Response::class);\n        }\n\n        return self::factory(Response::class);\n    }\n\n    \/**\n     * Le service Routes est une classe qui permet de construire facilement\n     * une collection d'itin\u00e9raires.\n     *\/\n    public static function routes(bool $shared = true): RouteCollection\n    {\n        if (true === $shared) {\n            return self::singleton(RouteCollection::class);\n        }\n\n        return self::factory(RouteCollection::class);\n    }\n\n    \/**\n     * La classe Router utilise le tableau de routes d'une RouteCollection et d\u00e9termine\n     * le contr\u00f4leur et la m\u00e9thode corrects \u00e0 ex\u00e9cuter.\n     *\/\n    public static function router(?RouteCollection $routes = null, ?ServerRequest $request = null, bool $shared = true): Router\n    {\n        if (true === $shared) {\n            return self::singleton(Router::class);\n        }\n        if (empty($routes)) {\n            $routes = static::routes(true);\n        }\n        if (empty($request)) {\n            $request = static::request(true);\n        }\n\n        return self::factory(Router::class)->init($routes, $request);\n    }\n\n    \/**\n     * Return the session manager.\n     *\/\n    public static function session(bool $shared = true): Session\n    {\n        if (true === $shared) {\n            return self::singleton(Session::class);\n        }\n\n        \/**\n         * @var Session\n         *\/\n        $session = self::factory(Session::class);\n\n        if (session_status() === PHP_SESSION_NONE) {\n            $session->start();\n        }\n\n        return $session;\n    }\n\n    \/**\n     * La classe Timer fournit un moyen simple d'\u00e9valuer des parties de votre application.\n     *\/\n    public static function timer(bool $shared = true): Timer\n    {\n        if (true === $shared) {\n            return self::singleton(Timer::class);\n        }\n\n        return self::factory(Timer::class);\n    }\n\n    \/**\n     * La classe URI fournit un moyen de mod\u00e9liser et de manipuler les URI.\n     *\/\n    public static function uri(?string $uri = null, bool $shared = true): Uri\n    {\n        if (true === $shared) {\n            return self::singleton(Uri::class)->setURI($uri);\n        }\n\n        return self::factory(Uri::class, [$uri]);\n    }\n\n    \/**\n     * La classe Renderer est la classe qui affiche r\u00e9ellement un fichier \u00e0 l'utilisateur.\n     * La classe View par d\u00e9faut dans BlitzPHP est intentionnellement simple, mais\n     * le service peut facilement \u00eatre remplac\u00e9 par un moteur de mod\u00e8le si l'utilisateur en a besoin.\n     *\/\n    public static function viewer(bool $shared = true): View\n    {\n        if (true === $shared) {\n            return self::singleton(View::class);\n        }\n\n        return self::factory(View::class);\n    }\n\n    \/**\n     * Offre la possibilit\u00e9 d'effectuer des appels insensibles \u00e0 la casse des noms de service.\n     *\n     * @return mixed\n     *\/\n    public static function __callStatic(string $name, array $arguments)\n    {\n        if (method_exists(self::class, $name)) {\n            return self::$name(...$arguments);\n        }\n\n        return self::discoverServices($name, $arguments);\n    }\n\n    \/**\n     * Essaie d'obtenir un service \u00e0 partir du conteneur\n     *\n     * @return mixed\n     *\/\n    protected static function discoverServices(string $name, array $arguments)\n    {\n        $shared = array_pop($arguments);\n        if ($shared !== true) {\n            return self::discoverServiceFactory($name, $arguments);\n        }\n\n        return self::discoverServiceSingleton($name);\n    }\n\n    \/**\n     * Essaie d'obtenir un service \u00e0 partir du conteneur\n     *\n     * @return mixed\n     *\/\n    private static function discoverServiceFactory(string $name, array $arguments)\n    {\n        try {\n            return self::factory($name, $arguments);\n        } catch (NotFoundException $e) {\n            try {\n                return self::factory($name . 'Service', $arguments);\n            } catch (NotFoundException $ex) {\n                throw $e;\n            }\n        }\n    }\n\n    \/**\n     * Essaie de trouver un seul service\n     *\n     * @return mixed\n     *\/\n    private static function discoverServiceSingleton(string $name)\n    {\n        try {\n            return self::singleton($name);\n        } catch (NotFoundException $e) {\n            try {\n                return self::singleton($name . 'Service');\n            } catch (NotFoundException $ex) {\n                throw $e;\n            }\n        }\n    }\n\n    \/**\n     * Injecter une seule instance de la classe donn\u00e9e\n     *\n     * @return mixed\n     *\/\n    public static function singleton(string $name)\n    {\n        return self::injector()->get($name);\n    }\n\n    \/**\n     * Injecter une nouvelle instance de la classe donn\u00e9e\n     *\n     * @return mixed\n     *\/\n    public static function factory(string $name, array $arguments = [])\n    {\n        return self::injector()->make($name, $arguments);\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,2,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,2,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,0,null,null,null]},{"name":"src\\Output\\Language.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Output;\n\nuse BlitzPHP\\Config\\Config;\nuse BlitzPHP\\Loader\\FileLocator;\nuse BlitzPHP\\Loader\\Services;\nuse BlitzPHP\\Utilities\\Arr;\nuse MessageFormatter;\n\nclass Language\n{\n    \/**\n     * Stores the retrieved language lines\n     * from files for faster retrieval on\n     * second use.\n     *\n     * @var array\n     *\/\n    protected $language = [];\n\n    \/**\n     * The current language\/locale to work with.\n     *\n     * @var string\n     *\/\n    protected $locale;\n\n    \/**\n     * Boolean value whether the intl\n     * libraries exist on the system.\n     *\n     * @var bool\n     *\/\n    protected $intlSupport = false;\n\n    \/**\n     * Stores filenames that have been\n     * loaded so that we don't load them again.\n     *\n     * @var array\n     *\/\n    protected $loadedFiles = [];\n\n    public function __construct()\n    {\n        if (class_exists('\\MessageFormatter')) {\n            $this->intlSupport = true;\n        }\n    }\n\n    \/**\n     * Sets the current locale to use when performing string lookups.\n     *\/\n    public function setLocale(?string $locale = null): self\n    {\n        $this->findLocale($locale);\n\n        return $this;\n    }\n\n    \/**\n     * Gets the current locale, with a fallback to the default\n     * locale if none is set.\n     *\/\n    public function getLocale(): string\n    {\n        if (empty($this->locale)) {\n            $this->findLocale();\n        }\n\n        return $this->locale;\n    }\n\n    \/**\n     * Parses the language string for a file, loads the file, if necessary,\n     * getting the line.\n     *\n     * @param string $line Line.\n     * @param array  $args Arguments.\n     *\n     * @return string|string[] Returns line.\n     *\/\n    public function getLine(string $line, ?array $args = [])\n    {\n        \/\/ ignore requests with no file specified\n        if (! strpos($line, '.')) {\n            return $line;\n        }\n        if (empty($args)) {\n            $args = [];\n        }\n\n        \/\/ Parse out the file name and the actual alias.\n        \/\/ Will load the language file and strings.\n        [\n            $file,\n            $parsedLine,\n        ] = $this->parseLine($line, $this->locale);\n\n        $output = Arr::getRecursive($this->language[$this->locale][$file], $parsedLine);\n\n        if ($output === null && strpos($this->locale, '-')) {\n            [$locale] = explode('-', $this->locale, 2);\n\n            [\n                $file,\n                $parsedLine,\n            ] = $this->parseLine($line, $locale);\n\n            $output = Arr::getRecursive($this->language[$locale][$file], $parsedLine);\n        }\n\n        \/\/ if still not found, try English\n        if (empty($output)) {\n            $this->parseLine($line, 'en');\n\n            $output = Arr::getRecursive($this->language[$this->locale][$file], $parsedLine);\n            \/\/$output = $this->language['en'][$file][$parsedLine] ?? null;\n        }\n\n        $output ??= $line;\n\n        if (! empty($args)) {\n            $output = $this->formatMessage($output, $args);\n        }\n\n        return $output;\n    }\n\n    \/**\n     * Parses the language string which should include the\n     * filename as the first segment (separated by period).\n     *\/\n    protected function parseLine(string $line, string $locale): array\n    {\n        $file = substr($line, 0, strpos($line, '.'));\n        $line = substr($line, strlen($file) + 1);\n\n        \/*\n        $line = explode('.', $line);\n        $file = array_shift($line);\n        $line = implode('.', $line);\n        *\/\n\n        if (! isset($this->language[$locale][$file]) || ! array_key_exists($line, $this->language[$locale][$file])) {\n            $this->load($file, $locale);\n        }\n\n        return [\n            $file,\n            $line,\n        ];\n    }\n\n    \/**\n     * Advanced message formatting.\n     *\n     * @param array|string $message Message.\n     * @param array        $args    Arguments.\n     *\n     * @return array|string Returns formatted message.\n     *\/\n    protected function formatMessage($message, array $args = [])\n    {\n        if (! $this->intlSupport || ! $args) {\n            return $message;\n        }\n\n        if (is_array($message)) {\n            foreach ($message as $index => $value) {\n                $message[$index] = $this->formatMessage($value, $args);\n            }\n\n            return $message;\n        }\n\n        return MessageFormatter::formatMessage($this->locale, $message, $args);\n    }\n\n    \/**\n     * Charge un fichier de langue dans les param\u00e8tres r\u00e9gionaux actuels. Si $return est vrai,\n     * renverra le contenu du fichier, sinon fusionnera avec\n     * les lignes linguistiques existantes.\n     *\n     * @return array|void\n     *\/\n    protected function load(string $file, string $locale, bool $return = false)\n    {\n        if (! array_key_exists($locale, $this->loadedFiles)) {\n            $this->loadedFiles[$locale] = [];\n        }\n        if (in_array($file, $this->loadedFiles[$locale], true)) {\n            \/\/ Don't load it more than once.\n            return [];\n        }\n        if (! array_key_exists($locale, $this->language)) {\n            $this->language[$locale] = [];\n        }\n\n        if (! array_key_exists($file, $this->language[$locale])) {\n            $this->language[$locale][$file] = [];\n        }\n\n        $lang = FileLocator::lang($file, $locale);\n\n        if ($return) {\n            return $lang;\n        }\n\n        $this->loadedFiles[$locale][] = $file;\n\n        \/\/ Merge our string\n        $this->language[$locale][$file] = $lang;\n    }\n\n    \/**\n     * Cherche la locale appropriee par rapport a la requete de l'utilisateur\n     *\/\n    public static function searchLocale(?string $locale = null): string\n    {\n        $config = Config::get('app');\n\n        if (empty($locale)) {\n            $locale = Services::negotiator()->language($config['supported_locales']);\n        }\n        if (empty($locale)) {\n            $locale = $config['language'];\n        }\n\n        return self::normalizeLocale(empty($locale) ? 'en' : $locale);\n    }\n\n    private function findLocale(?string $locale = null): string\n    {\n        $this->locale = self::searchLocale($locale);\n\n        return $this->locale;\n    }\n\n    \/**\n     * Valide la langue entree\n     *\/\n    private static function normalizeLocale(string $locale): string\n    {\n        return $locale;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,0,null,0,null,null,null,null,0,null,0,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null]},{"name":"src\\Router\\Dispatcher.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Router;\n\nuse BlitzPHP\\Contracts\\Router\\RouteCollectionInterface;\nuse BlitzPHP\\Debug\\Timer;\nuse BlitzPHP\\Exceptions\\FrameworkException;\nuse BlitzPHP\\Exceptions\\PageNotFoundException;\nuse BlitzPHP\\Exceptions\\RedirectException;\nuse BlitzPHP\\Http\\Middleware;\nuse BlitzPHP\\Http\\Response;\nuse BlitzPHP\\Http\\ServerRequest;\nuse BlitzPHP\\Http\\Uri;\nuse BlitzPHP\\Loader\\Services;\nuse BlitzPHP\\Traits\\SingletonTrait;\nuse BlitzPHP\\View\\View;\nuse Closure;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse stdClass;\n\nclass Dispatcher\n{\n    use SingletonTrait;\n\n    \/**\n     * Heure de d\u00e9marrage de l'application.\n     *\n     * @var mixed\n     *\/\n    protected $startTime;\n\n    \/**\n     * Dur\u00e9e totale d'ex\u00e9cution de l'application\n     *\n     * @var float\n     *\/\n    protected $totalTime;\n\n    \/**\n     * Main application configuration\n     *\n     * @var stdClass\n     *\/\n    protected $config;\n\n    \/**\n     * instance Timer.\n     *\n     * @var Timer\n     *\/\n    protected $timer;\n\n    \/**\n     * requ\u00eate courrante.\n     *\n     * @var ServerRequest\n     *\/\n    protected $request;\n\n    \/**\n     * Reponse courrante.\n     *\n     * @var Response\n     *\/\n    protected $response;\n\n    \/**\n     * Router \u00e0 utiliser.\n     *\n     * @var Router\n     *\/\n    protected $router;\n\n    \/**\n     * @var Middleware\n     *\/\n    private $middleware;\n\n    \/**\n     * Contr\u00f4leur \u00e0 utiliser.\n     *\n     * @var Closure|string\n     *\/\n    protected $controller;\n\n    \/**\n     * M\u00e9thode du ontr\u00f4leur \u00e0 ex\u00e9cuter.\n     *\n     * @var string\n     *\/\n    protected $method;\n\n    \/**\n     * Gestionnaire de sortie \u00e0 utiliser.\n     *\n     * @var string\n     *\/\n    protected $output;\n\n    \/**\n     * D\u00e9lai d'expiration du cache\n     *\n     * @var int\n     *\/\n    protected static $cacheTTL = 0;\n\n    \/**\n     * Chemin de requ\u00eate \u00e0 utiliser.\n     *\n     * @var string\n     *\/\n    protected $path;\n\n    \/**\n     * L'instance Response doit-elle \"faire semblant\"\n     * pour \u00e9viter de d\u00e9finir des en-t\u00eates\/cookies\/etc\n     *\n     * @var bool\n     *\/\n    protected $useSafeOutput = false;\n\n    \/**\n     * Constructor.\n     *\/\n    private function __construct()\n    {\n        $this->startTime = microtime(true);\n\n        $this->config = (object) config('app');\n        $this->initMiddlewareQueue();\n    }\n\n    public static function init(bool $returnResponse = false)\n    {\n        return self::instance()->run(null, $returnResponse);\n    }\n\n    \/**\n     * Retourne la methode invoquee\n     *\/\n    public static function getMethod(): ?string\n    {\n        $method = self::instance()->method;\n        if (empty($method)) {\n            $method = Services::routes()->getDefaultMethod();\n        }\n\n        return $method;\n    }\n\n    \/**\n     * Lancez l'application !\n     *\n     * C'est \"la boucle\" si vous voulez. Le principal point d'entr\u00e9e dans le script\n     * qui obtient les instances de classe requises, d\u00e9clenche les filtres,\n     * essaie d'acheminer la r\u00e9ponse, charge le contr\u00f4leur et g\u00e9n\u00e9ralement\n     * fait fonctionner toutes les pi\u00e8ces ensemble.\n     *\n     * @throws Exception\n     * @throws RedirectException\n     *\n     * @return bool|mixed|ResponseInterface|ServerRequestInterface\n     *\/\n    public function run(?RouteCollectionInterface $routes = null, bool $returnResponse = false)\n    {\n        $this->startBenchmark();\n\n        $this->getRequestObject();\n        $this->getResponseObject();\n\n        $this->forceSecureAccess();\n\n        $this->spoofRequestMethod();\n\n        \/**\n         * Init event manager\n         *\/\n        $events_file = CONFIG_PATH . 'events.php';\n        if (file_exists($events_file)) {\n            require_once $events_file;\n        }\n\n        Services::event()->trigger('pre_system');\n\n        \/\/ Recherche une page en cache. L'ex\u00e9cution s'arr\u00eatera\n        \/\/ si la page a \u00e9t\u00e9 mise en cache.\n        $response = $this->displayCache();\n        if ($response instanceof ResponseInterface) {\n            if ($returnResponse) {\n                return $response;\n            }\n\n            return $this->emitResponse($response);\n        }\n\n        try {\n            return $this->handleRequest($routes, $returnResponse);\n        } catch (RedirectException $e) {\n            Services::logger()->info('REDIRECTED ROUTE at ' . $e->getMessage());\n\n            \/\/ Si la route est une route de \"redirection\", elle lance\n            \/\/ l'exception avec le $to comme message\n            \/\/ $this->response->redirect(base_url($e->getMessage()), 'auto', $e->getCode());\n            $this->response = $this->response->withHeader('Location', base_url($e->getMessage()), 'auto', $e->getCode());\n\n            $this->sendResponse();\n\n            $this->callExit(EXIT_SUCCESS);\n\n            return;\n        } catch (PageNotFoundException $e) {\n            $this->display404errors($e);\n        }\n    }\n\n    \/**\n     * D\u00e9finissez notre instance Response sur le mode \"faire semblant\" afin que des choses comme\n     * les cookies et les en-t\u00eates ne sont pas r\u00e9ellement envoy\u00e9s, permettant \u00e0 PHP 7.2+ de\n     * ne pas se plaindre lorsque la fonction ini_set() est utilis\u00e9e.\n     *\/\n    public function useSafeOutput(bool $safe = true): self\n    {\n        $this->useSafeOutput = $safe;\n\n        return $this;\n    }\n\n    \/**\n     * Handles the main request logic and fires the controller.\n     *\n     * @throws PageNotFoundException\n     * @throws RedirectException\n     *\n     * @return mixed|RequestInterface|ResponseInterface\n     *\/\n    protected function handleRequest(?RouteCollectionInterface $routes = null, bool $returnResponse = false)\n    {\n        if (empty($routes)) {\n            $routes_file = CONFIG_PATH . 'routes.php';\n\n            if (file_exists($routes_file)) {\n                require_once $routes_file;\n            }\n        }\n        if (empty($routes) || ! ($routes instanceof RouteCollection)) {\n            $routes = Services::routes();\n        }\n\n        \/**\n         * Route middlewares\n         *\/\n        $routeMiddlewares = (array) $this->dispatchRoutes($routes);\n\n        \/\/ The bootstrapping in a middleware\n        $this->middleware->append(function (ServerRequestInterface $request, ResponseInterface $response, callable $next): ResponseInterface {\n            $returned = $this->startController($request, $response);\n\n            \/\/ Closure controller has run in startController().\n            if (! is_callable($this->controller)) {\n                $controller = $this->createController($request, $response);\n\n                if (! method_exists($controller, '_remap') && ! is_callable([$controller, $this->method], false)) {\n                    throw PageNotFoundException::methodNotFound($this->method);\n                }\n\n                \/\/ Is there a \"post_controller_constructor\" event?\n                Services::event()->trigger('post_controller_constructor');\n\n                $returned = $this->runController($controller);\n            } else {\n                $this->timer->stop('controller_constructor');\n                $this->timer->stop('controller');\n            }\n\n            Services::event()->trigger('post_system');\n\n            if ($returned instanceof ResponseInterface) {\n                $response = $returned;\n            }\n\n            return $response;\n        });\n\n        \/**\n         * Ajouter des middlewares de routes\n         *\/\n        foreach ($routeMiddlewares as $middleware) {\n            $this->middleware->prepend($middleware);\n        }\n\n        \/\/ Enregistrer notre URI actuel en tant qu'URI pr\u00e9c\u00e9dent dans la session\n        \/\/ pour une utilisation plus s\u00fbre et plus pr\u00e9cise avec la fonction d'assistance `previous_url()`.\n        $this->storePreviousURL(current_url(true));\n\n        \/**\n         * Emission de la reponse\n         *\/\n        $this->gatherOutput($this->middleware->handle($this->request));\n\n        if (! $returnResponse) {\n            $this->sendResponse();\n        }\n\n        \/\/ Y a-t-il un \u00e9v\u00e9nement post-syst\u00e8me ?\n        Services::event()->trigger('post_system');\n\n        return $this->response;\n    }\n\n    \/**\n     * D\u00e9marrer le benchmark\n     *\n     * La minuterie est utilis\u00e9e pour afficher l'ex\u00e9cution totale du script \u00e0 la fois dans la\n     * barre d'outils de d\u00e9bogage, et \u00e9ventuellement sur la page affich\u00e9e.\n     *\/\n    protected function startBenchmark()\n    {\n        if ($this->startTime === null) {\n            $this->startTime = microtime(true);\n        }\n\n        $this->timer = Services::timer();\n        $this->timer->start('total_execution', $this->startTime);\n        $this->timer->start('bootstrap');\n    }\n\n    \/**\n     * D\u00e9finit un objet Request \u00e0 utiliser pour cette requ\u00eate.\n     * Utilis\u00e9 lors de l'ex\u00e9cution de certains tests.\n     *\/\n    public function setRequest(ServerRequestInterface $request): self\n    {\n        $this->request = $request;\n\n        return $this;\n    }\n\n    \/**\n     * Obtenez notre objet Request et d\u00e9finissez le protocole du serveur en fonction des informations fournies\n     * par le serveur.\n     *\/\n    protected function getRequestObject()\n    {\n        if ($this->request instanceof ServerRequestInterface) {\n            return;\n        }\n\n        if (is_cli() && ! on_test()) {\n            \/\/ @codeCoverageIgnoreStart\n            \/\/ $this->request = Services::clirequest($this->config);\n        \/\/ @codeCoverageIgnoreEnd\n        }\n\n        $version = $_SERVER['SERVER_PROTOCOL'] ?? 'HTTP\/1.1';\n        if (! is_numeric($version)) {\n            $version = substr($version, strpos($version, '\/') + 1);\n        }\n\n        \/\/ Assurez-vous que la version est au bon format\n        $version = number_format((float) $version, 1);\n\n        $this->request = Services::request()->withProtocolVersion($version);\n    }\n\n    \/**\n     * Obtenez notre objet Response et d\u00e9finissez des valeurs par d\u00e9faut, notamment\n     * la version du protocole HTTP et une r\u00e9ponse r\u00e9ussie par d\u00e9faut.\n     *\/\n    protected function getResponseObject()\n    {\n        \/\/ Supposons le succ\u00e8s jusqu'\u00e0 preuve du contraire.\n        $this->response = Services::response()->withStatus(200);\n\n        if (! is_cli() || on_test()) {\n        }\n\n        $this->response = $this->response->withProtocolVersion($this->request->getProtocolVersion());\n    }\n\n    \/**\n     * Forcer l'acc\u00e8s au site s\u00e9curis\u00e9 ? Si la valeur de configuration 'forceGlobalSecureRequests'\n     * est vrai, imposera que toutes les demandes adress\u00e9es \u00e0 ce site soient effectu\u00e9es via\n     * HTTPS. Redirigera \u00e9galement l'utilisateur vers la page actuelle avec HTTPS\n     * comme d\u00e9fini l'en-t\u00eate HTTP Strict Transport Security pour ces navigateurs\n     * qui le supportent.\n     *\n     * @param int $duration Combien de temps la s\u00e9curit\u00e9 stricte des transports\n     *                      doit \u00eatre appliqu\u00e9 pour cette URL.\n     *\/\n    protected function forceSecureAccess($duration = 31536000)\n    {\n        if ($this->config->force_global_secure_requests !== true) {\n            return;\n        }\n\n        force_https($duration, $this->request, $this->response);\n    }\n\n    \/**\n     * D\u00e9termine si une r\u00e9ponse a \u00e9t\u00e9 mise en cache pour l'URI donn\u00e9.\n     *\n     * @throws FrameworkException\n     *\n     * @return bool|ResponseInterface\n     *\/\n    public function displayCache()\n    {\n        if ($cachedResponse = Services::cache()->read($this->generateCacheName())) {\n            $cachedResponse = unserialize($cachedResponse);\n            if (! is_array($cachedResponse) || ! isset($cachedResponse['output']) || ! isset($cachedResponse['headers'])) {\n                throw new FrameworkException('Error unserializing page cache');\n            }\n\n            $headers = $cachedResponse['headers'];\n            $output  = $cachedResponse['output'];\n\n            \/\/ Effacer tous les en-t\u00eates par d\u00e9faut\n            foreach (array_keys($this->response->getHeaders()) as $key) {\n                $this->response = $this->response->withoutHeader($key);\n            }\n\n            \/\/ D\u00e9finir les en-t\u00eates mis en cache\n            foreach ($headers as $name => $value) {\n                $this->response = $this->response->withHeader($name, $value);\n            }\n\n            $output = $this->displayPerformanceMetrics($output);\n\n            return $this->response->withBody(to_stream($output));\n        }\n\n        return false;\n    }\n\n    \/**\n     * Indique \u00e0 l'application que la sortie finale doit \u00eatre mise en cache.\n     *\/\n    public static function cache(int $time)\n    {\n        static::$cacheTTL = $time;\n    }\n\n    \/**\n     * Met en cache la r\u00e9ponse compl\u00e8te de la requ\u00eate actuelle. Pour utiliser\n     * la mise en cache pleine page pour des performances tr\u00e8s \u00e9lev\u00e9es.\n     *\n     * @return mixed\n     *\/\n    protected function cachePage()\n    {\n        $headers = [];\n\n        foreach (array_keys($this->response->getHeaders()) as $header) {\n            $headers[$header] = $this->response->getHeaderLine($header);\n        }\n\n        return Services::cache()->write(\n            $this->generateCacheName(),\n            serialize(['headers' => $headers, 'output' => $this->output]),\n            static::$cacheTTL\n        );\n    }\n\n    \/**\n     * Renvoie un tableau avec nos statistiques de performances de base collect\u00e9es.\n     *\/\n    public function getPerformanceStats(): array\n    {\n        return [\n            'startTime' => $this->startTime,\n            'totalTime' => $this->totalTime,\n        ];\n    }\n\n    \/**\n     * G\u00e9n\u00e8re le nom du cache \u00e0 utiliser pour notre mise en cache pleine page.\n     *\/\n    protected function generateCacheName(): string\n    {\n        $uri = $this->request->getUri();\n\n        $name = Uri::createURIString($uri->getScheme(), $uri->getAuthority(), $uri->getPath());\n\n        return md5($name);\n    }\n\n    \/**\n     * Remplace les balises memory_usage et elapsed_time.\n     *\/\n    public function displayPerformanceMetrics(string $output): string\n    {\n        $this->totalTime = $this->timer->getElapsedTime('total_execution');\n\n        return str_replace('{elapsed_time}', (string) $this->totalTime, $output);\n    }\n\n    \/**\n     * Fonctionne avec le routeur pour\n     * faire correspondre une route \u00e0 l'URI actuel. Si la route est une\n     * \"route de redirection\", g\u00e9rera \u00e9galement la redirection.\n     *\n     * @param RouteCollectionInterface|null $routes Une interface de collecte \u00e0 utiliser \u00e0 la place\n     *                                              du fichier de configuration.\n     *\n     * @throws RedirectException\n     *\n     * @return string|string[]|null\n     *\/\n    protected function dispatchRoutes(RouteCollectionInterface $routes)\n    {\n        $this->router = Services::router($routes, $this->request, false);\n\n        $path = $this->determinePath();\n\n        $this->timer->stop('bootstrap');\n        $this->timer->start('routing');\n\n        ob_start();\n        $this->controller = $this->router->handle($path);\n        $this->method     = $this->router->methodName();\n\n        \/\/ Si un segment {locale} correspondait dans la route finale,\n        \/\/ alors nous devons d\u00e9finir les param\u00e8tres r\u00e9gionaux corrects sur notre requ\u00eate.\n        if ($this->router->hasLocale()) {\n            $this->request = $this->request->withLocale($this->router->getLocale());\n        }\n\n        $this->timer->stop('routing');\n\n        return $this->router->getMiddlewares();\n    }\n\n    \/**\n     * D\u00e9termine le chemin \u00e0 utiliser pour que nous essayions d'acheminer vers, en fonction\n     * de l'entr\u00e9e de l'utilisateur (setPath), ou le chemin CLI\/IncomingRequest.\n     *\/\n    protected function determinePath(): string\n    {\n        if (! empty($this->path)) {\n            return $this->path;\n        }\n\n        return method_exists($this->request, 'getPath')\n            ? $this->request->getPath()\n            : $this->request->getUri()->getPath();\n    }\n\n    \/**\n     * Permet de d\u00e9finir le chemin de la requ\u00eate depuis l'ext\u00e9rieur de la classe,\n     * au lieu de compter sur CLIRequest ou IncomingRequest pour le chemin.\n     *\n     * Ceci est principalement utilis\u00e9 par la console.\n     *\/\n    public function setPath(string $path): self\n    {\n        $this->path = $path;\n\n        return $this;\n    }\n\n    \/**\n     * Modifie l'objet de requ\u00eate pour utiliser une m\u00e9thode diff\u00e9rente\n     * si une variable POST appel\u00e9e _method est trouv\u00e9e.\n     *\/\n    private function spoofRequestMethod()\n    {\n        \/\/ Ne fonctionne qu'avec les formulaires POST\n        if ($this->request->getMethod() !== 'post') {\n            return;\n        }\n\n        $post = $this->request->getParsedBody();\n\n        if (empty($post['_method'])) {\n            return;\n        }\n\n        \/\/ Accepte seulement PUT, PATCH, DELETE\n        if (in_array(strtoupper($post['_method']), ['PUT', 'PATCH', 'DELETE'], true)) {\n            $this->request = $this->request->withMethod($post['_method']);\n        }\n    }\n\n    \/**\n     * Maintenant que tout a \u00e9t\u00e9 configur\u00e9, cette m\u00e9thode tente d'ex\u00e9cuter le\n     * m\u00e9thode du contr\u00f4leur et lancez le script. S'il n'en est pas capable, le fera\n     * afficher l'erreur Page introuvable appropri\u00e9e.\n     *\/\n    protected function startController(ServerRequest $request, Response $response)\n    {\n        \/\/ Aucun contr\u00f4leur sp\u00e9cifi\u00e9 - nous ne savons pas quoi faire maintenant.\n        if (empty($this->controller)) {\n            throw PageNotFoundException::emptyController();\n        }\n\n        $this->timer->start('controller');\n        $this->timer->start('controller_constructor');\n\n        \/\/ Est-il achemin\u00e9 vers une Closure ?\n        if (is_object($this->controller) && (get_class($this->controller) === 'Closure')) {\n            $controller = $this->controller;\n\n            $sendParameters = [];\n\n            foreach ($this->router->params() as $parameter) {\n                $sendParameters[] = $parameter;\n            }\n            array_push($sendParameters, $request, $response);\n\n            return Services::injector()->call($controller, $sendParameters);\n        }\n\n        \/\/ Essayez de charger automatiquement la classe\n        if (! class_exists($this->controller, true) || $this->method[0] === '_') {\n            throw PageNotFoundException::controllerNotFound($this->controller, $this->method);\n        }\n\n        return null;\n    }\n\n    \/**\n     * Instancie la classe contr\u00f4leur.\n     *\n     * @return \\BlitzPHP\\Controllers\\BaseController|mixed\n     *\/\n    private function createController(ServerRequestInterface $request, ResponseInterface $response)\n    {\n        \/**\n         * @var \\BlitzPHP\\Controllers\\BaseController\n         *\/\n        $class = Services::injector()->get($this->controller);\n\n        if (method_exists($class, 'initialize')) {\n            $class->initialize($request, $response, Services::logger());\n        }\n\n        $this->timer->stop('controller_constructor');\n\n        return $class;\n    }\n\n    \/**\n     * Ex\u00e9cute le contr\u00f4leur, permettant aux m\u00e9thodes _remap de fonctionner.\n     *\n     * @param mixed $class\n     *\n     * @return mixed\n     *\/\n    protected function runController($class)\n    {\n        \/\/ S'il s'agit d'une demande de console, utilisez les segments d'entr\u00e9e comme param\u00e8tres\n        $params = defined('KLINGED') ? $this->request->getSegments() : $this->router->params();\n        $method = $this->method;\n\n        if (method_exists($class, '_remap')) {\n            $params = [$method, $params];\n            $method = '_remap';\n        }\n\n        $output = Services::injector()->call([$class, $method], (array) $params);\n\n        $this->timer->stop('controller');\n\n        if ($output instanceof View) {\n            $output = $this->response->withBody(to_stream($output->get()));\n        }\n\n        return $output;\n    }\n\n    \/**\n     * Affiche une page d'erreur 404 introuvable. S'il est d\u00e9fini, essaiera de\n     * appelez le contr\u00f4leur\/m\u00e9thode 404Override qui a \u00e9t\u00e9 d\u00e9fini dans la configuration de routage.\n     *\/\n    protected function display404errors(PageNotFoundException $e)\n    {\n        \/\/ Is there a 404 Override available?\n        if ($override = $this->router->get404Override()) {\n            if ($override instanceof Closure) {\n                echo $override($e->getMessage());\n            } elseif (is_array($override)) {\n                $this->timer->start('controller');\n                $this->timer->start('controller_constructor');\n\n                $this->controller = $override[0];\n                $this->method     = $override[1];\n\n                $controller = $this->createController($this->request, $this->response);\n                $this->runController($controller);\n            }\n\n            unset($override);\n\n            $this->emitResponse();\n\n            return;\n        }\n\n        \/\/ Affiche l'erreur 404\n        $this->response = $this->response->withStatus($e->getCode());\n\n        if (! on_test()) {\n            \/\/ @codeCoverageIgnoreStart\n            if (ob_get_level() > 0) {\n                ob_end_flush();\n            }\n            \/\/ @codeCoverageIgnoreEnd\n        }\n        \/\/ Lors des tests, l'un est pour phpunit, l'autre pour le cas de test.\n        elseif (ob_get_level() > 2) {\n            ob_end_flush(); \/\/ @codeCoverageIgnore\n        }\n\n        throw PageNotFoundException::pageNotFound(! on_prod() || is_cli() ? $e->getMessage() : '');\n    }\n\n    \/**\n     * Rassemble la sortie du script \u00e0 partir du tampon, remplace certaines balises d'ex\u00e9cutions\n     * d'horodatage dans la sortie et affiche la barre d'outils de d\u00e9bogage, si n\u00e9cessaire.\n     *\n     * @param mixed|null $returned\n     *\/\n    protected function gatherOutput($returned = null)\n    {\n        $this->output = ob_get_contents();\n        \/\/ Si la mise en m\u00e9moire tampon n'est pas nulle.\n        \/\/ Nettoyer (effacer) le tampon de sortie et d\u00e9sactiver le tampon de sortie\n        if (ob_get_length()) {\n            ob_end_clean();\n        }\n\n        \/\/ Si le contr\u00f4leur a renvoy\u00e9 un objet de r\u00e9ponse,\n        \/\/ nous devons en saisir le corps pour qu'il puisse\n        \/\/ \u00eatre ajout\u00e9 \u00e0 tout ce qui aurait d\u00e9j\u00e0 pu \u00eatre ajout\u00e9 avant de faire le \u00e9cho.\n        \/\/ Nous devons \u00e9galement enregistrer l'instance localement\n        \/\/ afin que tout changement de code d'\u00e9tat, etc., ait lieu.\n        if ($returned instanceof ResponseInterface) {\n            $this->response = $returned;\n            $returned       = $returned->getBody()->getContents();\n        }\n\n        if (is_string($returned)) {\n            $this->output .= $returned;\n        }\n\n        \/\/ Mettez-le en cache sans remplacer les mesures de performances\n        \/\/ afin que nous puissions avoir des mises \u00e0 jour de vitesse en direct en cours de route.\n        if (static::$cacheTTL > 0) {\n            $this->cachePage();\n        }\n\n        $this->output = $this->displayPerformanceMetrics($this->output);\n\n        $this->response = $this->response->withBody(to_stream($this->output));\n    }\n\n    \/**\n     * Si nous avons un objet de session \u00e0 utiliser, stockez l'URI actuel\n     * comme l'URI pr\u00e9c\u00e9dent. Ceci est appel\u00e9 juste avant d'envoyer la\n     * r\u00e9ponse au client, et le rendra disponible \u00e0 la prochaine demande.\n     *\n     * Cela permet au fournisseur une d\u00e9tection plus s\u00fbre et plus fiable de la fonction previous_url().\n     *\n     * @param \\BlitzPHP\\Http\\URI|string $uri\n     *\/\n    public function storePreviousURL($uri)\n    {\n        \/\/ Ignorer les requ\u00eates CLI\n        if (is_cli() && ! on_test()) {\n            return; \/\/ @codeCoverageIgnore\n        }\n\n        \/\/ IIgnorer les requ\u00eates AJAX\n        if (method_exists($this->request, 'isAJAX') && $this->request->isAJAX()) {\n            return;\n        }\n\n        \/\/ Ceci est principalement n\u00e9cessaire lors des tests ...\n        if (is_string($uri)) {\n            $uri = Services::uri($uri, false);\n        }\n\n        if (isset($_SESSION)) {\n            $_SESSION['_blitz_previous_url'] = Uri::createURIString(\n                $uri->getScheme(),\n                $uri->getAuthority(),\n                $uri->getPath(),\n                $uri->getQuery(),\n                $uri->getFragment()\n            );\n        }\n    }\n\n    \/**\n     * Renvoie la sortie de cette requ\u00eate au client.\n     * C'est ce qu'il attendait !\n     *\/\n    protected function sendResponse()\n    {\n        $this->totalTime = $this->timer->getElapsedTime('total_execution');\n\n        Services::emitter()->emit(\n            $this->response\n            \/\/ Services::toolbar()->prepare($this, $this->request, $this->response)\n        );\n    }\n\n    protected function emitResponse()\n    {\n        $this->gatherOutput();\n        $this->sendResponse();\n    }\n\n    \/**\n     * Quitte l'application en d\u00e9finissant le code de sortie pour les applications bas\u00e9es sur CLI\n     * qui pourrait regarder.\n     *\n     * Fabriqu\u00e9 dans une m\u00e9thode distincte afin qu'il puisse \u00eatre simul\u00e9 pendant les tests\n     * sans r\u00e9ellement arr\u00eater l'ex\u00e9cution du script.\n     *\/\n    protected function callExit(int $code)\n    {\n        exit($code); \/\/ @codeCoverageIgnore\n    }\n\n    \/**\n     * Initialise le gestionnaire de middleware\n     *\/\n    protected function initMiddlewareQueue(): void\n    {\n        $this->middleware = Services::injector()->make(Middleware::class, [$this->response]);\n\n        $middlewaresFile = CONFIG_PATH . 'middlewares.php';\n        if (file_exists($middlewaresFile) && ! in_array($middlewaresFile, get_included_files(), true)) {\n            $middleware = require $middlewaresFile;\n            if (is_callable($middleware)) {\n                $middlewareQueue = $middleware($this->middleware, $this->request);\n                if ($middlewareQueue instanceof Middleware) {\n                    $this->middleware = $middlewareQueue;\n                }\n            }\n        }\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,null,null,null,null,0,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,null,0,null,0,null,null,null,null,0,null,0,null,null,0,null,null,null,0,null,null,0,null,null,0,null,null,null,0,null,0,null,null,null,null,0,null,0,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,0,null,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,0,null,null,null,0,null,0,null,0,0,null,null,0,null,null,0,null,null,0,0,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,0,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,0,0,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,0,null,null,null,0,null,null,null,null,0,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,0,null,0,0,0,null,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,0,null,null,null,0,null,0,null,null,0,null,0,null,0,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,0,null,null,0,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,null,0,0,null,0,0,null,null,0,null,0,null,0,null,null,null,0,null,null,null,null,0,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,0,0,null,null,null,0,null,null,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,0,null,0,null,0,null,0,null,null,null,null,null,null]},{"name":"src\\Router\\RouteCollection.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Router;\n\nuse BlitzPHP\\Contracts\\Router\\RouteCollectionInterface;\nuse BlitzPHP\\Exceptions\\RouterException;\nuse BlitzPHP\\Loader\\Services;\nuse Closure;\nuse InvalidArgumentException;\n\nclass RouteCollection implements RouteCollectionInterface\n{\n    \/**\n     * L'espace de noms \u00e0 ajouter \u00e0 tous les contr\u00f4leurs.\n     * Par d\u00e9faut, les espaces de noms globaux (\\)\n     *\n     * @var string\n     *\/\n    protected $defaultNamespace = '\\\\';\n\n    \/**\n     * Le nom du contr\u00f4leur par d\u00e9faut \u00e0 utiliser\n     * lorsqu'aucun autre contr\u00f4leur n'est sp\u00e9cifi\u00e9.\n     *\n     * Non utilis\u00e9 ici. Valeur d'intercommunication pour la classe Routeur.\n     *\n     * @var string\n     *\/\n    protected $defaultController = 'Home';\n\n    \/**\n     * Le nom de la m\u00e9thode par d\u00e9faut \u00e0 utiliser\n     * lorsqu'aucune autre m\u00e9thode n'a \u00e9t\u00e9 sp\u00e9cifi\u00e9e.\n     *\n     * Non utilis\u00e9 ici. Valeur d'intercommunication pour la classe Routeur.\n     *\n     * @var string\n     *\/\n    protected $defaultMethod = 'index';\n\n    \/**\n     * L'espace r\u00e9serv\u00e9 utilis\u00e9 lors du routage des \"ressources\"\n     * lorsqu'aucun autre espace r\u00e9serv\u00e9 n'a \u00e9t\u00e9 sp\u00e9cifi\u00e9.\n     *\n     * @var string\n     *\/\n    protected $defaultPlaceholder = 'any';\n\n    \/**\n     * S'il faut faire correspondre l'URI aux contr\u00f4leurs\n     * lorsqu'il ne correspond pas aux itin\u00e9raires d\u00e9finis.\n     *\n     * Non utilis\u00e9 ici. Valeur d'intercommunication pour la classe Routeur.\n     *\n     * @var bool\n     *\/\n    protected $autoRoute = true;\n\n    \/**\n     * Un appelable qui sera affich\u00e9\n     * lorsque la route ne peut pas \u00eatre match\u00e9e.\n     *\n     * @var Closure|string\n     *\/\n    protected $override404;\n\n    \/**\n     * Espaces r\u00e9serv\u00e9s d\u00e9finis pouvant \u00eatre utilis\u00e9s\n     *\n     * @var array\n     *\/\n    protected $placeholders = [\n        'any'      => '.*',\n        'segment'  => '[^\/]+',\n        'alphanum' => '[a-zA-Z0-9]+',\n        'num'      => '[0-9]+',\n        'alpha'    => '[a-zA-Z]+',\n        'hash'     => '[^\/]+',\n        'slug'     => '[a-z0-9-]+',\n    ];\n\n    \/**\n     * Tableau de toutes les routes et leurs mappages.\n     *\n     * @var array\n     *\/\n    protected $routes = [\n        '*'       => [],\n        'options' => [],\n        'get'     => [],\n        'head'    => [],\n        'post'    => [],\n        'put'     => [],\n        'delete'  => [],\n        'trace'   => [],\n        'connect' => [],\n        'cli'     => [],\n    ];\n\n    \/**\n     * Tableaux des options des routes\n     *\n     * @var array\n     *\/\n    protected $routesOptions = [];\n\n    \/**\n     * La m\u00e9thode actuelle par laquelle le script est appel\u00e9.\n     *\n     * @var string\n     *\/\n    protected $HTTPVerb = '*';\n\n    \/**\n     * La liste par d\u00e9faut des m\u00e9thodes HTTP (et CLI pour l'utilisation de la ligne de commande)\n     * qui est autoris\u00e9 si aucune autre m\u00e9thode n'est fournie.\n     *\n     * @var array\n     *\/\n    protected $defaultHTTPMethods = [\n        'options',\n        'get',\n        'head',\n        'post',\n        'put',\n        'delete',\n        'trace',\n        'connect',\n        'cli',\n    ];\n\n    \/**\n     * Le nom du groupe de route courant\n     *\n     * @var string|null\n     *\/\n    protected $group;\n\n    \/**\n     * Le sous domaine courant\n     *\n     * @var string|null\n     *\/\n    protected $currentSubdomain;\n\n    \/**\n     * Stocke une copie des options actuelles en cours appliqu\u00e9 lors de la cr\u00e9ation.\n     *\n     * @var array|null\n     *\/\n    protected $currentOptions;\n\n    \/**\n     * Un petit booster de performances.\n     *\n     * @var bool\n     *\/\n    protected $didDiscover = false;\n\n    \/**\n     * Handle to the file locator to use.\n     *\n     * @var FileLocator\n     *\/\n    protected $fileLocator;\n\n    \/**\n     * Handle to the modules config.\n     *\n     * @var Modules\n     *\/\n    protected $moduleConfig;\n\n    \/**\n     * Flag for sorting routes by priority.\n     *\n     * @var bool\n     *\/\n    protected $prioritize = false;\n\n    \/**\n     * Route priority detection flag.\n     *\n     * @var bool\n     *\/\n    protected $prioritizeDetected = false;\n\n    \/**\n     * Constructor\n     *\n     * @param mixed $placeholder\n     *\/\n    \/* public function __construct(FileLocator $locator, Modules $moduleConfig)\n    {\n        $this->fileLocator  = $locator;\n        $this->moduleConfig = $moduleConfig;\n    } *\/\n\n    \/**\n     * Enregistre une nouvelle contrainte aupr\u00e8s du syst\u00e8me. Les contraintes sont utilis\u00e9es\n     * par les routes en tant qu'espaces r\u00e9serv\u00e9s pour les expressions r\u00e9guli\u00e8res afin de d\u00e9finir\n     * les parcours plus humains.\n     *\n     * Vous pouvez passer un tableau associatif en tant que $placeholder et avoir\n     * plusieurs espaces r\u00e9serv\u00e9s ajout\u00e9s \u00e0 la fois.\n     *\n     * @param array|string $placeholder\n     *\/\n    public function addPlaceholder($placeholder, ?string $pattern = null): self\n    {\n        if (! is_array($placeholder)) {\n            $placeholder = [$placeholder => $pattern];\n        }\n\n        $this->placeholders = array_merge($this->placeholders, $placeholder);\n\n        return $this;\n    }\n\n    \/**\n     * D\u00e9finit l'espace de noms par d\u00e9faut \u00e0 utiliser pour les contr\u00f4leurs lorsqu'aucun autre n'a \u00e9t\u00e9 sp\u00e9cifi\u00e9.\n     *\/\n    public function setDefaultNamespace(string $value): self\n    {\n        $this->defaultNamespace = filter_var(strip_tags($value), FILTER_SANITIZE_STRING);\n        $this->defaultNamespace = rtrim($this->defaultNamespace, '\\\\') . '\\\\';\n\n        return $this;\n    }\n\n    \/**\n     * D\u00e9finit le contr\u00f4leur par d\u00e9faut \u00e0 utiliser lorsqu'aucun autre contr\u00f4leur n'a \u00e9t\u00e9 sp\u00e9cifi\u00e9.\n     *\/\n    public function setDefaultController(string $value): self\n    {\n        $this->defaultController = filter_var(strip_tags($value), FILTER_SANITIZE_STRING);\n\n        return $this;\n    }\n\n    \/**\n     * D\u00e9finit la m\u00e9thode par d\u00e9faut pour appeler le contr\u00f4leur lorsqu'aucun autre\n     * m\u00e9thode a \u00e9t\u00e9 d\u00e9finie dans la route.\n     *\/\n    public function setDefaultMethod(string $value): self\n    {\n        $this->defaultMethod = filter_var(strip_tags($value), FILTER_SANITIZE_STRING);\n\n        return $this;\n    }\n\n    \/**\n     * Si TRUE, le syst\u00e8me tentera de faire correspondre l'URI avec\n     * Contr\u00f4leurs en faisant correspondre chaque segment avec des dossiers\/fichiers\n     * dans CONTROLLER_PATH, lorsqu'aucune correspondance n'a \u00e9t\u00e9 trouv\u00e9e pour les routes d\u00e9finies.\n     *\n     * Si FAUX, la recherche s'arr\u00eatera et n'effectuera AUCUN routage automatique.\n     *\/\n    public function setAutoRoute(bool $value): self\n    {\n        $this->autoRoute = $value;\n\n        return $this;\n    }\n\n    \/**\n     * D\u00e9finit la classe\/m\u00e9thode qui doit \u00eatre appel\u00e9e si le routage ne trouver pas une correspondance.\n     * Il peut s'agir soit d'une closure, soit d'un contr\u00f4leur\/m\u00e9thode exactement comme une route est d\u00e9finie : Users::index\n     *\n     * Ce param\u00e8tre est transmis \u00e0 la classe Routeur et y est g\u00e9r\u00e9.\n     *\n     * @param callable|null $callable\n     *\/\n    public function set404Override($callable = null): self\n    {\n        $this->override404 = $callable;\n\n        return $this;\n    }\n\n    \/**\n     * Renvoie le param\u00e8tre 404 Override, qui peut \u00eatre nul, une fermeture une cha\u00eene contr\u00f4leur\/m\u00e9thode.\n     *\n     * @return Closure|string|null\n     *\/\n    public function get404Override()\n    {\n        return $this->override404;\n    }\n\n    \/**\n     * Tentera de d\u00e9couvrir d'\u00e9ventuelles routes suppl\u00e9mentaires, soit par\n     * les espaces de noms PSR4 locaux ou via des packages Composer s\u00e9lectionn\u00e9s.\n     *\/\n    protected function discoverRoutes()\n    {\n        if ($this->didDiscover) {\n            return;\n        }\n\n        \/* if ($this->moduleConfig->shouldDiscover('routes')) {\n            $files = $this->fileLocator->search('Config\/Routes.php');\n\n            foreach ($files as $file) {\n                \/\/ N'incluez plus notre fichier principal...\n                if ($file === CONFIG_PATH . 'Routes.php') {\n                    continue;\n                }\n\n                include $file;\n            }\n        } *\/\n\n        $this->didDiscover = true;\n    }\n\n    \/**\n     * D\u00e9finit la contrainte par d\u00e9faut \u00e0 utiliser dans le syst\u00e8me. Typiquement\n     * \u00e0 utiliser avec la m\u00e9thode 'ressource'.\n     *\/\n    public function setDefaultConstraint(string $placeholder): self\n    {\n        if (array_key_exists($placeholder, $this->placeholders)) {\n            $this->defaultPlaceholder = $placeholder;\n        }\n\n        return $this;\n    }\n\n    \/**\n     * Renvoie le nom du contr\u00f4leur par d\u00e9faut. Avec l'espace de noms.\n     *\/\n    public function getDefaultController(): string\n    {\n        return preg_replace('#Controller$#i', '', $this->defaultController).'Controller';\n    }\n\n    \/**\n     * Renvoie le nom de la m\u00e9thode par d\u00e9faut \u00e0 utiliser dans le contr\u00f4leur.\n     *\/\n    public function getDefaultMethod(): string\n    {\n        return $this->defaultMethod;\n    }\n\n    \/**\n     * Renvoie l'espace de noms par d\u00e9faut tel qu'il est d\u00e9fini dans le fichier de configuration Routes.\n     *\/\n    public function getDefaultNamespace(): string\n    {\n        return $this->defaultNamespace;\n    }\n\n    \/**\n     * Returns the flag that tells whether to autoRoute URI against Controllers.\n     *\/\n    public function shouldAutoRoute(): bool\n    {\n        return $this->autoRoute;\n    }\n\n    \/**\n     * Returns the raw array of available routes.\n     *\/\n    public function getRoutes(?string $verb = null): array\n    {\n        if (empty($verb)) {\n            $verb = $this->getHTTPVerb();\n        }\n        $verb = strtolower($verb);\n\n        \/\/ Since this is the entry point for the Router,\n        \/\/ take a moment to do any route discovery\n        \/\/ we might need to do.\n        $this->discoverRoutes();\n\n        $routes     = [];\n        $collection = [];\n\n        if (isset($this->routes[$verb])) {\n            \/\/ Keep current verb's routes at the beginning so they're matched\n            \/\/ before any of the generic, \"add\" routes.\n            if (isset($this->routes['*'])) {\n                $extraRules = array_diff_key($this->routes['*'], $this->routes[$verb]);\n                $collection = array_merge($this->routes[$verb], $extraRules);\n            }\n\n            foreach ($collection as $r) {\n                $key          = key($r['route']);\n                $routes[$key] = $r['route'][$key];\n            }\n        }\n\n        \/\/ sorting routes by priority\n        if ($this->prioritizeDetected && $this->prioritize && $routes !== []) {\n            $order = [];\n\n            foreach ($routes as $key => $value) {\n                $key                    = $key === '\/' ? $key : ltrim($key, '\/ ');\n                $priority               = $this->getRoutesOptions($key, $verb)['priority'] ?? 0;\n                $order[$priority][$key] = $value;\n            }\n\n            ksort($order);\n            $routes = array_merge(...$order);\n        }\n\n        return $routes;\n    }\n\n    \/**\n     * Renvoie une ou toutes les options d'itin\u00e9raire\n     *\/\n    public function getRoutesOptions(?string $from = null, ?string $verb = null): array\n    {\n        $options = $this->loadRoutesOptions($verb);\n\n        return $from ? $options[$from] ?? [] : $options;\n    }\n\n    \/**\n     * Renvoie le verbe HTTP actuellement utilis\u00e9.\n     *\/\n    public function getHTTPVerb(): string\n    {\n        return $this->HTTPVerb;\n    }\n\n    \/**\n     * D\u00e9finit le verbe HTTP actuel.\n     * Utilis\u00e9 principalement pour les tests.\n     *\/\n    public function setHTTPVerb(string $verb): self\n    {\n        $this->HTTPVerb = $verb;\n\n        return $this;\n    }\n\n    \/**\n     * Une m\u00e9thode de raccourci pour ajouter un certain nombre d'itin\u00e9raires en une seule fois.\n     * Il ne permet pas de d\u00e9finir des options sur l'itin\u00e9raire, ou de\n     * d\u00e9finir la m\u00e9thode utilis\u00e9e.\n     *\/\n    public function map(array $routes = [], ?array $options = null): self\n    {\n        foreach ($routes as $from => $to) {\n            $this->add($from, $to, $options);\n        }\n\n        return $this;\n    }\n\n    \/**\n     * Ajoute une seule route \u00e0 la collection.\n     *\n     * Example:\n     *      $routes->add('news', 'Posts::index');\n     *\n     * @param array|Closure|string $to\n     *\/\n    public function add(string $from, $to, ?array $options = null): self\n    {\n        $this->create('*', $from, $to, $options);\n\n        return $this;\n    }\n\n    \/**\n     * Ajoute une redirection temporaire d'une route \u00e0 une autre. Utilis\u00e9 pour\n     * rediriger le trafic des anciennes routes inexistantes vers les nouvelles\n     * itin\u00e9raires d\u00e9plac\u00e9s.\n     *\n     * @param string $from   Le mod\u00e8le \u00e0 comparer\n     * @param string $to     Soit un nom de route ou un URI vers lequel rediriger\n     * @param int    $status Le code d'\u00e9tat HTTP qui doit \u00eatre renvoy\u00e9 avec cette redirection\n     *\/\n    public function addRedirect(string $from, string $to, int $status = 302): self\n    {\n        \/\/ Utilisez le mod\u00e8le de la route nomm\u00e9e s'il s'agit d'une route nomm\u00e9e.\n        if (array_key_exists($to, $this->routes['*'])) {\n            $to = $this->routes['*'][$to]['route'];\n        } elseif (array_key_exists($to, $this->routes['get'])) {\n            $to = $this->routes['get'][$to]['route'];\n        }\n\n        $this->create('*', $from, $to, ['redirect' => $status]);\n\n        return $this;\n    }\n\n    \/**\n     * D\u00e9termine si la route est une route de redirection.\n     *\/\n    public function isRedirect(string $from): bool\n    {\n        foreach ($this->routes['*'] as $name => $route) {\n            \/\/ Est-ce une route nomm\u00e9e ?\n            if ($name === $from || key($route['route']) === $from) {\n                return isset($route['redirect']) && is_numeric($route['redirect']);\n            }\n        }\n\n        return false;\n    }\n\n    \/**\n     * R\u00e9cup\u00e8re le code d'\u00e9tat HTTP d'une route de redirection.\n     *\/\n    public function getRedirectCode(string $from): int\n    {\n        foreach ($this->routes['*'] as $name => $route) {\n            \/\/ Est-ce une route nomm\u00e9e ?\n            if ($name === $from || key($route['route']) === $from) {\n                return $route['redirect'] ?? 0;\n            }\n        }\n\n        return 0;\n    }\n\n    \/**\n     * Regroupez une s\u00e9rie de routes sous un seul segment d'URL. C'est pratique\n     * pour regrouper des \u00e9l\u00e9ments dans une zone d'administration, comme :\n     *\n     * Example:\n     *     \/\/ Creates route: admin\/users\n     *     $route->group('admin', function() {\n     *            $route->resource('users');\n     *     });\n     *\n     * @param string         $name      Le nom avec lequel grouper\/pr\u00e9fixer les routes.\n     * @param array|callable ...$params\n     *\/\n    public function group(string $name, ...$params)\n    {\n        $oldGroup   = $this->group;\n        $oldOptions = $this->currentOptions;\n\n        \/\/ Pour enregistrer une route, nous allons d\u00e9finir un indicateur afin que notre routeur\n        \/\/ donc il verra le nom du groupe.\n        \/\/ Si le nom du groupe est vide, nous continuons \u00e0 utiliser le nom du groupe pr\u00e9c\u00e9demment construit.\n        $this->group = $name ? ltrim($oldGroup . '\/' . $name, '\/') : $oldGroup;\n\n        $callback = array_pop($params);\n\n        if ($params && is_array($params[0])) {\n            $this->currentOptions = array_shift($params);\n        }\n\n        if (is_callable($callback)) {\n            $callback($this);\n        }\n\n        $this->group          = $oldGroup;\n        $this->currentOptions = $oldOptions;\n    }\n\n    \/*\n     * ------------------------------------------------- -------------------\n     * Routage bas\u00e9 sur les verbes HTTP\n     * ------------------------------------------------- -------------------\n     * Le routage fonctionne ici car, comme le fichier de configuration des routes est lu,\n     * les diff\u00e9rentes routes bas\u00e9es sur le verbe HTTP ne seront ajout\u00e9es qu'\u00e0 la m\u00e9moire en m\u00e9moire\n     * routes s'il s'agit d'un appel qui doit r\u00e9pondre \u00e0 ce verbe.\n     *\n     * Le tableau d'options est g\u00e9n\u00e9ralement utilis\u00e9 pour transmettre un 'as' ou var, mais peut\n     * \u00eatre \u00e9tendu \u00e0 l'avenir. Voir le docblock pour la m\u00e9thode 'add' ci-dessus pour\n     * liste actuelle des options disponibles dans le monde.*\/\n\n    \/**\n     * Cr\u00e9e une collection d'itin\u00e9raires bas\u00e9s sur HTTP-verb pour un contr\u00f4leur.\n     *\n     * Options possibles :\n     * 'controller' - Personnalisez le nom du contr\u00f4leur utilis\u00e9 dans la route 'to'\n     * 'placeholder' - L'expression r\u00e9guli\u00e8re utilis\u00e9e par le routeur. La valeur par d\u00e9faut est '(:any)'\n     * 'websafe' - - '1' si seuls les verbes HTTP GET et POST sont pris en charge\n     *\n     * Exemple:\n     *\n     *      $route->resource('photos');\n     *\n     *      \/\/ Gen\u00e8re les routes suivantes:\n     *      HTTP Verb | Path        | Action        | Used for...\n     *      ----------+-------------+---------------+-----------------\n     *      GET         \/photos             index           un tableau d'objets photo\n     *      GET         \/photos\/new         new             un objet photo vide, avec des propri\u00e9t\u00e9s par d\u00e9faut\n     *      GET         \/photos\/{id}\/edit   edit            un objet photo sp\u00e9cifique, propri\u00e9t\u00e9s modifiables\n     *      GET         \/photos\/{id}        show            un objet photo sp\u00e9cifique, toutes les propri\u00e9t\u00e9s\n     *      POST        \/photos             create          un nouvel objet photo, \u00e0 ajouter \u00e0 la ressource\n     *      DELETE      \/photos\/{id}        delete          supprime l'objet photo sp\u00e9cifi\u00e9\n     *      PUT\/PATCH   \/photos\/{id}        update          propri\u00e9t\u00e9s de remplacement pour la photo existante\n     *\n     *  Si l'option 'websafe' est pr\u00e9sente, les chemins suivants sont \u00e9galement disponibles :\n     *\n     *      POST\t\t\/photos\/{id}\/delete delete\n     *      POST        \/photos\/{id}        update\n     *\n     * @param string     $name    Le nom de la ressource\/du contr\u00f4leur vers lequel router.\n     * @param array|null $options Une liste des fa\u00e7ons possibles de personnaliser le routage.\n     *\/\n    public function resource(string $name, ?array $options = null): self\n    {\n        \/\/ Afin de permettre la personnalisation de la route, le\n        \/\/ les ressources sont envoy\u00e9es \u00e0, nous devons avoir un nouveau nom\n        \/\/ pour stocker les valeurs.\n        $newName = implode('\\\\', array_map('ucfirst', explode('\/', $name)));\n\n        \/\/ Si un nouveau contr\u00f4leur est sp\u00e9cifi\u00e9, alors nous rempla\u00e7ons le\n        \/\/ valeur de $name avec le nom du nouveau contr\u00f4leur.\n        if (isset($options['controller'])) {\n            $newName = ucfirst(filter_var(strip_tags($options['controller']), FILTER_SANITIZE_STRING));\n        }\n\n        \/\/ Afin de permettre la personnalisation des valeurs d'identifiant autoris\u00e9es\n        \/\/ nous avons besoin d'un endroit pour les stocker.\n        $id = $options['placeholder'] ?? $this->placeholders[$this->defaultPlaceholder] ?? '(:segment)';\n\n        \/\/ On s'assure de capturer les r\u00e9f\u00e9rences arri\u00e8re\n        $id = '(' . trim($id, '()') . ')';\n\n        $methods = isset($options['only']) ? (is_string($options['only']) ? explode(',', $options['only']) : $options['only']) : ['index', 'show', 'create', 'update', 'delete', 'new', 'edit'];\n\n        if (isset($options['except'])) {\n            $options['except'] = is_array($options['except']) ? $options['except'] : explode(',', $options['except']);\n\n            foreach ($methods as $i => $method) {\n                if (in_array($method, $options['except'], true)) {\n                    unset($methods[$i]);\n                }\n            }\n        }\n\n        if (in_array('index', $methods, true)) {\n            $this->get($name, $newName . '::index', $options);\n        }\n        if (in_array('new', $methods, true)) {\n            $this->get($name . '\/new', $newName . '::new', $options);\n        }\n        if (in_array('edit', $methods, true)) {\n            $this->get($name . '\/' . $id . '\/edit', $newName . '::edit\/$1', $options);\n        }\n        if (in_array('show', $methods, true)) {\n            $this->get($name . '\/' . $id, $newName . '::show\/$1', $options);\n        }\n        if (in_array('create', $methods, true)) {\n            $this->post($name, $newName . '::create', $options);\n        }\n        if (in_array('update', $methods, true)) {\n            $this->put($name . '\/' . $id, $newName . '::update\/$1', $options);\n            $this->patch($name . '\/' . $id, $newName . '::update\/$1', $options);\n        }\n        if (in_array('delete', $methods, true)) {\n            $this->delete($name . '\/' . $id, $newName . '::delete\/$1', $options);\n        }\n\n        \/\/ Websafe ? la suppression doit \u00eatre v\u00e9rifi\u00e9e avant la mise \u00e0 jour en raison du nom de la m\u00e9thode\n        if (isset($options['websafe'])) {\n            if (in_array('delete', $methods, true)) {\n                $this->post($name . '\/' . $id . '\/delete', $newName . '::delete\/$1', $options);\n            }\n            if (in_array('update', $methods, true)) {\n                $this->post($name . '\/' . $id, $newName . '::update\/$1', $options);\n            }\n        }\n\n        return $this;\n    }\n\n    \/**\n     * Cr\u00e9e une collection de routes bas\u00e9es sur les verbes HTTP pour un contr\u00f4leur de pr\u00e9sentateur.\n     *\n     * Options possibles :\n     * 'controller' - Personnalisez le nom du contr\u00f4leur utilis\u00e9 dans la route 'to'\n     * 'placeholder' - L'expression r\u00e9guli\u00e8re utilis\u00e9e par le routeur. La valeur par d\u00e9faut est '(:any)'\n     *\n     * Example:\n     *\n     *      $route->presenter('photos');\n     *\n     *      \/\/ G\u00e9n\u00e8re les routes suivantes\n     *      HTTP Verb | Path        | Action        | Used for...\n     *      ----------+-------------+---------------+-----------------\n     *      GET         \/photos             index           affiche le tableau des tous les objets photo\n     *      GET         \/photos\/show\/{id}   show            affiche un objet photo sp\u00e9cifique, toutes les propri\u00e9t\u00e9s\n     *      GET         \/photos\/new         new             affiche un formulaire pour un objet photo vide, avec les propri\u00e9t\u00e9s par d\u00e9faut\n     *      POST        \/photos\/create      create          traitement du formulaire pour une nouvelle photo\n     *      GET         \/photos\/edit\/{id}   edit            affiche un formulaire d'\u00e9dition pour un objet photo sp\u00e9cifique, propri\u00e9t\u00e9s modifiables\n     *      POST        \/photos\/update\/{id} update          traitement des donn\u00e9es du formulaire d'\u00e9dition\n     *      GET         \/photos\/remove\/{id} remove          affiche un formulaire pour confirmer la suppression d'un objet photo sp\u00e9cifique\n     *      POST        \/photos\/delete\/{id} delete          suppression de l'objet photo sp\u00e9cifi\u00e9\n     *\n     * @param string     $name    Le nom du contr\u00f4leur vers lequel router.\n     * @param array|null $options Une liste des fa\u00e7ons possibles de personnaliser le routage.\n     *\/\n    public function presenter(string $name, ?array $options = null): self\n    {\n        \/\/ Afin de permettre la personnalisation de la route, le\n        \/\/ les ressources sont envoy\u00e9es \u00e0, nous devons avoir un nouveau nom\n        \/\/ pour stocker les valeurs.\n        $newName = implode('\\\\', array_map('ucfirst', explode('\/', $name)));\n\n        \/\/ Si un nouveau contr\u00f4leur est sp\u00e9cifi\u00e9, alors nous rempla\u00e7ons le\n        \/\/ valeur de $name avec le nom du nouveau contr\u00f4leur.\n        if (isset($options['controller'])) {\n            $newName = ucfirst(filter_var(strip_tags($options['controller']), FILTER_SANITIZE_STRING));\n        }\n\n        \/\/ Afin de permettre la personnalisation des valeurs d'identifiant autoris\u00e9es\n        \/\/ nous avons besoin d'un endroit pour les stocker.\n        $id = $options['placeholder'] ?? $this->placeholders[$this->defaultPlaceholder] ?? '(:segment)';\n\n        \/\/ On s'assure de capturer les r\u00e9f\u00e9rences arri\u00e8re\n        $id = '(' . trim($id, '()') . ')';\n\n        $methods = isset($options['only']) ? (is_string($options['only']) ? explode(',', $options['only']) : $options['only']) : ['index', 'show', 'new', 'create', 'edit', 'update', 'remove', 'delete'];\n\n        if (isset($options['except'])) {\n            $options['except'] = is_array($options['except']) ? $options['except'] : explode(',', $options['except']);\n\n            foreach ($methods as $i => $method) {\n                if (in_array($method, $options['except'], true)) {\n                    unset($methods[$i]);\n                }\n            }\n        }\n\n        if (in_array('index', $methods, true)) {\n            $this->get($name, $newName . '::index', $options);\n        }\n        if (in_array('show', $methods, true)) {\n            $this->get($name . '\/show\/' . $id, $newName . '::show\/$1', $options);\n        }\n        if (in_array('new', $methods, true)) {\n            $this->get($name . '\/new', $newName . '::new', $options);\n        }\n        if (in_array('create', $methods, true)) {\n            $this->post($name . '\/create', $newName . '::create', $options);\n        }\n        if (in_array('edit', $methods, true)) {\n            $this->get($name . '\/edit\/' . $id, $newName . '::edit\/$1', $options);\n        }\n        if (in_array('update', $methods, true)) {\n            $this->post($name . '\/update\/' . $id, $newName . '::update\/$1', $options);\n        }\n        if (in_array('remove', $methods, true)) {\n            $this->get($name . '\/remove\/' . $id, $newName . '::remove\/$1', $options);\n        }\n        if (in_array('delete', $methods, true)) {\n            $this->post($name . '\/delete\/' . $id, $newName . '::delete\/$1', $options);\n        }\n        if (in_array('show', $methods, true)) {\n            $this->get($name . '\/' . $id, $newName . '::show\/$1', $options);\n        }\n        if (in_array('create', $methods, true)) {\n            $this->post($name, $newName . '::create', $options);\n        }\n\n        return $this;\n    }\n\n    \/**\n     * Sp\u00e9cifie une seule route \u00e0 faire correspondre pour plusieurs verbes HTTP.\n     *\n     * Exemple:\n     *  $route->match( ['get', 'post'], 'users\/(:num)', 'users\/$1);\n     *\n     * @param array|Closure|string $to\n     *\/\n    public function match(array $verbs = [], string $from = '', $to = '', ?array $options = null): self\n    {\n        if (empty($from) || empty($to)) {\n            throw new InvalidArgumentException('You must supply the parameters: from, to.');\n        }\n\n        foreach ($verbs as $verb) {\n            $verb = strtolower($verb);\n\n            $this->{$verb}($from, $to, $options);\n        }\n\n        return $this;\n    }\n\n    \/**\n     * Sp\u00e9cifie une route qui n'est disponible que pour les requ\u00eates GET.\n     *\n     * @param array|Closure|string $to\n     *\/\n    public function get(string $from, $to, ?array $options = null): self\n    {\n        $this->create('get', $from, $to, $options);\n\n        return $this;\n    }\n\n    \/**\n     * Sp\u00e9cifie une route qui n'est disponible que pour les requ\u00eates POST.\n     *\n     * @param array|Closure|string $to\n     *\/\n    public function post(string $from, $to, ?array $options = null): self\n    {\n        $this->create('post', $from, $to, $options);\n\n        return $this;\n    }\n\n    \/**\n     * Sp\u00e9cifie une route qui n'est disponible que pour les requ\u00eates PUT.\n     *\n     * @param array|Closure|string $to\n     *\/\n    public function put(string $from, $to, ?array $options = null): self\n    {\n        $this->create('put', $from, $to, $options);\n\n        return $this;\n    }\n\n    \/**\n     * Sp\u00e9cifie une route qui n'est disponible que pour les requ\u00eates DELETE.\n     *\n     * @param array|Closure|string $to\n     *\/\n    public function delete(string $from, $to, ?array $options = null): self\n    {\n        $this->create('delete', $from, $to, $options);\n\n        return $this;\n    }\n\n    \/**\n     * Sp\u00e9cifie une route qui n'est disponible que pour les requ\u00eates HEAD.\n     *\n     * @param array|Closure|string $to\n     *\/\n    public function head(string $from, $to, ?array $options = null): self\n    {\n        $this->create('head', $from, $to, $options);\n\n        return $this;\n    }\n\n    \/**\n     * Sp\u00e9cifie une route qui n'est disponible que pour les requ\u00eates PATCH.\n     *\n     * @param array|Closure|string $to\n     *\/\n    public function patch(string $from, $to, ?array $options = null): self\n    {\n        $this->create('patch', $from, $to, $options);\n\n        return $this;\n    }\n\n    \/**\n     * Sp\u00e9cifie une route qui n'est disponible que pour les requ\u00eates OPTIONS.\n     *\n     * @param array|Closure|string $to\n     *\/\n    public function options(string $from, $to, ?array $options = null): self\n    {\n        $this->create('options', $from, $to, $options);\n\n        return $this;\n    }\n\n    \/**\n     * Sp\u00e9cifie une route qui n'est disponible que pour les requ\u00eates de ligne de commande.\n     *\n     * @param array|Closure|string $to\n     *\/\n    public function cli(string $from, $to, ?array $options = null): self\n    {\n        $this->create('cli', $from, $to, $options);\n\n        return $this;\n    }\n\n    \/**\n     * Limite les itin\u00e9raires \u00e0 un ENVIRONNEMENT sp\u00e9cifi\u00e9 ou ils ne fonctionneront pas.\n     *\/\n    public function environment(string $env, Closure $callback): self\n    {\n        \/*\n        if ($env === ENVIRONMENT) {\n            $callback($this);\n        }*\/\n\n        return $this;\n    }\n\n    \/**\n     * Tente de rechercher une route en fonction de sa destination.\n     *\n     * Si une route existe :\n     *\n     * 'path\/(:any)\/(:any)' => 'Controller::method\/$1\/$2'\n     *\n     * Cette m\u00e9thode vous permet de conna\u00eetre le contr\u00f4leur et la m\u00e9thode\n     * et obtenir la route qui y m\u00e8ne.\n     *\n     * \/\/ \u00c9gal \u00e0 'chemin\/$param1\/$param2'\n     * reverseRoute('Controller::method', $param1, $param2);\n     *\n     * @param mixed ...$params\n     *\n     * @return false|string\n     *\/\n    public function reverseRoute(string $search, ...$params)\n    {\n        \/\/ Les routes nomm\u00e9es ont une priorit\u00e9 plus \u00e9lev\u00e9e.\n        foreach ($this->routes as $collection) {\n            if (array_key_exists($search, $collection)) {\n                $route = $this->fillRouteParams(key($collection[$search]['route']), $params);\n\n                return $this->localizeRoute($route);\n            }\n        }\n\n        \/\/ Si ce n'est pas une route nomm\u00e9e, alors bouclez\n        \/\/ toutes les routes pour trouver une correspondance.\n        foreach ($this->routes as $collection) {\n            foreach ($collection as $route) {\n                $from = key($route['route']);\n                $to   = $route['route'][$from];\n\n                \/\/ on ignore les closures\n                if (! is_string($to)) {\n                    continue;\n                }\n\n                \/\/ Perd toute barre oblique d'espace de noms au d\u00e9but des cha\u00eenes\n                \/\/ pour assurer une correspondance plus coh\u00e9rente.$to     = ltrim($to, '\\\\');\n                $search = ltrim($search, '\\\\');\n\n                \/\/ S'il y a une chance de correspondance, alors ce sera\n                \/\/ soit avec $search au d\u00e9but de la cha\u00eene $to.\n                if (strpos($to, $search) !== 0) {\n                    continue;\n                }\n\n                \/\/ Assurez-vous que le nombre de $params donn\u00e9 ici\n                \/\/ correspond au nombre de back-references dans la route\n                if (substr_count($to, '$') !== count($params)) {\n                    continue;\n                }\n\n                $route = $this->fillRouteParams($from, $params);\n\n                return $this->localizeRoute($route);\n            }\n        }\n\n        \/\/ Si nous sommes toujours l\u00e0, alors nous n'avons pas trouv\u00e9 de correspondance.\n        return false;\n    }\n\n    \/**\n     * Remplace la balise {locale} par les param\u00e8tres r\u00e9gionaux actuels de l'application\n     *\/\n    protected function localizeRoute(string $route): string\n    {\n        return strtr($route, ['{locale}' => Services::request()->getLocale()]);\n    }\n\n    \/**\n     * V\u00e9rifie une route (en utilisant le \"from\") pour voir si elle est filtr\u00e9e ou non.\n     *\/\n    public function isFiltered(string $search, ?string $verb = null): bool\n    {\n        $options = $this->loadRoutesOptions($verb);\n\n        return isset($options[$search]['filter']);\n    }\n\n    \/**\n     * Renvoie les filtres qui doivent \u00eatre appliqu\u00e9s pour un seul itin\u00e9raire, ainsi que\n     * avec tous les param\u00e8tres qu'il pourrait avoir. Les param\u00e8tres sont trouv\u00e9s en divisant\n     * le nom du param\u00e8tre entre deux points pour s\u00e9parer le nom du filtre de la liste des param\u00e8tres,\n     * et le fractionnement du r\u00e9sultat sur des virgules. Alors:\n     *\n     *    'role:admin,manager'\n     *\n     * a un filtre de \"r\u00f4le\", avec des param\u00e8tres de ['admin', 'manager'].\n     *\/\n    public function getFiltersForRoute(string $search, ?string $verb = null): array\n    {\n        $options = $this->loadRoutesOptions($verb);\n\n        if (is_string($options[$search]['filter'])) {\n            return [$options[$search]['filter']];\n        }\n\n        return $options[$search]['filter'] ?? [];\n    }\n\n    \/**\n     * @throws RouterException\n     *\/\n    protected function fillRouteParams(string $from, ?array $params = null): string\n    {\n        \/\/ Retrouvez toutes nos back-r\u00e9f\u00e9rences dans la route d'origine\n        preg_match_all('\/\\(([^)]+)\\)\/', $from, $matches);\n\n        if (empty($matches[0])) {\n            return '\/' . ltrim($from, '\/');\n        }\n\n        \/\/ Construire notre cha\u00eene r\u00e9sultante, en ins\u00e9rant les $params dans\n        \/\/ les endroits appropri\u00e9s.\n        foreach ($matches[0] as $index => $pattern) {\n            if (! preg_match('#^' . $pattern . '$#u', $params[$index])) {\n                throw RouterException::invalidParameterType();\n            }\n\n            \/\/ Assurez-vous que le param\u00e8tre que nous ins\u00e9rons correspond\n            \/\/ le type de param\u00e8tre attendu.\n            $pos  = strpos($from, $pattern);\n            $from = substr_replace($from, $params[$index], $pos, strlen($pattern));\n        }\n\n        return '\/' . ltrim($from, '\/');\n    }\n\n    \/**\n     * Fait le gros du travail de cr\u00e9ation d'un itin\u00e9raire r\u00e9el. Vous devez sp\u00e9cifier\n     * la ou les m\u00e9thodes de demande pour lesquelles cette route fonctionnera. Ils peuvent \u00eatre s\u00e9par\u00e9s\n     * par un caract\u00e8re pipe \"|\" s'il y en a plusieurs.\n     *\n     * @param array|Closure|string $to\n     *\/\n    protected function create(string $verb, string $from, $to, ?array $options = null)\n    {\n        $overwrite = false;\n        $prefix    = $this->group === null ? '' : $this->group . '\/';\n\n        $from = filter_var(strip_tags($prefix . $from), FILTER_SANITIZE_STRING);\n\n        \/\/ Alors que nous voulons ajouter une route dans un groupe de '\/',\n        \/\/ \u00e7a ne marche pas avec la correspondance, alors supprimez-les...\n        if ($from !== '\/') {\n            $from = trim($from, '\/');\n        }\n\n        $options = array_merge($this->currentOptions ?? [], $options ?? []);\n\n        \/\/ D\u00e9tection de priorit\u00e9 de routage\n        if (isset($options['priority'])) {\n            $options['priority'] = abs((int) $options['priority']);\n\n            if ($options['priority'] > 0) {\n                $this->prioritizeDetected = true;\n            }\n        }\n\n        \/\/ Limitation du nom d'h\u00f4te ?\n        if (! empty($options['hostname'])) {\n            \/\/ @todo determine if there's a way to whitelist hosts?\n            if (isset($_SERVER['HTTP_HOST']) && strtolower($_SERVER['HTTP_HOST']) !== strtolower($options['hostname'])) {\n                return;\n            }\n\n            $overwrite = true;\n        }\n\n        \/\/ Limitation du nom sous-domaine ?\n        elseif (! empty($options['subdomain'])) {\n            \/\/ Si nous ne correspondons pas au sous-domaine actuel, alors\n            \/\/ nous n'avons pas besoin d'ajouter la route.\n            if (! $this->checkSubdomains($options['subdomain'])) {\n                return;\n            }\n\n            $overwrite = true;\n        }\n\n        \/\/ Sommes-nous en train de compenser les liaisons ?\n        \/\/ Si oui, occupez-vous d'eux ici en un\n        \/\/ abattre en plein vol.\n        if (isset($options['offset']) && is_string($to)) {\n            \/\/ R\u00e9cup\u00e8re une cha\u00eene constante avec laquelle travailler.\n            $to = preg_replace('\/(\\$\\d+)\/', '$X', $to);\n\n            for ($i = (int) $options['offset'] + 1; $i < (int) $options['offset'] + 7; $i++) {\n                $to = preg_replace_callback(\n                    '\/\\$X\/',\n                    static fn ($m) => '$' . $i,\n                    $to,\n                    1\n                );\n            }\n        }\n\n        \/\/ Remplacez nos espaces r\u00e9serv\u00e9s de regex par la chose r\u00e9elle\n        \/\/ pour que le routeur n'ait pas besoin de savoir quoi que ce soit.\n        foreach ($this->placeholders as $tag => $pattern) {\n            $from = str_ireplace(':' . $tag, $pattern, $from);\n        }\n\n        \/\/ S'il s'agit d'une redirection, aucun traitement\n        if (! isset($options['redirect']) && is_string($to)) {\n            \/\/ Si aucun espace de noms n'est trouv\u00e9, ajouter l'espace de noms par d\u00e9faut\n            if (strpos($to, '\\\\') === false || strpos($to, '\\\\') > 0) {\n                $namespace = $options['namespace'] ?? $this->defaultNamespace;\n                $to        = trim($namespace, '\\\\') . '\\\\' . $to;\n            }\n            \/\/ Assurez-vous toujours que nous \u00e9chappons \u00e0 notre espace de noms afin de ne pas pointer vers\n            \/\/ \\BlitzPHP\\Routes\\Controller::method.\n            $to = '\\\\' . ltrim($to, '\\\\');\n        }\n\n        $name = $options['as'] ?? $from;\n\n        \/\/ Ne remplacez aucun 'from' existant afin que les routes d\u00e9couvertes automatiquement\n        \/\/ n'\u00e9crase pas les param\u00e8tres app\/Config\/Routes.\n        \/\/ les routes manuelement d\u00e9finies doivent toujours \u00eatre la \"source de v\u00e9rit\u00e9\".\n        \/\/ cela ne fonctionne que parce que les routes d\u00e9couvertes sont ajout\u00e9es juste avant\n        \/\/ pour tenter de router la requ\u00eate.\n        if (isset($this->routes[$verb][$name]) && ! $overwrite) {\n            return;\n        }\n\n        $this->routes[$verb][$name] = [\n            'route' => [$from => $to],\n        ];\n\n        $this->routesOptions[$verb][$from] = $options;\n\n        \/\/ C'est une redirection ?\n        if (isset($options['redirect']) && is_numeric($options['redirect'])) {\n            $this->routes['*'][$name]['redirect'] = $options['redirect'];\n        }\n    }\n\n    \/**\n     * Compare le ou les sous-domaines transmis avec le sous-domaine actuel\n     * sur cette page demande.\n     *\n     * @param mixed $subdomains\n     *\/\n    private function checkSubdomains($subdomains): bool\n    {\n        \/\/ Les appels CLI ne peuvent pas \u00eatre sur le sous-domaine.\n        if (! isset($_SERVER['HTTP_HOST'])) {\n            return false;\n        }\n\n        if ($this->currentSubdomain === null) {\n            $this->currentSubdomain = $this->determineCurrentSubdomain();\n        }\n\n        if (! is_array($subdomains)) {\n            $subdomains = [$subdomains];\n        }\n\n        \/\/ Les routes peuvent \u00eatre limit\u00e9es \u00e0 n'importe quel sous-domaine. Dans ce cas, cependant,\n        \/\/ il n\u00e9cessite la pr\u00e9sence d'un sous-domaine.\n        if (! empty($this->currentSubdomain) && in_array('*', $subdomains, true)) {\n            return true;\n        }\n\n        return in_array($this->currentSubdomain, $subdomains, true);\n    }\n\n    \/**\n     * Examine le HTTP_HOST pour obtenir une meilleure correspondance pour le sous-domaine. Ce\n     * ne sera pas parfait, mais devrait r\u00e9pondre \u00e0 nos besoins.\n     *\n     * Ce n'est surtout pas parfait puisqu'il est possible d'enregistrer un domaine\n     * avec un point (.) dans le cadre du nom de domaine.\n     *\n     * @return mixed\n     *\/\n    private function determineCurrentSubdomain()\n    {\n        \/\/ Nous devons nous assurer qu'un sch\u00e9ma existe\n        \/\/ sur l'URL sinon parse_url sera mal interpr\u00e9t\u00e9\n        \/\/ 'h\u00f4te' comme 'chemin'.\n        $url = $_SERVER['HTTP_HOST'];\n        if (strpos($url, 'http') !== 0) {\n            $url = 'http:\/\/' . $url;\n        }\n\n        $parsedUrl = parse_url($url);\n\n        $host = explode('.', $parsedUrl['host']);\n\n        if ($host[0] === 'www') {\n            unset($host[0]);\n        }\n\n        \/\/ D\u00e9barrassez-vous de tous les domaines, qui seront les derniers\n        unset($host[count($host)]);\n\n        \/\/ Compte pour les domaines .co.uk, .co.nz, etc.\n        if (end($host) === 'co') {\n            $host = array_slice($host, 0, -1);\n        }\n\n        \/\/ S'il ne nous reste qu'une partie, alors nous n'avons pas de sous-domaine.\n        if (count($host) === 1) {\n            \/\/ D\u00e9finissez-le sur false pour ne pas revenir ici.\n            return false;\n        }\n\n        return array_shift($host);\n    }\n\n    \/**\n     * R\u00e9initialisez les routes, afin qu'un cas de test puisse fournir le\n     * ceux explicites n\u00e9cessaires pour cela.\n     *\/\n    public function resetRoutes()\n    {\n        $this->routes = ['*' => []];\n\n        foreach ($this->defaultHTTPMethods as $verb) {\n            $this->routes[$verb] = [];\n        }\n\n        $this->prioritizeDetected = false;\n    }\n\n    \/**\n     * Charger les options d'itin\u00e9raires en fonction du verbe\n     *\/\n    protected function loadRoutesOptions(?string $verb = null): array\n    {\n        $verb = $verb ?: $this->getHTTPVerb();\n\n        $options = $this->routesOptions[$verb] ?? [];\n\n        if (isset($this->routesOptions['*'])) {\n            foreach ($this->routesOptions['*'] as $key => $val) {\n                if (isset($options[$key])) {\n                    $extraOptions  = array_diff_key($val, $options[$key]);\n                    $options[$key] = array_merge($options[$key], $extraOptions);\n                } else {\n                    $options[$key] = $val;\n                }\n            }\n        }\n\n        return $options;\n    }\n\n    \/**\n     * Activer ou d\u00e9sactiver le tri des routes par priorit\u00e9\n     *\/\n    public function setPrioritize(bool $enabled = true): self\n    {\n        $this->prioritize = $enabled;\n\n        return $this;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,2,null,2,2,null,null,null,null,null,2,2,null,null,null,2,2,null,null,null,null,null,2,null,null,0,0,0,null,null,0,0,null,null,2,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,null,null,null,2,null,null,2,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,2,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,0,null,0,null,null,0,null,null,null,0,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,0,null,0,null,null,0,null,null,null,0,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,0,null,null,0,null,null,null,null,null,0,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,0,null,0,null,null,0,null,null,null,0,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,0,null,null,null,0,null,null,null,null,0,null,null,null,null,0,null,null,null,null,null,0,null,null,0,null,0,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,0,null,null,null,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,2,2,null,2,null,null,null,null,2,null,null,2,null,null,null,2,null,null,0,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,0,null,null,null,null,null,null,2,null,null,null,null,null,null,2,2,null,null,null,2,null,null,2,null,null,null,null,null,null,null,0,null,null,null,null,2,null,2,null,null,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,0,null,null,0,null,null,null,0,null,null,null,0,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,2,null,2,null,null,null,null,2,0,null,2,null,null,null,null,2,null,null,null,null,null,null,null,0,null,0,null,null,null]},{"name":"src\\Router\\Router.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Router;\n\nuse BlitzPHP\\Contracts\\Router\\RouteCollectionInterface;\nuse BlitzPHP\\Contracts\\Router\\RouterInterface;\nuse BlitzPHP\\Exceptions\\PageNotFoundException;\nuse BlitzPHP\\Exceptions\\RedirectException;\nuse BlitzPHP\\Exceptions\\RouterException;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\n\/**\n * Analyse l'URL de la requ\u00eate dans le contr\u00f4leur, action et param\u00e8tres. Utilise les routes connect\u00e9es\n * pour faire correspondre la cha\u00eene d'URL entrante aux param\u00e8tres qui permettront \u00e0 la requ\u00eate d'\u00eatre envoy\u00e9e. Aussi\n * g\u00e8re la conversion des listes de param\u00e8tres en cha\u00eenes d'URL, en utilisant les routes connect\u00e9es. Le routage vous permet de d\u00e9coupler\n * la fa\u00e7on dont le monde interagit avec votre application (URL) et l'impl\u00e9mentation (contr\u00f4leurs et actions).\n *\/\nclass Router implements RouterInterface\n{\n    \/**\n     * Une instance de la classe RouteCollection.\n     *\n     * @var RouteCollection\n     *\/\n    protected $collection;\n\n    \/**\n     * Sous-r\u00e9pertoire contenant la classe de contr\u00f4leur demand\u00e9e.\n     * Principalement utilis\u00e9 par 'autoRoute'.\n     *\n     * @var string|null\n     *\/\n    protected $directory;\n\n    \/**\n     * Le nom de la classe contr\u00f4leur\n     *\n     * @var string\n     *\/\n    protected $controller;\n\n    \/**\n     * Le nom de la m\u00e9thode \u00e0 utiliser\n     *\n     * @var string\n     *\/\n    protected $method;\n\n    \/**\n     * An array of binds that were collected\n     * so they can be sent to closure routes.\n     *\n     * @var array\n     *\/\n    protected $params = [];\n\n    \/**\n     * Le nom du du front-controller.\n     *\n     * @var string\n     *\/\n    protected $indexPage = 'index.php';\n\n    \/**\n     * Les routes trouv\u00e9es pour la requ\u00eate courrante\n     *\n     * @var array|null\n     *\/\n    protected $matchedRoute;\n\n    \/**\n     * Les options de la route match\u00e9e.\n     *\n     * @var array|null\n     *\/\n    protected $matchedRouteOptions;\n\n    \/**\n     * Le locale (langue) qui a \u00e9t\u00e9 detect\u00e9e dans la route.\n     *\n     * @var string\n     *\/\n    protected $detectedLocale;\n\n    \/**\n     * Les informations des middlewares \u00e0 executer\n     * Si la route match\u00e9e necessite des filtres.\n     *\n     * @var string[]\n     *\/\n    protected $middlewaresInfo = [];\n\n    \/**\n     * @param Request $request\n     *\n     * @return self\n     *\/\n    public function init(RouteCollectionInterface $routes, ServerRequestInterface $request)\n    {\n        $this->collection = $routes;\n\n        $this->setController($this->collection->getDefaultController());\n        $this->setMethod($this->collection->getDefaultMethod());\n\n        $this->collection->setHTTPVerb($request->getMethod() ?? strtolower($_SERVER['REQUEST_METHOD']));\n\n        return $this;\n    }\n\n    \/**\n     * @throws PageNotFoundException\n     * @throws RedirectException\n     *\n     * @return mixed|string\n     *\/\n    public function handle(?string $uri = null)\n    {\n        \/\/ Si nous ne trouvons pas d'URI \u00e0 comparer, alors\n        \/\/ tout fonctionne \u00e0 partir de ses param\u00e8tres par d\u00e9faut.\n        if ($uri === null || $uri === '') {\n            return strpos($this->controller, '\\\\') === false\n                ? $this->collection->getDefaultNamespace() . $this->controller\n                : $this->controller;\n        }\n\n        $uri = urldecode($uri);\n\n        if ($this->checkRoutes($uri)) {\n            if ($this->collection->isFiltered($this->matchedRoute[0])) {\n                $this->middlewaresInfo = $this->collection->getFiltersForRoute($this->matchedRoute[0]);\n            }\n\n            return $this->controller;\n        }\n\n        \/\/ Toujours l\u00e0 ? Ensuite, nous pouvons essayer de faire correspondre l'URI avec\n        \/\/ Contr\u00f4leurs\/r\u00e9pertoires, mais l'application peut ne pas\n        \/\/ vouloir ceci, comme dans le cas des API.\n        if (! $this->collection->shouldAutoRoute()) {\n            throw new PageNotFoundException(\"Can't find a route for '{$uri}'.\");\n        }\n\n        $this->autoRoute($uri);\n\n        return $this->controllerName();\n    }\n\n    \/**\n     * Renvoie les informations des middlewares de la routes match\u00e9e\n     *\n     * @return string[]\n     *\/\n    public function getMiddlewares(): array\n    {\n        return $this->middlewaresInfo;\n    }\n\n    \/**\n     * Renvoie le nom du contr\u00f4leur match\u00e9\n     *\/\n    public function controllerName(): string\n    {\n        return str_replace('-', '_', trim($this->controller, '\/\\\\'));\n    }\n\n    \/**\n     * Retourne le nom de la m\u00e9thode \u00e0 ex\u00e9cuter\n     *\/\n    public function methodName(): string\n    {\n        return str_replace('-', '_', $this->method);\n    }\n\n    \/**\n     * Renvoie les param\u00e8tres de remplacement 404 de la collection.\n     * Si le remplacement est une cha\u00eene, sera divis\u00e9 en tableau contr\u00f4leur\/index.\n     *\n     * @return array|callable|null\n     *\/\n    public function get404Override()\n    {\n        $route = $this->collection->get404Override();\n\n        if (is_string($route)) {\n            $routeArray = explode('::', $route);\n\n            return [\n                $routeArray[0], \/\/ Controller\n                $routeArray[1] ?? 'index',   \/\/ Method\n            ];\n        }\n\n        if (is_callable($route)) {\n            return $route;\n        }\n\n        return null;\n    }\n\n    \/**\n     * Renvoie les liaisons qui ont \u00e9t\u00e9 mises en correspondance et collect\u00e9es\n     * pendant le processus d'analyse sous forme de tableau, pr\u00eat \u00e0 \u00eatre envoy\u00e9 \u00e0\n     * instance->method(...$params).\n     *\/\n    public function params(): array\n    {\n        return $this->params;\n    }\n\n    \/**\n     * Renvoie le nom du sous-r\u00e9pertoire dans lequel se trouve le contr\u00f4leur.\n     * Relatif \u00e0 APPPATH.'Controllers'.\n     *\n     * Uniquement utilis\u00e9 lorsque le routage automatique est activ\u00e9.\n     *\/\n    public function directory(): string\n    {\n        return ! empty($this->directory) ? $this->directory : '';\n    }\n\n    \/**\n     * Renvoie les informations de routage qui correspondaient \u00e0 ce\n     * requ\u00eate, si une route a \u00e9t\u00e9 d\u00e9finie.\n     *\/\n    public function getMatchedRoute(): ?array\n    {\n        return $this->matchedRoute;\n    }\n\n    \/**\n     * Renvoie toutes les options d\u00e9finies pour la route correspondante\n     *\n     * @return array|null\n     *\/\n    public function getMatchedRouteOptions()\n    {\n        return $this->matchedRouteOptions;\n    }\n\n    \/**\n     * D\u00e9finit la valeur qui doit \u00eatre utilis\u00e9e pour correspondre au fichier index.php. Valeurs par d\u00e9faut\n     * \u00e0 index.php mais cela vous permet de le modifier au cas o\u00f9 vous utilisez\n     * quelque chose comme mod_rewrite pour supprimer la page. Vous pourriez alors le d\u00e9finir comme une chaine vide=\n     *\/\n    public function setIndexPage(string $page): self\n    {\n        $this->indexPage = $page;\n\n        return $this;\n    }\n\n    \/**\n     * Renvoie vrai\/faux selon que la route actuelle contient ou non\n     * un placeholder {locale}.\n     *\/\n    public function hasLocale(): bool\n    {\n        return (bool) $this->detectedLocale;\n    }\n\n    \/**\n     * Renvoie la locale (langue) d\u00e9tect\u00e9e, le cas \u00e9ch\u00e9ant, ou null.\n     *\/\n    public function getLocale(): ?string\n    {\n        return $this->detectedLocale;\n    }\n\n    \/**\n     * Compare la cha\u00eene uri aux routes que la\n     * classe RouteCollection a d\u00e9finie pour nous, essayant de trouver une correspondance.\n     * Cette m\u00e9thode modifiera $this->controller, si n\u00e9cessaire.\n     *\n     * @param string $uri Le chemin URI \u00e0 comparer aux routes\n     *\n     * @throws RedirectException\n     *\n     * @return bool Si la route a \u00e9t\u00e9 mis en correspondance ou non.\n     *\/\n    protected function checkRoutes(string $uri): bool\n    {\n        $routes = $this->collection->getRoutes($this->collection->getHTTPVerb());\n\n        \/\/ S'il n'y a pas de routes definies pour la methode HTTP, c'est pas la peine d'aller plus loin\n        if (empty($routes)) {\n            return false;\n        }\n\n        $uri = $uri === '\/'\n            ? $uri\n            : trim($uri, '\/');\n\n        \/\/ Boucle dans le tableau de routes \u00e0 la recherche de caract\u00e8res g\u00e9n\u00e9riques\n        foreach ($routes as $key => $val) {\n            $localeSegment = null;\n\n            $key = $key === '\/'\n                ? $key\n                : ltrim($key, '\/ ');\n\n            $matchedKey = $key;\n\n            \/\/ A-t-on affaire \u00e0 une locale ?\n            if (strpos($key, '{locale}') !== false) {\n                $localeSegment = array_search('{locale}', preg_split('\/[\\\/]*((^[a-zA-Z0-9])|\\(([^()]*)\\))*[\\\/]+\/m', $key), true);\n\n                \/\/ Remplacez-la par une regex pour qu'elle correspondra r\u00e9ellement.\n                $key = str_replace('\/', '\\\/', $key);\n                $key = str_replace('{locale}', '[^\\\/]+', $key);\n            }\n\n            \/\/ Does the RegEx match?\n            if (preg_match('#^' . $key . '$#u', $uri, $matches)) {\n                \/\/ Is this route supposed to redirect to another?\n                if ($this->collection->isRedirect($key)) {\n                    throw new RedirectException(is_array($val) ? key($val) : $val, $this->collection->getRedirectCode($key));\n                }\n                \/\/ Store our locale so CodeIgniter object can\n                \/\/ assign it to the Request.\n                if (isset($localeSegment)) {\n                    \/\/ The following may be inefficient, but doesn't upset NetBeans :-\/\n                    $temp                 = (explode('\/', $uri));\n                    $this->detectedLocale = $temp[$localeSegment];\n                }\n\n                \/\/ Are we using Closures? If so, then we need\n                \/\/ to collect the params into an array\n                \/\/ so it can be passed to the controller method later.\n                if (! is_string($val) && is_callable($val)) {\n                    $this->controller = $val;\n\n                    \/\/ Remove the original string from the matches array\n                    array_shift($matches);\n\n                    $this->params = $matches;\n\n                    $this->matchedRoute = [\n                        $matchedKey,\n                        $val,\n                    ];\n\n                    $this->matchedRouteOptions = $this->collection->getRoutesOptions($matchedKey);\n\n                    return true;\n                }\n                \/\/ Are we using the default method for back-references?\n\n                \/\/ Support resource route when function with subdirectory\n                \/\/ ex: $routes->resource('Admin\/Admins');\n                if (strpos($val, '$') !== false && strpos($key, '(') !== false && strpos($key, '\/') !== false) {\n                    $replacekey = str_replace('\/(.*)', '', $key);\n                    $val        = preg_replace('#^' . $key . '$#u', $val, $uri);\n                    $val        = str_replace($replacekey, str_replace('\/', '\\\\', $replacekey), $val);\n                } elseif (strpos($val, '$') !== false && strpos($key, '(') !== false) {\n                    $val = preg_replace('#^' . $key . '$#u', $val, $uri);\n                } elseif (strpos($val, '\/') !== false) {\n                    [\n                        $controller,\n                        $method,\n                    ] = explode('::', $val);\n\n                    \/\/ Only replace slashes in the controller, not in the method.\n                    $controller = str_replace('\/', '\\\\', $controller);\n\n                    $val = $controller . '::' . $method;\n                }\n\n                $this->setRequest(explode('\/', $val));\n\n                $this->matchedRoute = [\n                    $matchedKey,\n                    $val,\n                ];\n\n                $this->matchedRouteOptions = $this->collection->getRoutesOptions($matchedKey);\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    \/**\n     * Tente de faire correspondre un chemin d'URI avec des contr\u00f4leurs et des r\u00e9pertoires\n     * trouv\u00e9 dans CONTROLLER_PATH, pour trouver une route correspondante.\n     *\/\n    public function autoRoute(string $uri)\n    {\n        $segments = explode('\/', $uri);\n\n        $segments = $this->scanControllers($segments);\n\n        \/\/ Si nous n'avons plus de segments - essayez le contr\u00f4leur par d\u00e9faut ;\n        \/\/ AVERTISSEMENT : les r\u00e9pertoires sont d\u00e9plac\u00e9s hors du tableau de segments.\n        if (empty($segments)) {\n            $this->setDefaultController();\n        }\n        \/\/ S'il n'est pas vide, le premier segment doit \u00eatre le contr\u00f4leur\n        else {\n            $this->setController(array_shift($segments));\n        }\n\n        $controllerName = $this->controllerName();\n        if (! $this->isValidSegment($controllerName)) {\n            throw new PageNotFoundException($this->controller . ' is not a valid controller name');\n        }\n\n        \/\/ Utilise le nom de la m\u00e9thode s'il existe.\n        \/\/ Si ce n'est pas le cas, ce n'est pas grave - le nom de la m\u00e9thode par d\u00e9faut\n        \/\/ a d\u00e9j\u00e0 \u00e9t\u00e9 d\u00e9fini.\n        if (! empty($segments)) {\n            $this->setMethod(array_shift($segments) ?: $this->method);\n        }\n\n        if (! empty($segments)) {\n            $this->params = $segments;\n        }\n\n        $defaultNamespace = $this->collection->getDefaultNamespace();\n        if ($this->collection->getHTTPVerb() !== 'cli') {\n            $controller = '\\\\' . $defaultNamespace;\n\n            $controller .= $this->directory ? str_replace('\/', '\\\\', $this->directory) : '';\n            $controller .= $controllerName;\n\n            $controller = strtolower($controller);\n            $methodName = strtolower($this->methodName());\n\n            foreach ($this->collection->getRoutes('cli') as $route) {\n                if (is_string($route)) {\n                    $route = strtolower($route);\n                    if (strpos($route, $controller . '::' . $methodName) === 0) {\n                        throw new PageNotFoundException();\n                    }\n\n                    if ($route === $controller) {\n                        throw new PageNotFoundException();\n                    }\n                }\n            }\n        }\n\n        \/\/ Charge le fichier afin qu'il soit disponible.\n        $file = CONTROLLER_PATH . $this->directory . $controllerName . '.php';\n        if (is_file($file)) {\n            include_once $file;\n        }\n\n        \/\/ Assurez-vous que le contr\u00f4leur stocke le nom de classe complet\n        \/\/ Nous devons v\u00e9rifier une longueur sup\u00e9rieure \u00e0 1, puisque par d\u00e9faut ce sera '\\'\n        if (strpos($this->controller, '\\\\') === false && strlen($defaultNamespace) > 1) {\n            $this->setController('\\\\' . ltrim(str_replace('\/', '\\\\', $defaultNamespace . $this->directory . $controllerName), '\\\\'));\n        }\n    }\n\n    \/**\n     * Scans the controller directory, attempting to locate a controller matching the supplied uri $segments\n     *\n     * @param array $segments URI segments\n     *\n     * @return array returns an array of remaining uri segments that don't map onto a directory\n     *\n     * @deprecated this function name does not properly describe its behavior so it has been deprecated\n     *\n     * @codeCoverageIgnore\n     *\/\n    protected function validateRequest(array $segments): array\n    {\n        return $this->scanControllers($segments);\n    }\n\n    \/**\n     * Scanne le r\u00e9pertoire du contr\u00f4leur, essayant de localiser un contr\u00f4leur correspondant aux segments d'URI fournis\n     *\n     * @param array $segments segments d'URI\n     *\n     * @return array renvoie un tableau des segments uri restants qui ne correspondent pas \u00e0 un r\u00e9pertoire\n     *\/\n    protected function scanControllers(array $segments): array\n    {\n        $segments = array_filter($segments, static fn ($segment) => $segment !== '');\n        \/\/ r\u00e9indexe num\u00e9riquement le tableau, supprimant les lacunes\n        $segments = array_values($segments);\n\n        \/\/ si une valeur de r\u00e9pertoire pr\u00e9c\u00e9dente a \u00e9t\u00e9 d\u00e9finie, retournez simplement les segments et sortez d'ici\n        if (isset($this->directory)) {\n            return $segments;\n        }\n\n        \/\/ Parcourez nos segments et revenez d\u00e8s qu'un contr\u00f4leur\n        \/\/ est trouv\u00e9 ou lorsqu'un tel r\u00e9pertoire n'existe pas\n        $c = count($segments);\n\n        while ($c-- > 0) {\n            $segmentConvert = ucfirst(str_replace('-', '_', $segments[0]));\n            \/\/ d\u00e8s que nous rencontrons un segment non conforme \u00e0 PSR-4, arr\u00eatons la recherche\n            if (! $this->isValidSegment($segmentConvert)) {\n                return $segments;\n            }\n\n            $test = CONTROLLER_PATH . $this->directory . $segmentConvert;\n\n            \/\/ tant que chaque segment n'est *pas* un fichier de contr\u00f4leur mais correspond \u00e0 un r\u00e9pertoire, ajoutez-le \u00e0 $this->r\u00e9pertoire\n            if (! is_file($test . '.php') && is_dir($test)) {\n                $this->setDirectory($segmentConvert, true, false);\n                array_shift($segments);\n\n                continue;\n            }\n\n            return $segments;\n        }\n\n        \/\/ Cela signifie que tous les segments \u00e9taient en fait des r\u00e9pertoires\n        return $segments;\n    }\n\n    \/**\n     * D\u00e9finit le sous-r\u00e9pertoire dans lequel se trouve le contr\u00f4leur.\n     *\n     * @param bool $validate si vrai, v\u00e9rifie que $dir se compose uniquement de segments conformes \u00e0 PSR4\n     *\/\n    public function setDirectory(?string $dir = null, bool $append = false, bool $validate = true)\n    {\n        if (empty($dir)) {\n            $this->directory = null;\n\n            return;\n        }\n\n        if ($validate) {\n            $segments = explode('\/', trim($dir, '\/'));\n\n            foreach ($segments as $segment) {\n                if (! $this->isValidSegment($segment)) {\n                    return;\n                }\n            }\n        }\n\n        if ($append !== true || empty($this->directory)) {\n            $this->directory = trim($dir, '\/') . '\/';\n        } else {\n            $this->directory .= trim($dir, '\/') . '\/';\n        }\n    }\n\n    \/**\n     * Renvoie true si la cha\u00eene $segment fournie repr\u00e9sente un segment d'espace de noms\/r\u00e9pertoire valide conforme \u00e0 PSR-4\n     *\n     * regex comes from https:\/\/www.php.net\/manual\/en\/language.variables.basics.php\n     *\/\n    private function isValidSegment(string $segment): bool\n    {\n        return (bool) preg_match('\/^[a-zA-Z_\\x80-\\xff][a-zA-Z0-9_\\x80-\\xff]*$\/', $segment);\n    }\n\n    \/**\n     * D\u00e9finir la route de la requ\u00eate\n     *\n     * Prend un tableau de segments URI en entr\u00e9e et d\u00e9finit la classe\/m\u00e9thode\n     * \u00eatre appel\u00e9.\n     *\n     * @param array $segments segments d'URI\n     *\/\n    protected function setRequest(array $segments = [])\n    {\n        \/\/ Si nous n'avons aucun segment - essayez le contr\u00f4leur par d\u00e9faut ;\n        if (empty($segments)) {\n            $this->setDefaultController();\n\n            return;\n        }\n\n        [$controller, $method] = array_pad(explode('::', $segments[0]), 2, null);\n\n        $this->setController($controller);\n\n        \/\/ $this->method contient d\u00e9j\u00e0 le nom de la m\u00e9thode par d\u00e9faut,\n        \/\/ donc ne l'\u00e9crasez pas avec le vide.\n        if (! empty($method)) {\n            $this->setMethod($method);\n        }\n\n        array_shift($segments);\n\n        $this->params = $segments;\n    }\n\n    \/**\n     * D\u00e9finit le contr\u00f4leur par d\u00e9faut en fonction des informations d\u00e9finies dans RouteCollection.\n     *\/\n    protected function setDefaultController()\n    {\n        if (empty($this->controller)) {\n            throw RouterException::missingDefaultRoute();\n        }\n\n        \/\/ La m\u00e9thode est-elle sp\u00e9cifi\u00e9e ?\n        if (sscanf($this->controller, '%[^\/]\/%s', $class, $this->method) !== 2) {\n            $this->method = 'index';\n        }\n\n        if (! is_file(CONTROLLER_PATH . $this->directory . $this->makeController($class) . '.php')) {\n            return;\n        }\n\n        $this->setController($class);\n\n        \/\/ log_message('info', 'Used the default controller.');\n    }\n\n    \/**\n     * Modifie le nom du controleur\n     *\/\n    private function setController(string $name): void\n    {\n        $this->controller = $this->makeController($name);\n    }\n\n    \/**\n     * Construit un nom de contr\u00f4leur valide\n     *\/\n    private function makeController(string $name): string\n    {\n        return preg_replace(\n            ['#Controller$#', '#' . config('app.url_suffix') . '$#i'],\n            '',\n            ucfirst($name)\n        ) . 'Controller';\n    }\n\n    \/**\n     * Modifie le nom de la m\u00e9thode\n     *\/\n    private function setMethod(string $name): void\n    {\n        $this->method = preg_replace('#' . config('app.url_suffix') . '$#i', '', strtolower($name));\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,2,2,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,2,null,null,null,2,null,null,2,null,null,null,null,null,null,2,null,null,2,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,0,null,null,null,null,2,null,null,null,2,null,null,null,2,null,2,null,null,null,2,null,null,2,2,null,null,null,null,null,null,2,null,null,null,null,null,0,0,null,null,null,null,null,null,0,null,null,0,null,0,null,null,null,null,0,null,0,null,0,null,null,null,null,null,null,2,2,2,null,2,null,null,null,null,0,null,null,0,null,0,null,null,2,null,null,null,null,2,null,2,null,2,null,null,null,2,null,null,null,null,null,null,null,null,2,null,2,null,null,null,null,2,null,null,null,2,null,null,2,null,2,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,0,null,0,0,null,0,0,null,null,null,0,null,0,null,null,null,0,null,null,null,null,null,null,0,null,0,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,2,null,2,null,null,null,0,null,null,null,null,2,null,null,2,null,null,2,null,null,0,null,null,null,0,0,null,0,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,null,null,0,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,0,null,null,2,null,2,null,null,null,null,2,null,null,2,null,2,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,null,null,null,null,2,null,null,null,null,null,null,null,2,null,null,null]},{"name":"src\\Traits\\ApiResponseTrait.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Traits;\n\nuse BlitzPHP\\Contracts\\Http\\StatusCode;\n\n\/**\n * Fournit des m\u00e9thodes courantes, plus lisibles,\n * pour fournir des r\u00e9ponses HTTP coh\u00e9rentes dans diverses situations courantes\n * lorsque vous travaillez en tant qu'API.\n *\/\ntrait ApiResponseTrait\n{\n    \/**\n     * Permet aux classes enfants de remplacer\n     * code d'\u00e9tat utilis\u00e9 dans leur API.\n     *\n     * @var array<string, int>\n     *\/\n    protected $codes = [\n        'created'                   => StatusCode::CREATED,\n        'deleted'                   => StatusCode::OK,\n        'updated'                   => StatusCode::OK,\n        'no_content'                => StatusCode::NO_CONTENT,\n        'invalid_request'           => StatusCode::BAD_REQUEST,\n        'unsupported_response_type' => StatusCode::BAD_REQUEST,\n        'invalid_scope'             => StatusCode::BAD_REQUEST,\n        'temporarily_unavailable'   => StatusCode::BAD_REQUEST,\n        'invalid_grant'             => StatusCode::BAD_REQUEST,\n        'invalid_credentials'       => StatusCode::BAD_REQUEST,\n        'invalid_refresh'           => StatusCode::BAD_REQUEST,\n        'no_data'                   => StatusCode::BAD_REQUEST,\n        'invalid_data'              => StatusCode::BAD_REQUEST,\n        'access_denied'             => StatusCode::UNAUTHORIZED,\n        'unauthorized'              => StatusCode::UNAUTHORIZED,\n        'invalid_client'            => StatusCode::UNAUTHORIZED,\n        'forbidden'                 => StatusCode::FORBIDDEN,\n        'resource_not_found'        => StatusCode::NOT_FOUND,\n        'not_acceptable'            => StatusCode::NOT_ACCEPTABLE,\n        'resource_exists'           => StatusCode::CONFLICT,\n        'conflict'                  => StatusCode::CONFLICT,\n        'resource_gone'             => StatusCode::GONE,\n        'payload_too_large'         => StatusCode::PAYLOAD_TOO_LARGE,\n        'unsupported_media_type'    => StatusCode::UNSUPPORTED_MEDIA_TYPE,\n        'too_many_requests'         => StatusCode::TOO_MANY_REQUESTS,\n        'server_error'              => StatusCode::INTERNAL_ERROR,\n        'unsupported_grant_type'    => StatusCode::NOT_IMPLEMENTED,\n        'not_implemented'           => StatusCode::NOT_IMPLEMENTED,\n    ];\n\n    \/**\n     * Fournit une m\u00e9thode simple et unique pour renvoyer une r\u00e9ponse d'API, format\u00e9e\n     * pour correspondre au format demand\u00e9, avec le type de contenu et le code d'\u00e9tat appropri\u00e9s.\n     *\n     * @param mixed    $data   Les donnees a renvoyer\n     * @param int|null $status Le statut de la reponse\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface\n     *\/\n    abstract protected function respond($data, ?int $status = StatusCode::OK);\n\n    \/**\n     * Utilis\u00e9 pour les \u00e9checs g\u00e9n\u00e9riques pour lesquels aucune m\u00e9thode personnalis\u00e9e n'existe.\n     *\n     * @param string          $message Le message d\u00e9crivant l'erreur\n     * @param int             $status  Code d'\u00e9tat HTTP\n     * @param int|string|null $code    Code d'erreur personnalis\u00e9, sp\u00e9cifique \u00e0 l'API\n     * @param array           $errors  La liste des erreurs rencontr\u00e9es\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface\n     *\/\n    abstract protected function respondFail(?string $message = \"Une erreur s'est produite\", ?int $status = StatusCode::INTERNAL_ERROR, int|string|null $code = null, array $errors = []);\n\n    \/**\n     * Utilis\u00e9 pour les succ\u00e8s g\u00e9n\u00e9riques pour lesquels aucune m\u00e9thode personnalis\u00e9e n'existe.\n     *\n     * @param mixed|null $result\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface\n     *\/\n    abstract protected function respondSuccess(?string $message = 'Resultat', $result = null, ?int $status = StatusCode::OK);\n\n    \/**\n     * Reponse de type bad request\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface\n     *\/\n    final protected function respondBadRequest(string $message, int|string|null $code = null, array $errors = [])\n    {\n        return $this->respondFail($message, $this->codes['invalid_request'] ?? StatusCode::BAD_REQUEST, $code, $errors);\n    }\n\n    \/**\n     * \u00c0 utiliser lorsque vous essayez de cr\u00e9er une nouvelle ressource et qu'elle existe d\u00e9j\u00e0.\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface\n     *\/\n    final protected function respondConflict(string $message, int|string|null $code = null, array $errors = [])\n    {\n        return $this->respondFail($message, $this->codes['conflict'] ?? StatusCode::CONFLICT, $code, $errors);\n    }\n\n    \/**\n     * Utilis\u00e9 apr\u00e8s la cr\u00e9ation r\u00e9ussie d'une nouvelle ressource.\n     *\n     * @param mixed|null $result\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface\n     *\/\n    final protected function respondCreated(string $message, $result = null)\n    {\n        return $this->respondSuccess($message, $result, $this->codes['created'] ?? StatusCode::CREATED);\n    }\n\n    \/**\n     * Utilis\u00e9 apr\u00e8s qu'une ressource a \u00e9t\u00e9 supprim\u00e9e avec succ\u00e8s.\n     *\n     * @param mixed|null $result\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface\n     *\/\n    protected function respondDeleted(string $message, $result = null)\n    {\n        return $this->respondSuccess($message, $result, $this->codes['deleted'] ?? StatusCode::OK);\n    }\n\n    \/**\n     * Utilis\u00e9 lorsque l'acc\u00e8s est toujours refus\u00e9 \u00e0 cette ressource\n     * et qu'aucune nouvelle tentative n'aidera.\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface\n     *\/\n    final protected function respondForbidden(string $message, int|string|null $code = null, array $errors = [])\n    {\n        return $this->respondFail($message, $this->codes['forbidden'] ?? StatusCode::FORBIDDEN, $code, $errors);\n    }\n\n    \/**\n     * \u00c0 utiliser lorsqu'une ressource a \u00e9t\u00e9 pr\u00e9c\u00e9demment supprim\u00e9e. Ceci est diff\u00e9rent de Not Found,\n     * car ici, nous savons que les donn\u00e9es existaient auparavant, mais sont maintenant disparues,\n     * o\u00f9 Not Found signifie que nous ne pouvons tout simplement pas trouver d'informations \u00e0 leur sujet.\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface\n     *\/\n    final protected function respondGone(string $message, int|string|null $code = null, array $errors = [])\n    {\n        return $this->respondFail($message, $this->codes['resource_gone'] ?? StatusCode::GONE, $code, $errors);\n    }\n\n    \/**\n     * Utilis\u00e9 lorsqu'il y a une erreur de serveur.\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface\n     *\/\n    final protected function respondInternalError(string $message, int|string|null $code = null, array $errors = [])\n    {\n        return $this->respondFail($message, $this->codes['server_error'] ?? StatusCode::INTERNAL_ERROR, $code, $errors);\n    }\n\n    \/**\n     * Reponse de type invalid token\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface\n     *\/\n    final protected function respondInvalidToken(string $message, int|string|null $code = null, array $errors = [])\n    {\n        return $this->respondFail($message, $this->codes['invalid_token'] ?? StatusCode::INVALID_TOKEN, $code, $errors);\n    }\n\n    \/**\n     * Reponse de type method not allowed\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface\n     *\/\n    final protected function respondMethodNotAllowed(string $message, int|string|null $code = null, array $errors = [])\n    {\n        return $this->respondFail($message, $this->codes['not_allowed'] ?? StatusCode::METHOD_NOT_ALLOWED, $code, $errors);\n    }\n\n    \/**\n     * Utilis\u00e9 apr\u00e8s qu'une commande a \u00e9t\u00e9 ex\u00e9cut\u00e9e avec succ\u00e8s\n     * mais qu'il n'y a pas de r\u00e9ponse significative \u00e0 renvoyer au client.\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface|void\n     *\/\n    final protected function respondNoContent(string $message)\n    {\n        return $this->respondSuccess($message, null, $this->codes['no_content'] ?? StatusCode::NO_CONTENT);\n    }\n\n    \/**\n     * Reponse de type not acceptable\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface\n     *\/\n    final protected function respondNotAcceptable(string $message, int|string|null $code = null, array $errors = [])\n    {\n        return $this->respondFail($message, $this->codes['not_acceptable'] ?? StatusCode::NOT_ACCEPTABLE, $code, $errors);\n    }\n\n    \/**\n     * Utilis\u00e9 lorsqu'une ressource sp\u00e9cifi\u00e9e est introuvable.\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface|void\n     *\/\n    final protected function respondNotFound(string $message, int|string|null $code = null, array $errors = [])\n    {\n        return $this->respondFail($message, $this->codes['resource_not_found'] ?? StatusCode::NOT_FOUND, $code, $errors);\n    }\n\n    \/**\n     * Reponse de type not implemented\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface\n     *\/\n    final protected function respondNotImplemented(string $message, int|string|null $code = null, array $errors = [])\n    {\n        return $this->respondFail($message, $this->codes['not_implemented'] ?? StatusCode::NOT_IMPLEMENTED, $code, $errors);\n    }\n\n    \/**\n     * Reponse de type ok\n     *\n     * @param mixed|null $result\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface\n     *\/\n    final protected function respondOk(string $message, $result = null)\n    {\n        return $this->respondSuccess($message, $result, $this->codes['ok'] ?? StatusCode::OK);\n    }\n\n    \/**\n     * Utilis\u00e9 lorsque l'utilisateur a fait trop de demandes pour la ressource r\u00e9cemment.\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface|void\n     *\/\n    final protected function respondTooManyRequests(string $message, int|string|null $code = null, array $errors = [])\n    {\n        return $this->respondFail($message, $this->codes['too_many_requests'] ?? StatusCode::TOO_MANY_REQUESTS, $code, $errors);\n    }\n\n    \/**\n     * Utilis\u00e9 lorsque le client n'a pas envoy\u00e9 d'informations d'autorisation\n     * ou avait de mauvaises informations d'identification d'autorisation.\n     * L'utilisateur est encourag\u00e9 \u00e0 r\u00e9essayer avec les informations appropri\u00e9es.\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface\n     *\/\n    final protected function respondUnauthorized(string $message, int|string|null $code = null, array $errors = [])\n    {\n        return $this->respondFail($message, $this->codes['unauthorized'] ?? StatusCode::UNAUTHORIZED, $code, $errors);\n    }\n\n    \/**\n     * Utilis\u00e9 apr\u00e8s qu'une ressource a \u00e9t\u00e9 mise \u00e0 jour avec succ\u00e8s.\n     *\n     * @param mixed|null $result\n     *\n     * @return \\Psr\\Http\\Message\\ResponseInterface\n     *\/\n    final protected function respondUpdated(string $message, $result = null)\n    {\n        return $this->respondSuccess($message, $result, $this->codes['updated'] ?? StatusCode::OK);\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null]},{"name":"src\\Traits\\CliMessage.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Traits;\n\ntrait CliMessage\n{\n    \/**\n     * @var array messages pour la console\n     *\/\n    private $messages = [];\n\n    \/**\n     * Renvoi les messages pour la console\n     *\/\n    public function getMessages(): array\n    {\n        return $this->messages;\n    }\n\n    \/**\n     * Rajoute un nouveau message a la pile de message\n     *\/\n    private function pushMessage(string $message, string $color = 'green'): self\n    {\n        $this->messages[] = compact('message', 'color');\n\n        return $this;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null]},{"name":"src\\Traits\\InstanceConfigTrait.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Traits;\n\nuse BlitzPHP\\Utilities\\Arr;\nuse Exception;\nuse InvalidArgumentException;\n\n\/**\n * Un trait pour lire et \u00e9crire la configuration de l'instance\n *\n * Les objets d'impl\u00e9mentation doivent d\u00e9clarer une propri\u00e9t\u00e9 `$_defaultConfig`.\n *\/\ntrait InstanceConfigTrait\n{\n    \/**\n     * Configuration d'ex\u00e9cution\n     *\n     * @var array<string, mixed>\n     *\/\n    protected $_config = [];\n\n    \/**\n     * Si la propri\u00e9t\u00e9 config a d\u00e9j\u00e0 \u00e9t\u00e9 configur\u00e9e avec les valeurs par d\u00e9faut\n     *\n     * @var bool\n     *\/\n    protected $_configInitialized = false;\n\n    \/**\n     * D\u00e9finit la configuration.\n     *\n     * ### Utilisation\n     *\n     * D\u00e9finition d'une valeur sp\u00e9cifique :\n     *\n     * ```\n     * $this->setConfig('key', $value);\n     * ```\n     *\n     * D\u00e9finition d'une valeur imbriqu\u00e9e :\n     *\n     * ```\n     * $this->setConfig('some.nested.key', $value);\n     * ```\n     *\n     * Mise \u00e0 jour de plusieurs param\u00e8tres de configuration en m\u00eame temps :\n     *\n     * ```\n     * $this->setConfig(['one' => 'value', 'other' => 'value']);\n     * ```\n     *\n     * @param array<string, mixed>|string $key   La cl\u00e9 \u00e0 d\u00e9finir, ou un tableau complet de configurations.\n     * @param bool                        $merge Que ce soit pour fusionner ou \u00e9craser de mani\u00e8re r\u00e9cursive la configuration existante, la valeur par d\u00e9faut est true.\n     * @param mixed|null                  $value\n     *\n     * @throws Exception Lorsque vous essayez de d\u00e9finir une cl\u00e9 qui n'est pas valide.\n     *\/\n    public function setConfig($key, $value = null, bool $merge = true): self\n    {\n        if (! $this->_configInitialized) {\n            $this->_config            = $this->_defaultConfig;\n            $this->_configInitialized = true;\n        }\n\n        $this->_configWrite($key, $value, $merge);\n\n        return $this;\n    }\n\n    \/**\n     * Renvoie la configuration.\n     *\n     * ### Utilisation\n     *\n     * Lecture de toute la config :\n     *\n     * ```\n     * $this->getConfig();\n     * ```\n     *\n     * Lecture d'une valeur sp\u00e9cifique :\n     *\n     * ```\n     * $this->getConfig('key');\n     * ```\n     *\n     * Lecture d'une valeur imbriqu\u00e9e :\n     *\n     * ```\n     * $this->getConfig('some.nested.key');\n     * ```\n     *\n     * Lecture avec valeur par d\u00e9faut :\n     *\n     * ```\n     * $this->getConfig('some-key', 'default-value');\n     * ```\n     *\n     * @param mixed|null $default\n     *\n     * @return mixed Donn\u00e9es de configuration \u00e0 la cl\u00e9 nomm\u00e9e ou null si la cl\u00e9 n'existe pas.\n     *\/\n    public function getConfig(?string $key = null, $default = null)\n    {\n        if (! $this->_configInitialized) {\n            $this->_config            = $this->_defaultConfig;\n            $this->_configInitialized = true;\n        }\n\n        $return = $this->_configRead($key);\n\n        return $return ?? $default;\n    }\n\n    \/**\n     * Renvoie la configuration pour cette cl\u00e9 sp\u00e9cifique.\n     *\n     * La valeur de configuration de cette cl\u00e9 doit exister, elle ne peut jamais \u00eatre nulle.\n     *\n     * @throws InvalidArgumentException\n     *\/\n    public function getConfigOrFail(string $key)\n    {\n        $config = $this->getConfig($key);\n        if ($config === null) {\n            throw new InvalidArgumentException(sprintf('Expected configuration `%s` not found.', $key));\n        }\n\n        return $config;\n    }\n\n    \/**\n     * Fusionnez la configuration fournie avec la configuration existante. Contrairement \u00e0 `config()` qui fait\n     * une fusion r\u00e9cursive pour les cl\u00e9s imbriqu\u00e9es, cette m\u00e9thode effectue une fusion simple.\n     *\n     * D\u00e9finition d'une valeur sp\u00e9cifique :\n     *\n     * ```\n     * $this->configShallow('key', $value);\n     * ```\n     *\n     * D\u00e9finition d'une valeur imbriqu\u00e9e :\n     *\n     * ```\n     * $this->configShallow('some.nested.key', $value);\n     * ```\n     *\n     * Mise \u00e0 jour de plusieurs param\u00e8tres de configuration en m\u00eame temps :\n     *\n     * ```\n     * $this->configShallow(['one' => 'value', 'other' => 'value']);\n     * ```\n     *\n     * @param array<string, mixed>|string $key   La cl\u00e9 \u00e0 d\u00e9finir, ou un tableau complet de configurations.\n     * @param mixed|null                  $value\n     *\/\n    public function configShallow($key, $value = null): self\n    {\n        if (! $this->_configInitialized) {\n            $this->_config            = $this->_defaultConfig;\n            $this->_configInitialized = true;\n        }\n\n        $this->_configWrite($key, $value, 'shallow');\n\n        return $this;\n    }\n\n    \/**\n     * Lit une cl\u00e9 de configuration.\n     *\/\n    protected function _configRead(?string $key)\n    {\n        if ($key === null) {\n            return $this->_config;\n        }\n\n        if (strpos($key, '.') === false) {\n            return $this->_config[$key] ?? null;\n        }\n\n        $return = $this->_config;\n\n        foreach (explode('.', $key) as $k) {\n            if (! is_array($return) || ! isset($return[$k])) {\n                $return = null;\n                break;\n            }\n\n            $return = $return[$k];\n        }\n\n        return $return;\n    }\n\n    \/**\n     * \u00c9crit une cl\u00e9 de configuration.\n     *\n     * @param array<string, mixed>|string $key   Cl\u00e9 sur laquelle \u00e9crire.\n     * @param bool|string                 $merge True pour fusionner de mani\u00e8re r\u00e9cursive, 'shallow' pour une fusion simple,\n     *                                           false pour \u00e9craser, la valeur par d\u00e9faut est false.\n     * @param mixed                       $value\n     *\n     * @throws Exception si vous tentez d'\u00e9craser la configuration existante\n     *\/\n    protected function _configWrite($key, $value, $merge = false): void\n    {\n        if (is_string($key) && $value === null) {\n            $this->_configDelete($key);\n\n            return;\n        }\n\n        if ($merge) {\n            $update = is_array($key) ? $key : [$key => $value];\n            if ($merge === 'shallow') {\n                $this->_config = array_merge($this->_config, Arr::expand($update));\n            } else {\n                $this->_config = Arr::merge($this->_config, Arr::expand($update));\n            }\n\n            return;\n        }\n\n        if (is_array($key)) {\n            foreach ($key as $k => $val) {\n                $this->_configWrite($k, $val);\n            }\n\n            return;\n        }\n\n        if (strpos($key, '.') === false) {\n            $this->_config[$key] = $value;\n\n            return;\n        }\n\n        $update = &$this->_config;\n        $stack  = explode('.', $key);\n\n        foreach ($stack as $k) {\n            if (! is_array($update)) {\n                throw new Exception(sprintf('Cannot set %s value', $key));\n            }\n\n            $update[$k] ??= [];\n\n            $update = &$update[$k];\n        }\n\n        $update = $value;\n    }\n\n    \/**\n     * Supprime une seule cl\u00e9 de configuration.\n     *\n     * @throws Exception si vous tentez d'\u00e9craser la configuration existante\n     *\/\n    protected function _configDelete(string $key): void\n    {\n        if (strpos($key, '.') === false) {\n            unset($this->_config[$key]);\n\n            return;\n        }\n\n        $update = &$this->_config;\n        $stack  = explode('.', $key);\n        $length = count($stack);\n\n        foreach ($stack as $i => $k) {\n            if (! is_array($update)) {\n                throw new Exception(sprintf('Cannot unset %s value', $key));\n            }\n\n            if (! isset($update[$k])) {\n                break;\n            }\n\n            if ($i === $length - 1) {\n                unset($update[$k]);\n                break;\n            }\n\n            $update = &$update[$k];\n        }\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,null,0,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,null,null,0,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,0,null,0,null,null,0,null,null,null,null,0,null,null,0,null,null,null,0,null,0,null,null,0,0,null,null,null,0,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,0,0,null,null,null,0,null,null,null,0,null,null,null,0,0,null,null,0,null,null,null,null]},{"name":"src\\Traits\\Macroable.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Traits;\n\nuse BadMethodCallException;\nuse Closure;\nuse ReflectionClass;\nuse ReflectionException;\nuse ReflectionMethod;\n\ntrait Macroable\n{\n    \/**\n     * The registered string macros.\n     *\n     * @var array\n     *\/\n    protected static $macros = [];\n\n    \/**\n     * Register a custom macro.\n     *\n     * @param string          $name\n     * @param callable|object $macro\n     *\n     * @return void\n     *\/\n    public static function macro($name, $macro)\n    {\n        static::$macros[$name] = $macro;\n    }\n\n    \/**\n     * Mix another object into the class.\n     *\n     * @param object $mixin\n     * @param bool   $replace\n     *\n     * @throws ReflectionException\n     *\n     * @return void\n     *\/\n    public static function mixin($mixin, $replace = true)\n    {\n        $methods = (new ReflectionClass($mixin))->getMethods(\n            ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_PROTECTED\n        );\n\n        foreach ($methods as $method) {\n            if ($replace || ! static::hasMacro($method->name)) {\n                $method->setAccessible(true);\n                static::macro($method->name, $method->invoke($mixin));\n            }\n        }\n    }\n\n    \/**\n     * Checks if macro is registered.\n     *\n     * @param string $name\n     *\n     * @return bool\n     *\/\n    public static function hasMacro($name)\n    {\n        return isset(static::$macros[$name]);\n    }\n\n    \/**\n     * Dynamically handle calls to the class.\n     *\n     * @param string $method\n     * @param array  $parameters\n     *\n     * @throws BadMethodCallException\n     *\n     * @return mixed\n     *\/\n    public static function __callStatic($method, $parameters)\n    {\n        if (! static::hasMacro($method)) {\n            throw new BadMethodCallException(sprintf(\n                'Method %s::%s does not exist.',\n                static::class,\n                $method\n            ));\n        }\n\n        $macro = static::$macros[$method];\n\n        if ($macro instanceof Closure) {\n            return call_user_func_array(Closure::bind($macro, null, static::class), $parameters);\n        }\n\n        return $macro(...$parameters);\n    }\n\n    \/**\n     * Dynamically handle calls to the class.\n     *\n     * @param string $method\n     * @param array  $parameters\n     *\n     * @throws BadMethodCallException\n     *\n     * @return mixed\n     *\/\n    public function __call($method, $parameters)\n    {\n        if (! static::hasMacro($method)) {\n            throw new BadMethodCallException(sprintf(\n                'Method %s::%s does not exist.',\n                static::class,\n                $method\n            ));\n        }\n\n        $macro = static::$macros[$method];\n\n        if ($macro instanceof Closure) {\n            return ($macro->bindTo($this, static::class))(...$parameters);\n        }\n\n        return $macro(...$parameters);\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null]},{"name":"src\\Traits\\SingletonTrait.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Traits;\n\nuse RuntimeException;\n\n\/**\n * Ce trait fournit le mod\u00e8le Singleton (une seule instance pour la classe concr\u00e8te) aux classes qui l'utilisent.\n * Toute l'application enti\u00e8re peut accepter sa seule instance via la m\u00e9thode statique publique getInstance(),\n * fourni par le trait.\n * Si quelqu'un essaie de cloner ou de s\u00e9rialiser l'objet, le trait l\u00e8ve RuntimeException.\n * La propri\u00e9t\u00e9 statique pour la seule instance est d\u00e9clar\u00e9e comme prot\u00e9g\u00e9e et est instanci\u00e9e avec le mot-cl\u00e9 'static'\n * pour assurer la possibilit\u00e9 d'\u00e9tendre la classe.\n *\/\ntrait SingletonTrait\n{\n    \/**\n     * La seule instance d'utilisation de la classe\n     *\n     * @var object\n     *\/\n    protected static $_instance;\n\n    \/**\n     * V\u00e9rifie, instancie et renvoie la seule instance de la classe using.\n     *\/\n    public static function getInstance()\n    {\n        if (! (static::$_instance instanceof static)) {\n            $params            = func_get_args();\n            static::$_instance = new static(...$params);\n        }\n\n        return static::$_instance;\n    }\n\n    \/**\n     * @alias getInstance\n     *\/\n    public static function instance()\n    {\n        $params = func_get_args();\n\n        return static::getInstance(...$params);\n    }\n\n    \/**\n     * Constructeur de classe. La classe concr\u00e8te utilisant ce trait peut le remplacer.\n     *\/\n    protected function __construct()\n    {\n    }\n\n    \/**\n     * Emp\u00eache le clonage des objets\n     *\n     * @throws RuntimeException\n     *\/\n    public function __clone()\n    {\n        throw new RuntimeException('Cannot clone Singleton objects');\n    }\n\n    \/**\n     * Emp\u00eache la s\u00e9rialisation des objets\n     *\n     * @throws RuntimeException\n     *\/\n    public function __sleep()\n    {\n        throw new RuntimeException('Cannot serialize Singleton objects');\n    }\n\n    \/**\n     * Renvoie la seule instance si elle est appel\u00e9e en tant que fonction\n     *\n     * @return object\n     *\/\n    public function __invoke()\n    {\n        return static::getInstance();\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,2,0,null,null,2,null,null,null,null,null,null,null,2,null,2,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null]},{"name":"src\\Traits\\StaticConfigTrait.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Traits;\n\nuse BadMethodCallException;\nuse InvalidArgumentException;\nuse LogicException;\n\n\/**\n * A trait that provides a set of static methods to manage configuration\n * for classes that provide an adapter facade or need to have sets of\n * configuration data registered and manipulated.\n *\n * Implementing objects are expected to declare a static `$_dsnClassMap` property.\n *\/\ntrait StaticConfigTrait\n{\n    \/**\n     * Configuration sets.\n     *\n     * @var array<string, mixed>\n     *\/\n    protected static $_config = [];\n\n    \/**\n     * This method can be used to define configuration adapters for an application.\n     *\n     * To change an adapter's configuration at runtime, first drop the adapter and then\n     * reconfigure it.\n     *\n     * Adapters will not be constructed until the first operation is done.\n     *\n     * ### Usage\n     *\n     * Assuming that the class' name is `Cache` the following scenarios\n     * are supported:\n     *\n     * Setting a cache engine up.\n     *\n     * ```\n     * Cache::setConfig('default', $settings);\n     * ```\n     *\n     * Injecting a constructed adapter in:\n     *\n     * ```\n     * Cache::setConfig('default', $instance);\n     * ```\n     *\n     * Configure multiple adapters at once:\n     *\n     * ```\n     * Cache::setConfig($arrayOfConfig);\n     * ```\n     *\n     * @param array<string, mixed>|string      $key    The name of the configuration, or an array of multiple configs.\n     * @param array<string, mixed>|object|null $config An array of name => configuration data for adapter.\n     *\n     * @throws BadMethodCallException When trying to modify an existing config.\n     * @throws LogicException         When trying to store an invalid structured config array.\n     *\/\n    public static function setConfig($key, $config = null): void\n    {\n        if ($config === null) {\n            if (! is_array($key)) {\n                throw new LogicException('If config is null, key must be an array.');\n            }\n\n            foreach ($key as $name => $settings) {\n                static::setConfig($name, $settings);\n            }\n\n            return;\n        }\n\n        if (isset(static::$_config[$key])) {\n            \/** @psalm-suppress PossiblyInvalidArgument *\/\n            throw new BadMethodCallException(sprintf('Cannot reconfigure existing key \"%s\"', $key));\n        }\n\n        if (is_object($config)) {\n            $config = ['className' => $config];\n        }\n\n        if (isset($config['url'])) {\n            $parsed = static::parseDsn($config['url']);\n            unset($config['url']);\n            $config = $parsed + $config;\n        }\n\n        if (isset($config['engine']) && empty($config['className'])) {\n            $config['className'] = $config['engine'];\n            unset($config['engine']);\n        }\n        \/** @psalm-suppress InvalidPropertyAssignmentValue *\/\n        static::$_config[$key] = $config;\n    }\n\n    \/**\n     * Reads existing configuration.\n     *\n     * @param string $key The name of the configuration.\n     *\n     * @return mixed|null Configuration data at the named key or null if the key does not exist.\n     *\/\n    public static function getConfig(string $key)\n    {\n        return static::$_config[$key] ?? null;\n    }\n\n    \/**\n     * Reads existing configuration for a specific key.\n     *\n     * The config value for this key must exist, it can never be null.\n     *\n     * @param string $key The name of the configuration.\n     *\n     * @throws InvalidArgumentException If value does not exist.\n     *\n     * @return mixed Configuration data at the named key.\n     *\/\n    public static function getConfigOrFail(string $key)\n    {\n        if (! isset(static::$_config[$key])) {\n            throw new InvalidArgumentException(sprintf('Expected configuration `%s` not found.', $key));\n        }\n\n        return static::$_config[$key];\n    }\n\n    \/**\n     * Drops a constructed adapter.\n     *\n     * If you wish to modify an existing configuration, you should drop it,\n     * change configuration and then re-add it.\n     *\n     * If the implementing objects supports a `$_registry` object the named configuration\n     * will also be unloaded from the registry.\n     *\n     * @param string $config An existing configuration you wish to remove.\n     *\n     * @return bool Success of the removal, returns false when the config does not exist.\n     *\/\n    public static function drop(string $config): bool\n    {\n        if (! isset(static::$_config[$config])) {\n            return false;\n        }\n        \/** @psalm-suppress RedundantPropertyInitializationCheck *\/\n        if (isset(static::$_registry)) {\n            static::$_registry->unload($config);\n        }\n        unset(static::$_config[$config]);\n\n        return true;\n    }\n\n    \/**\n     * Returns an array containing the named configurations\n     *\n     * @return array<string> Array of configurations.\n     *\/\n    public static function configured(): array\n    {\n        $configurations = array_keys(static::$_config);\n\n        return array_map(static fn ($key) => (string) $key, $configurations);\n    }\n\n    \/**\n     * Parses a DSN into a valid connection configuration\n     *\n     * This method allows setting a DSN using formatting similar to that used by PEAR::DB.\n     * The following is an example of its usage:\n     *\n     * ```\n     * $dsn = 'mysql:\/\/user:pass@localhost\/database?';\n     * $config = ConnectionManager::parseDsn($dsn);\n     *\n     * $dsn = 'Cake\\Log\\Engine\\FileLog:\/\/?types=notice,info,debug&file=debug&path=LOGS';\n     * $config = Log::parseDsn($dsn);\n     *\n     * $dsn = 'smtp:\/\/user:secret@localhost:25?timeout=30&client=null&tls=null';\n     * $config = Email::parseDsn($dsn);\n     *\n     * $dsn = 'file:\/\/\/?className=\\My\\Cache\\Engine\\FileEngine';\n     * $config = Cache::parseDsn($dsn);\n     *\n     * $dsn = 'File:\/\/?prefix=myapp_cake_core_&serialize=true&duration=+2 minutes&path=\/tmp\/persistent\/';\n     * $config = Cache::parseDsn($dsn);\n     * ```\n     *\n     * For all classes, the value of `scheme` is set as the value of both the `className`\n     * unless they have been otherwise specified.\n     *\n     * Note that querystring arguments are also parsed and set as values in the returned configuration.\n     *\n     * @param string $dsn The DSN string to convert to a configuration array\n     *\n     * @throws InvalidArgumentException If not passed a string, or passed an invalid string\n     *\n     * @return array<string, mixed> The configuration array to be stored after parsing the DSN\n     *\/\n    public static function parseDsn(string $dsn): array\n    {\n        if (empty($dsn)) {\n            return [];\n        }\n\n        $pattern = <<<'REGEXP'\n            {\n                ^\n                (?P<_scheme>\n                    (?P<scheme>[\\w\\\\\\\\]+):\/\/\n                )\n                (?P<_username>\n                    (?P<username>.*?)\n                    (?P<_password>\n                        :(?P<password>.*?)\n                    )?\n                    @\n                )?\n                (?P<_host>\n                    (?P<host>[^?#\/:@]+)\n                    (?P<_port>\n                        :(?P<port>\\d+)\n                    )?\n                )?\n                (?P<_path>\n                    (?P<path>\/[^?#]*)\n                )?\n                (?P<_query>\n                    \\?(?P<query>[^#]*)\n                )?\n                (?P<_fragment>\n                    \\#(?P<fragment>.*)\n                )?\n                $\n            }x\n            REGEXP;\n\n        preg_match($pattern, $dsn, $parsed);\n\n        if (! $parsed) {\n            throw new InvalidArgumentException(\"The DSN string '{$dsn}' could not be parsed.\");\n        }\n\n        $exists = [];\n\n        foreach ($parsed as $k => $v) {\n            if (is_int($k)) {\n                unset($parsed[$k]);\n            } elseif (strpos($k, '_') === 0) {\n                $exists[substr($k, 1)] = ($v !== '');\n                unset($parsed[$k]);\n            } elseif ($v === '' && ! $exists[$k]) {\n                unset($parsed[$k]);\n            }\n        }\n\n        $query = '';\n\n        if (isset($parsed['query'])) {\n            $query = $parsed['query'];\n            unset($parsed['query']);\n        }\n\n        parse_str($query, $queryArgs);\n\n        foreach ($queryArgs as $key => $value) {\n            if ($value === 'true') {\n                $queryArgs[$key] = true;\n            } elseif ($value === 'false') {\n                $queryArgs[$key] = false;\n            } elseif ($value === 'null') {\n                $queryArgs[$key] = null;\n            }\n        }\n\n        $parsed = $queryArgs + $parsed;\n\n        if (empty($parsed['className'])) {\n            $classMap = static::getDsnClassMap();\n\n            $parsed['className'] = $parsed['scheme'];\n            if (isset($classMap[$parsed['scheme']])) {\n                \/** @psalm-suppress PossiblyNullArrayOffset *\/\n                $parsed['className'] = $classMap[$parsed['scheme']];\n            }\n        }\n\n        return $parsed;\n    }\n\n    \/**\n     * Updates the DSN class map for this class.\n     *\n     * @param array<string, string> $map Additions\/edits to the class map to apply.\n     * @psalm-param array<string, class-string> $map\n     *\/\n    public static function setDsnClassMap(array $map): void\n    {\n        static::$_dsnClassMap = $map + static::$_dsnClassMap;\n    }\n\n    \/**\n     * Returns the DSN class map for this class.\n     *\n     * @return array<string, string>\n     * @psalm-return array<string, class-string>\n     *\/\n    public static function getDsnClassMap(): array\n    {\n        return static::$_dsnClassMap;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,0,null,null,null,0,null,null,null,0,0,0,null,null,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,0,null,0,0,null,0,null,null,null,0,null,null,0,0,null,null,0,null,null,null,0,null,0,null,0,null,null,null,0,null,null,0,null,0,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null]},{"name":"src\\Utilities\\Arr.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Utilities;\n\nuse ArrayAccess;\nuse BlitzPHP\\Traits\\Macroable;\nuse Exception;\nuse InvalidArgumentException;\n\nclass Arr\n{\n    use Macroable;\n\n    public const SORT_ASC  = 1;\n    public const SORT_DESC = 2;\n\n    \/**\n     * D\u00e9terminez si la valeur donn\u00e9e est un tableau accessible.\n     *\n     * @param mixed $value\n     *\/\n    public static function accessible($value): bool\n    {\n        return is_array($value) || $value instanceof ArrayAccess;\n    }\n\n    \/**\n     * Ajoutez un \u00e9l\u00e9ment \u00e0 un tableau en utilisant la notation \"point\" s'il n'existe pas.\n     *\n     * @param mixed $value\n     *\/\n    public static function add(array $array, string $key, $value): array\n    {\n        if (null === static::get($array, $key)) {\n            static::set($array, $key, $value);\n        }\n\n        return $array;\n    }\n\n    \/**\n     * Teste si oui ou non un chemin donn\u00e9 existe dans $data.\n     * Cette m\u00e9thode utilise la m\u00eame syntaxe de chemin que Arr::extract()\n     *\n     * La v\u00e9rification des chemins qui pourraient cibler plus d'un \u00e9l\u00e9ment\n     * assurez-vous qu'au moins un \u00e9l\u00e9ment correspondant existe.\n     *\n     * @param array  $data La donn\u00e9e \u00e0 v\u00e9rifier\n     * @param string $path Le chemin \u00e0 v\u00e9rifier.\n     *\n     * @see self::extract()\n     * @credit CakePHP - http:\/\/book.cakephp.org\/2.0\/en\/core-utility-libraries\/hash.html#Hash::check\n     *\/\n    public static function check(array $data, string $path): bool\n    {\n        $results = self::extract($data, $path);\n        if (! is_array($results)) {\n            return false;\n        }\n\n        return count($results) > 0;\n    }\n\n    \/**\n     * R\u00e9duire un tableau de tableaux en un seul tableau.\n     *\/\n    public static function collapse(array $array): array\n    {\n        $results = [];\n\n        foreach ($array as $values) {\n            if ($values instanceof Collection) {\n                $values = $values->all();\n            } elseif (! is_array($values)) {\n                continue;\n            }\n\n            $results[] = $values;\n        }\n\n        return array_merge([], ...$results);\n    }\n\n    \/**\n     * Cr\u00e9e un tableau associatif en utilisant `$keyPath` comme chemin pour construire ses cl\u00e9s, et \u00e9ventuellement\n     * `$valuePath` comme chemin pour obtenir les valeurs. Si `$valuePath` n'est pas sp\u00e9cifi\u00e9, toutes les valeurs seront initialis\u00e9es\n     * \u00e0 null (utile pour Arr::merge). Vous pouvez \u00e9ventuellement regrouper les valeurs en fonction de ce qui est obtenu lorsque\n     * le chemin est sp\u00e9cifi\u00e9 dans `$groupPath`.\n     *\n     * @param array  $data      Array from where to extract keys and values\n     * @param string $keyPath   A dot-separated string.\n     * @param string $valuePath A dot-separated string.\n     * @param string $groupPath A dot-separated string.\n     *\n     * @return array Combined array\n     * @credit CakePHP - http:\/\/book.cakephp.org\/2.0\/en\/core-utility-libraries\/hash.html#Hash::combine\n     *\/\n    public static function combine(array $data, string $keyPath, ?string $valuePath = null, ?string $groupPath = null): array\n    {\n        if (empty($data)) {\n            return [];\n        }\n\n        if (is_array($keyPath)) {\n            $format = array_shift($keyPath);\n            $keys   = self::format($data, $keyPath, $format);\n        } else {\n            $keys = self::extract($data, $keyPath);\n        }\n        if (empty($keys)) {\n            return [];\n        }\n\n        if (! empty($valuePath) && is_array($valuePath)) {\n            $format = array_shift($valuePath);\n            $vals   = self::format($data, $valuePath, $format);\n        } elseif (! empty($valuePath)) {\n            $vals = self::extract($data, $valuePath);\n        }\n        if (empty($vals)) {\n            $vals = array_fill(0, count($keys), null);\n        }\n\n        if (count($keys) !== count($vals)) {\n            throw new Exception('Arr::combine() needs an equal number of keys + values.');\n        }\n\n        if ($groupPath !== null) {\n            $group = self::extract($data, $groupPath);\n            if (! empty($group)) {\n                $c = count($keys);\n\n                for ($i = 0; $i < $c; $i++) {\n                    if (! isset($group[$i])) {\n                        $group[$i] = 0;\n                    }\n                    if (! isset($out[$group[$i]])) {\n                        $out[$group[$i]] = [];\n                    }\n                    $out[$group[$i]][$keys[$i]] = $vals[$i];\n                }\n\n                return $out;\n            }\n        }\n        if (empty($vals)) {\n            return [];\n        }\n\n        return array_combine($keys, $vals);\n    }\n\n    \/**\n     * Determines if one array contains the exact keys and values of another.\n     *\n     * @param array $data   The data to search through.\n     * @param array $needle The values to file in $data\n     *\n     * @return bool true if $data contains $needle, false otherwise\n     * @credit CakePHP - http:\/\/book.cakephp.org\/2.0\/en\/core-utility-libraries\/hash.html#Hash::contains\n     *\/\n    public static function contains(array $data, array $needle): bool\n    {\n        if (empty($data) || empty($needle)) {\n            return false;\n        }\n        $stack = [];\n\n        while (! empty($needle)) {\n            $key = key($needle);\n            $val = $needle[$key];\n            unset($needle[$key]);\n\n            if (array_key_exists($key, $data) && is_array($val)) {\n                $next = $data[$key];\n                unset($data[$key]);\n\n                if (! empty($val)) {\n                    $stack[] = [$val, $next];\n                }\n            } elseif (! array_key_exists($key, $data) || $data[$key] !== $val) {\n                return false;\n            }\n\n            if (empty($needle) && ! empty($stack)) {\n                [$needle, $data] = array_pop($stack);\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * Cross join the given arrays, returning all possible permutations.\n     *\/\n    public static function crossJoin(array ...$arrays): array\n    {\n        $results = [[]];\n\n        foreach ($arrays as $index => $array) {\n            $append = [];\n\n            foreach ($results as $product) {\n                foreach ($array as $item) {\n                    $product[$index] = $item;\n\n                    $append[] = $product;\n                }\n            }\n\n            $results = $append;\n        }\n\n        return $results;\n    }\n\n    \/**\n     * Counts the dimensions of an array.\n     * Only considers the dimension of the first element in the array.\n     *\n     * If you have an un-even or heterogenous array, consider using Hash::maxDimensions()\n     * to get the dimensions of the array.\n     *\n     * @param array $data Array to count dimensions on\n     *\n     * @return int The number of dimensions in $data\n     * @credit CakePHP - http:\/\/book.cakephp.org\/2.0\/en\/core-utility-libraries\/hash.html#Hash::dimensions\n     *\/\n    public static function dimensions(array $data): int\n    {\n        if (empty($data)) {\n            return 0;\n        }\n        reset($data);\n        $depth = 1;\n\n        while ($elem = array_shift($data)) {\n            if (is_array($elem)) {\n                $depth++;\n                $data = &$elem;\n            } else {\n                break;\n            }\n        }\n\n        return $depth;\n    }\n\n    \/**\n     * Divide an array into two arrays. One with keys and the other with values.\n     *\/\n    public static function divide(array $array): array\n    {\n        return [array_keys($array), array_values($array)];\n    }\n\n    \/**\n     * Flatten a multi-dimensional associative array with dots.\n     *\/\n    public static function dot(array $array, string $prepend = ''): array\n    {\n        $results = [];\n\n        foreach ($array as $key => $value) {\n            if (is_array($value) && ! empty($value)) {\n                $results = array_merge($results, static::dot($value, $prepend . $key . '.'));\n            } else {\n                $results[$prepend . $key] = $value;\n            }\n        }\n\n        return $results;\n    }\n\n    \/**\n     * Get all of the given array except for a specified array of keys.\n     *\n     * @param array|string $keys\n     *\/\n    public static function except(array $array, $keys): array\n    {\n        static::forget($array, $keys);\n\n        return $array;\n    }\n\n    \/**\n     * Determine if the given key exists in the provided array.\n     *\n     * @param array|ArrayAccess $array\n     * @param int|string        $key\n     *\/\n    public static function exists($array, $key): bool\n    {\n        if ($array instanceof ArrayAccess) {\n            return $array->offsetExists($key);\n        }\n\n        return array_key_exists($key, $array);\n    }\n\n    \/**\n     * Explode the \"value\" and \"key\" arguments passed to \"pluck\".\n     *\n     * @param array|string      $value\n     * @param array|string|null $key\n     *\/\n    protected static function explodePluckParameters($value, $key): array\n    {\n        $value = is_string($value) ? explode('.', $value) : $value;\n\n        $key = null === $key || is_array($key) ? $key : explode('.', $key);\n\n        return [$value, $key];\n    }\n\n    \/**\n     * Gets the values from an array matching the $path expression.\n     * The path expression is a dot separated expression, that can contain a set\n     * of patterns and expressions:\n     *\n     * - `{n}` Matches any numeric key, or integer.\n     * - `{s}` Matches any string key.\n     * - `Foo` Matches any key with the exact same value.\n     *\n     * There are a number of attribute operators:\n     *\n     *  - `=`, `!=` Equality.\n     *  - `>`, `<`, `>=`, `<=` Value comparison.\n     *  - `=\/...\/` Regular expression pattern match.\n     *\n     * Given a set of User array data, from a `$User->find('all')` call:\n     *\n     * - `1.User.name` Get the name of the user at index 1.\n     * - `{n}.User.name` Get the name of every user in the set of users.\n     * - `{n}.User[id]` Get the name of every user with an id key.\n     * - `{n}.User[id>=2]` Get the name of every user with an id key greater than or equal to 2.\n     * - `{n}.User[username=\/^paul\/]` Get User elements with username matching `^paul`.\n     *\n     * @param array  $data The data to extract from.\n     * @param string $path The path to extract.\n     *\n     * @return array An array of the extracted values. Returns an empty array\n     *               if there are no matches.\n     * @credit CakePHP - http:\/\/book.cakephp.org\/2.0\/en\/core-utility-libraries\/hash.html#Hash::extract\n     *\/\n    public static function extract(array $data, string $path): array\n    {\n        if (empty($path)) {\n            return $data;\n        }\n\n        \/\/ Simple paths.\n        if (! preg_match('\/[{\\[]\/', $path)) {\n            return (array) self::get($data, $path);\n        }\n\n        if (strpos($path, '[') === false) {\n            $tokens = explode('.', $path);\n        } else {\n            $tokens = Str::tokenize($path, '.', '[', ']');\n        }\n\n        $_key = '__set_item__';\n\n        $context = [$_key => [$data]];\n\n        foreach ($tokens as $token) {\n            $next = [];\n\n            [$token, $conditions] = self::_splitConditions($token);\n\n            foreach ($context[$_key] as $item) {\n                foreach ((array) $item as $k => $v) {\n                    if (self::_matchToken($k, $token)) {\n                        $next[] = $v;\n                    }\n                }\n            }\n\n            \/\/ Filter for attributes.\n            if ($conditions) {\n                $filter = [];\n\n                foreach ($next as $item) {\n                    if (is_array($item) && self::_matches($item, $conditions)) {\n                        $filter[] = $item;\n                    }\n                }\n                $next = $filter;\n            }\n            $context = [$_key => $next];\n        }\n\n        return $context[$_key];\n    }\n\n    \/**\n     * Expands a flat array to a nested array.\n     *\n     * For example, unflattens an array that was collapsed with `Hash::flatten()`\n     * into a multi-dimensional array. So, `array('0.Foo.Bar' => 'Far')` becomes\n     * `array(array('Foo' => array('Bar' => 'Far')))`.\n     *\n     * @param array  $data      Flattened array\n     * @param string $separator The delimiter used\n     * @credit CakePHP - http:\/\/book.cakephp.org\/2.0\/en\/core-utility-libraries\/hash.html#Hash::expand\n     *\/\n    public static function expand(array $data, string $separator = '.'): array\n    {\n        $result = [];\n\n        foreach ($data as $flat => $value) {\n            $keys  = explode($separator, $flat);\n            $keys  = array_reverse($keys);\n            $child = [$keys[0] => $value];\n            array_shift($keys);\n\n            foreach ($keys as $k) {\n                $child = [$k => $child];\n            }\n            $result = self::merge($result, $child);\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Recursively filters a data set.\n     *\n     * @param array    $data     Either an array to filter, or value when in callback\n     * @param callable $callback A function to filter the data with. Defaults to\n     *                           `self::_filter()` Which strips out all non-zero empty values.\n     *\n     * @return array Filtered array\n     * @credit CakePHP - http:\/\/book.cakephp.org\/2.0\/en\/core-utility-libraries\/hash.html#Hash::filter\n     *\/\n    public static function filter(array $data, $callback = ['self', '_filter']): array\n    {\n        foreach ($data as $k => $v) {\n            if (is_array($v)) {\n                $data[$k] = self::filter($v, $callback);\n            }\n        }\n\n        return array_filter($data, $callback);\n    }\n\n    \/**\n     * Return the first element in an array passing a given truth test.\n     *\n     * @param mixed $default\n     *\n     * @return mixed\n     *\/\n    public static function first(array $array, ?callable $callback = null, $default = null)\n    {\n        if (null === $callback) {\n            if (empty($array)) {\n                return $default;\n            }\n\n            foreach ($array as $item) {\n                return $item;\n            }\n        }\n\n        foreach ($array as $key => $value) {\n            if ($callback($value, $key)) {\n                return $value;\n            }\n        }\n\n        return $default;\n    }\n\n    \/**\n     * Collapses a multi-dimensional array into a single dimension, using a delimited array path for\n     * each array element's key, i.e. array(array('Foo' => array('Bar' => 'Far'))) becomes\n     * array('0.Foo.Bar' => 'Far').)\n     *\n     * @param array  $data      Array to flatten\n     * @param string $separator String used to separate array key elements in a path, defaults to '.'\n     * @credit http:\/\/book.cakephp.org\/2.0\/en\/core-utility-libraries\/hash.html#Hash::flatten\n     *\/\n    public static function flatten(array $data, string $separator = '.'): array\n    {\n        $result = [];\n        $stack  = [];\n        $path   = null;\n\n        reset($data);\n\n        while (! empty($data)) {\n            $key     = key($data);\n            $element = $data[$key];\n            unset($data[$key]);\n\n            if (is_array($element) && ! empty($element)) {\n                if (! empty($data)) {\n                    $stack[] = [$data, $path];\n                }\n                $data = $element;\n                reset($data);\n                $path .= $key . $separator;\n            } else {\n                $result[$path . $key] = $element;\n            }\n\n            if (empty($data) && ! empty($stack)) {\n                [$data, $path] = array_pop($stack);\n                reset($data);\n            }\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Remove one or many array items from a given array using \"dot\" notation.\n     *\n     * @param array|string $keys\n     *\n     * @return void\n     *\/\n    public static function forget(array &$array, $keys)\n    {\n        $original = &$array;\n\n        $keys = (array) $keys;\n\n        if (count($keys) === 0) {\n            return;\n        }\n\n        foreach ($keys as $key) {\n            \/\/ if the exact key exists in the top-level, remove it\n            if (static::exists($array, $key)) {\n                unset($array[$key]);\n\n                continue;\n            }\n\n            $parts = explode('.', $key);\n\n            \/\/ clean up before each pass\n            $array = &$original;\n\n            while (count($parts) > 1) {\n                $part = array_shift($parts);\n\n                if (isset($array[$part]) && is_array($array[$part])) {\n                    $array = &$array[$part];\n                } else {\n                    continue 2;\n                }\n            }\n\n            unset($array[array_shift($parts)]);\n        }\n    }\n\n    \/**\n     * Returns a formatted series of values extracted from `$data`, using\n     * `$format` as the format and `$paths` as the values to extract.\n     *\n     * Usage:\n     *\n     * {{{\n     * $result = Hash::format($users, array('{n}.User.id', '{n}.User.name'), '%s : %s');\n     * }}}\n     *\n     * The `$format` string can use any format options that `vsprintf()` and `sprintf()` do.\n     *\n     * @param array  $data   Source array from which to extract the data\n     * @param array  $paths  An array containing one or more Hash::extract()-style key paths\n     * @param string $format Format string into which values will be inserted, see sprintf()\n     *\n     * @return array|null An array of strings extracted from `$path` and formatted with `$format`\n     *\n     * @see http:\/\/book.cakephp.org\/2.0\/en\/core-utility-libraries\/hash.html#Hash::format\n     * @see sprintf()\n     * @see Tableau::extract()\n     * @credit CakePHP - http:\/\/book.cakephp.org\/2.0\/en\/core-utility-libraries\/hash.html#Hash::format\n     *\/\n    public static function format(array $data, array $paths, string $format)\n    {\n        $extracted = [];\n        $count     = count($paths);\n\n        if (! $count) {\n            return;\n        }\n\n        for ($i = 0; $i < $count; $i++) {\n            $extracted[] = self::extract($data, $paths[$i]);\n        }\n        $out   = [];\n        $data  = $extracted;\n        $count = count($data[0]);\n\n        $countTwo = count($data);\n\n        for ($j = 0; $j < $count; $j++) {\n            $args = [];\n\n            for ($i = 0; $i < $countTwo; $i++) {\n                if (array_key_exists($j, $data[$i])) {\n                    $args[] = $data[$i][$j];\n                }\n            }\n            $out[] = vsprintf($format, $args);\n        }\n\n        return $out;\n    }\n\n    \/**\n     * Get a single value specified by $path out of $data.\n     * Does not support the full dot notation feature set,\n     * but is faster for simple read operations.\n     *\n     * @param array|ArrayAccess $data    Array of data to operate on.\n     * @param array|string      $path    The path being searched for. Either a dot\n     *                                   separated string, or an array of path segments.\n     * @param mixed             $default The return value when the path does not exist\n     *\n     * @return mixed The value fetched from the array, or null.\n     * @credit CakePHP - http:\/\/book.cakephp.org\/2.0\/en\/core-utility-libraries\/hash.html#Hash::get\n     *\/\n    public static function get($data, $path, $default = null)\n    {\n        if (! static::accessible($data)) {\n            return $default;\n        }\n        if (is_string($path) || is_numeric($path)) {\n            $parts = explode('.', $path);\n        } else {\n            $parts = $path;\n        }\n\n        foreach ($parts as $key) {\n            if (is_array($data) && isset($data[$key])) {\n                $data = &$data[$key];\n            } else {\n                return $default;\n            }\n        }\n\n        return $data;\n    }\n\n    \/**\n     * @return mixed\n     *\/\n    public static function getRecursive(?array $data, ?string $key = null)\n    {\n        if (empty($data)) {\n            return null;\n        }\n        if (empty($key)) {\n            return $data;\n        }\n\n        $key   = explode('.', $key);\n        $count = count($key);\n\n        if ($count === 1) {\n            return $data[$key[0]] ?? null;\n        }\n\n        $sub_key = $key[1];\n\n        for ($i = 2; $i < $count; $i++) {\n            $sub_key .= '.' . $key[$i];\n        }\n\n        return self::getRecursive($data[$key[0]] ?? null, $sub_key);\n    }\n\n    \/**\n     * Check if an item or items exist in an array using \"dot\" notation.\n     *\n     * @param array|ArrayAccess $array\n     * @param array|string      $keys\n     *\/\n    public static function has($array, $keys): bool\n    {\n        $keys = (array) $keys;\n\n        if (! $array || $keys === []) {\n            return false;\n        }\n\n        foreach ($keys as $key) {\n            $subKeyArray = $array;\n\n            if (static::exists($array, $key)) {\n                continue;\n            }\n\n            foreach (explode('.', $key) as $segment) {\n                if (static::accessible($subKeyArray) && static::exists($subKeyArray, $segment)) {\n                    $subKeyArray = $subKeyArray[$segment];\n                } else {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * Insert $values into an array with the given $path. You can use\n     * `{n}` and `{s}` elements to insert $data multiple times.\n     *\n     * @param array  $data   The data to insert into.\n     * @param string $path   The path to insert at.\n     * @param array  $values The values to insert.\n     *\n     * @return array The data with $values inserted.\n     * @credit CakePHP - http:\/\/book.cakephp.org\/2.0\/en\/core-utility-libraries\/hash.html#Hash::insert\n     *\/\n    public static function insert(array $data, $path, $values = null)\n    {\n        if (strpos($path, '[') === false) {\n            $tokens = explode('.', $path);\n        } else {\n            $tokens = Str::tokenize($path, '.', '[', ']');\n        }\n        if (strpos($path, '{') === false && strpos($path, '[') === false) {\n            return self::_simpleOp('insert', $data, $tokens, $values);\n        }\n\n        $token    = array_shift($tokens);\n        $nextPath = implode('.', $tokens);\n\n        [$token, $conditions] = self::_splitConditions($token);\n\n        foreach ($data as $k => $v) {\n            if (self::_matchToken($k, $token)) {\n                if ($conditions && self::_matches($v, $conditions)) {\n                    $data[$k] = array_merge($v, $values);\n\n                    continue;\n                }\n                if (! $conditions) {\n                    $data[$k] = self::insert($v, $nextPath, $values);\n                }\n            }\n        }\n\n        return $data;\n    }\n\n    \/**\n     * Determines if an array is associative.\n     *\n     * An array is \"associative\" if it doesn't have sequential numerical keys beginning with zero.\n     *\/\n    public static function isAssoc(array $array): bool\n    {\n        $keys = array_keys($array);\n\n        return array_keys($keys) !== $keys;\n    }\n\n    \/**\n     * Return the last element in an array passing a given truth test.\n     *\n     * @param mixed $default\n     *\n     * @return mixed\n     *\/\n    public static function last(array $array, ?callable $callback = null, $default = null)\n    {\n        if (null === $callback) {\n            return empty($array) ? $default : end($array);\n        }\n\n        return static::first(array_reverse($array, true), $callback, $default);\n    }\n\n    \/**\n     * Counts the dimensions of *all* array elements. Useful for finding the maximum\n     * number of dimensions in a mixed array.\n     *\n     * @param array $data Array to count dimensions on\n     *\n     * @return int The maximum number of dimensions in $data\n     * @credit CakePHP - http:\/\/book.cakephp.org\/2.0\/en\/core-utility-libraries\/hash.html#Hash::maxDimensions\n     *\/\n    public static function maxDimensions(array $data): int\n    {\n        $depth = [];\n        if (is_array($data) && reset($data) !== false) {\n            foreach ($data as $value) {\n                $depth[] = self::dimensions((array) $value) + 1;\n            }\n        }\n\n        return max($depth);\n    }\n\n    \/**\n     * This function can be thought of as a hybrid between PHP's `array_merge` and `array_merge_recursive`.\n     *\n     * The difference between this method and the built-in ones, is that if an array key contains another array, then\n     * Hash::merge() will behave in a recursive fashion (unlike `array_merge`). But it will not act recursively for\n     * keys that contain scalar values (unlike `array_merge_recursive`).\n     *\n     * Note: This function will work with an unlimited amount of arguments and typecasts non-array parameters into arrays.\n     *\n     * @param array $data  Array to be merged\n     * @param mixed $merge Array to merge with. The argument and all trailing arguments will be array cast when merged\n     *\n     * @return array Merged array\n     * @credit CakePHP - http:\/\/book.cakephp.org\/2.0\/en\/core-utility-libraries\/hash.html#Hash::merge\n     *\/\n    public static function merge(array $data, $merge)\n    {\n        $args   = func_get_args();\n        $return = current($args);\n\n        while (($arg = next($args)) !== false) {\n            foreach ((array) $arg as $key => $val) {\n                if (! empty($return[$key]) && is_array($return[$key]) && is_array($val)) {\n                    $return[$key] = self::merge($return[$key], $val);\n                } elseif (is_int($key) && isset($return[$key])) {\n                    $return[] = $val;\n                } else {\n                    $return[$key] = $val;\n                }\n            }\n        }\n\n        return $return;\n    }\n\n    \/**\n     * Checks to see if all the values in the array are numeric\n     *\n     * @param array $data The array to check.\n     *\n     * @return bool true if values are numeric, false otherwise\n     * @credit CakePHP - http:\/\/book.cakephp.org\/2.0\/en\/core-utility-libraries\/hash.html#Hash::numeric\n     *\/\n    public static function numeric(array $data): bool\n    {\n        if (empty($data)) {\n            return false;\n        }\n\n        return $data === array_filter($data, 'is_numeric');\n    }\n\n    \/**\n     * Get a subset of the items from the given array.\n     *\n     * @param array|string $keys\n     *\/\n    public static function only(array $array, $keys): array\n    {\n        return array_intersect_key($array, array_flip((array) $keys));\n    }\n\n    \/**\n     * Push an item onto the beginning of an array.\n     *\n     * @param mixed $value\n     * @param mixed $key\n     *\/\n    public static function prepend(array $array, $value, $key = null): array\n    {\n        if (null === $key) {\n            array_unshift($array, $value);\n        } else {\n            $array = [$key => $value] + $array;\n        }\n\n        return $array;\n    }\n\n    \/**\n     * Get a value from the array, and remove it.\n     *\n     * @param mixed $default\n     *\n     * @return mixed\n     *\/\n    public static function pull(array &$array, string $key, $default = null)\n    {\n        $value = static::get($array, $key, $default);\n\n        static::forget($array, $key);\n\n        return $value;\n    }\n\n    \/**\n     * Convert the array into a query string.\n     *\/\n    public static function query(array $array): string\n    {\n        return http_build_query($array, '', '&', PHP_QUERY_RFC3986);\n    }\n\n    \/**\n     * Get one or a specified number of random values from an array.\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return mixed\n     *\/\n    public static function random(array $array, ?int $number = null)\n    {\n        $requested = null === $number ? 1 : $number;\n\n        $count = count($array);\n\n        if ($requested > $count) {\n            throw new InvalidArgumentException(\n                \"You requested {$requested} items, but there are only {$count} items available.\"\n            );\n        }\n\n        if (null === $number) {\n            return $array[array_rand($array)];\n        }\n\n        if ((int) $number === 0) {\n            return [];\n        }\n\n        $keys = array_rand($array, $number);\n\n        $results = [];\n\n        foreach ((array) $keys as $key) {\n            $results[] = $array[$key];\n        }\n\n        return $results;\n    }\n\n    \/**\n     * Remove data matching $path from the $data array.\n     * You can use `{n}` and `{s}` to remove multiple elements\n     * from $data.\n     *\n     * @param array  $data The data to operate on\n     * @param string $path A path expression to use to remove.\n     *\n     * @return array The modified array.\n     * @credit CakePHP - http:\/\/book.cakephp.org\/2.0\/en\/core-utility-libraries\/hash.html#Hash::remove\n     *\/\n    public static function remove(array $data, $path)\n    {\n        if (strpos($path, '[') === false) {\n            $tokens = explode('.', $path);\n        } else {\n            $tokens = Str::tokenize($path, '.', '[', ']');\n        }\n\n        if (strpos($path, '{') === false && strpos($path, '[') === false) {\n            return self::_simpleOp('remove', $data, $tokens);\n        }\n\n        $token    = array_shift($tokens);\n        $nextPath = implode('.', $tokens);\n\n        [$token, $conditions] = self::_splitConditions($token);\n\n        foreach ($data as $k => $v) {\n            $match = self::_matchToken($k, $token);\n            if ($match && is_array($v)) {\n                if ($conditions && self::_matches($v, $conditions)) {\n                    unset($data[$k]);\n\n                    continue;\n                }\n                $data[$k] = self::remove($v, $nextPath);\n                if (empty($data[$k])) {\n                    unset($data[$k]);\n                }\n            } elseif ($match) {\n                unset($data[$k]);\n            }\n        }\n\n        return $data;\n    }\n\n    \/**\n     * Set an array item to a given value using \"dot\" notation.\n     *\n     * If no key is given to the method, the entire array will be replaced.\n     *\n     * @param mixed $value\n     *\/\n    public static function set(array &$array, string $key, $value): array\n    {\n        if (null === $key) {\n            return $array = $value;\n        }\n\n        $keys = explode('.', $key);\n\n        while (count($keys) > 1) {\n            $key = array_shift($keys);\n\n            \/\/ If the key doesn't exist at this depth, we will just create an empty array\n            \/\/ to hold the next value, allowing us to create the arrays to hold final\n            \/\/ values at the correct depth. Then we'll keep digging into the array.\n            if (! isset($array[$key]) || ! is_array($array[$key])) {\n                $array[$key] = [];\n            }\n\n            $array = &$array[$key];\n        }\n\n        $array[array_shift($keys)] = $value;\n\n        return $array;\n    }\n\n    \/**\n     * @param mixed $value\n     *\n     * @return void\n     *\/\n    public static function setRecursive(array &$data, ?string $key = null, $value = null)\n    {\n        if (empty($data) && empty($key)) {\n            return;\n        }\n\n        $key   = explode('.', $key);\n        $count = count($key);\n\n        if ($count === 1) {\n            $data[$key[0]] = $value;\n\n            return;\n        }\n\n        $sub_key = $key[1];\n\n        for ($i = 2; $i < $count; $i++) {\n            $sub_key .= '.' . $key[$i];\n        }\n\n        if (! isset($data[$key[0]])) {\n            $data[$key[0]] = [];\n        }\n\n        self::setRecursive($data[$key[0]], $sub_key, $value);\n    }\n\n    \/**\n     * Shuffle the given array and return the result.\n     *\/\n    public static function shuffle(array $array, ?int $seed = null): array\n    {\n        if (null === $seed) {\n            shuffle($array);\n        } else {\n            mt_srand($seed);\n            shuffle($array);\n            mt_srand();\n        }\n\n        return $array;\n    }\n\n    \/**\n     * Sort the array using the given callback or \"dot\" notation.\n     *\n     * @param array                $array\n     * @param callable|string|null $callback\n     *\/\n    public static function sort($array, $callback = null): array\n    {\n        return Collection::make($array)->sortBy($callback)->all();\n    }\n\n    \/**\n     * Sort an array in ASC\/DESC order relativly to a specific position\n     *\n     * @param array  $data      Array to sort\n     * @param string $field     String to describe field position\n     * @param int    $direction Direction of sort based on class constants\n     *\n     * @return array Sorted array\n     *\/\n    public static function sortField(array $data, string $field, int $direction = self::SORT_ASC): array\n    {\n        usort($data, static function ($a, $b) use ($field, $direction) {\n            $cmp1 = self::_getSortField_($a, $field);\n            $cmp2 = self::_getSortField_($b, $field);\n\n            if ($cmp1 === $cmp2) {\n                return 0;\n            }\n            if ($direction === self::SORT_ASC) {\n                return ($cmp1 < $cmp2) ? -1 : 1;\n            }\n\n            return ($cmp1 < $cmp2) ? 1 : -1;\n        });\n\n        return $data;\n    }\n\n    private static function _getSortField_($element, $field)\n    {\n        $field = explode('.', $field);\n\n        foreach ($field as $key) {\n            if (is_object($element) && isset($element->{$key})) {\n                $element = $element->{$key};\n            } elseif (isset($element[$key])) {\n                $element = $element[$key];\n            } else {\n                break;\n            }\n        }\n\n        return $element;\n    }\n\n    \/**\n     * Recursively sort an array by keys and values.\n     *\/\n    public static function sortRecursive(array $array): array\n    {\n        foreach ($array as &$value) {\n            if (is_array($value)) {\n                $value = static::sortRecursive($value);\n            }\n        }\n\n        if (static::isAssoc($array)) {\n            ksort($array);\n        } else {\n            sort($array);\n        }\n\n        return $array;\n    }\n\n    \/**\n     * Filter the array using the given callback.\n     *\/\n    public static function where(array $array, callable $callback): array\n    {\n        return array_filter($array, $callback, ARRAY_FILTER_USE_BOTH);\n    }\n\n    \/**\n     * If the given value is not an array and not null, wrap it in one.\n     *\n     * @param mixed $value\n     *\/\n    public static function wrap($value): array\n    {\n        if (null === $value) {\n            return [];\n        }\n\n        return is_array($value) ? $value : [$value];\n    }\n\n    \/**\n     * Callback function for filtering.\n     *\n     * @param mixed $var Array to filter.\n     *\/\n    protected static function _filter($var): bool\n    {\n        return (bool) ($var === 0 || $var === '0' || ! empty($var));\n    }\n\n    \/**\n     * Split token conditions\n     *\n     * @param string $token the token being splitted.\n     *\n     * @return array array(token, conditions) with token splitted\n     *\/\n    protected static function _splitConditions(string $token): array\n    {\n        $conditions = false;\n        $position   = strpos($token, '[');\n        if ($position !== false) {\n            $conditions = substr($token, $position);\n            $token      = substr($token, 0, $position);\n        }\n\n        return [$token, $conditions];\n    }\n\n    \/**\n     * Check a key against a token.\n     *\n     * @param string $key   The key in the array being searched.\n     * @param string $token The token being matched.\n     *\/\n    protected static function _matchToken(string $key, string $token): bool\n    {\n        if ($token === '{n}') {\n            return is_numeric($key);\n        }\n        if ($token === '{s}') {\n            return is_string($key);\n        }\n        if (is_numeric($token)) {\n            return $key === $token;\n        }\n\n        return $key === $token;\n    }\n\n    \/**\n     * Checks whether or not $data matches the attribute patterns\n     *\n     * @param array  $data     Array of data to match.\n     * @param string $selector The patterns to match.\n     *\n     * @return bool Fitness of expression.\n     *\/\n    protected static function _matches(array $data, string $selector): bool\n    {\n        preg_match_all(\n            '\/(\\[ (?P<attr>[^=><!]+?) (\\s* (?P<op>[><!]?[=]|[><]) \\s* (?P<val>(?:\\\/.*?\\\/ | [^\\]]+)) )? \\])\/x',\n            $selector,\n            $conditions,\n            PREG_SET_ORDER\n        );\n\n        foreach ($conditions as $cond) {\n            $attr = $cond['attr'];\n            $op   = $cond['op'] ?? null;\n            $val  = $cond['val'] ?? null;\n\n            \/\/ Presence test.\n            if (empty($op) && empty($val) && ! isset($data[$attr])) {\n                return false;\n            }\n            \/\/ Empty attribute = fail.\n            if (! (isset($data[$attr]) || array_key_exists($attr, $data))) {\n                return false;\n            }\n            $prop = null;\n            if (isset($data[$attr])) {\n                $prop = $data[$attr];\n            }\n            $isBool = is_bool($prop);\n            if ($isBool && is_numeric($val)) {\n                $prop = $prop ? '1' : '0';\n            } elseif ($isBool) {\n                $prop = $prop ? 'true' : 'false';\n            }\n            \/\/ Pattern matches and other operators.\n            if ($op === '=' && $val && $val[0] === '\/') {\n                if (! preg_match($val, $prop)) {\n                    return false;\n                }\n            } elseif (\n                ($op === '=' && $prop !== $val)\n                || ($op === '!=' && $prop === $val)\n                || ($op === '>' && $prop <= $val)\n                || ($op === '<' && $prop >= $val)\n                || ($op === '>=' && $prop < $val)\n                || ($op === '<=' && $prop > $val)\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * Perform a simple insert\/remove operation.\n     *\n     * @param string $op     The operation to do.\n     * @param array  $data   The data to operate on.\n     * @param array  $path   The path to work on.\n     * @param mixed  $values The values to insert when doing inserts.\n     *\n     * @return array|void data.\n     *\/\n    protected static function _simpleOp(string $op, array $data, array $path, $values = null)\n    {\n        $_list = &$data;\n\n        $count = count($path);\n        $last  = $count - 1;\n\n        foreach ($path as $i => $key) {\n            if (is_numeric($key) && (int) $key > 0 || $key === '0') {\n                $key = (int) $key;\n            }\n            if ($op === 'insert') {\n                if ($i === $last) {\n                    $_list[$key] = $values;\n\n                    return $data;\n                }\n                if (! isset($_list[$key])) {\n                    $_list[$key] = [];\n                }\n                $_list = &$_list[$key];\n                if (! is_array($_list)) {\n                    $_list = [];\n                }\n            } elseif ($op === 'remove') {\n                if ($i === $last) {\n                    unset($_list[$key]);\n\n                    return $data;\n                }\n                if (! isset($_list[$key])) {\n                    return $data;\n                }\n                $_list = &$_list[$key];\n            }\n        }\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,0,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,0,null,0,null,null,0,null,null,null,0,0,null,0,null,null,0,null,null,null,0,null,null,null,0,null,0,null,0,null,0,null,null,0,null,0,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,0,0,null,null,0,0,null,null,0,null,null,0,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,0,null,null,0,null,null,null,0,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,null,null,null,0,0,null,0,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,0,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,0,null,0,null,null,0,null,0,null,null,0,null,0,null,null,null,null,0,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,0,0,0,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,0,null,null,0,0,0,null,null,null,0,null,0,0,0,null,0,null,null,null,0,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,0,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,null,null,0,0,null,0,0,0,null,0,null,0,0,null,0,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,null,null,null,0,null,0,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,0,null,null,0,null,null,0,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,0,null,null,0,null,null,null,null,0,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,0,0,null,0,null,null,null,null,0,null,0,null,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,0,null,0,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,0,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,null,0,0,null,0,null,null,0,null,null,0,null,0,null,0,null,0,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,0,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,0,null,null,0,null,0,null,null,0,null,0,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,0,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,0,null,null,0,null,null,0,0,null,0,null,null,null,null,0,null,null,null,0,null,0,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,0,0,null,null,null,0,null,null,null,0,null,0,null,0,null,0,null,0,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,null,null,null,0,null,null,null,0,null,0,null,null,0,null,0,null,0,null,null,null,0,null,0,null,null,0,null,0,null,null,null,null,null]},{"name":"src\\Utilities\\Collection.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Utilities;\n\nuse ArrayAccess;\nuse ArrayIterator;\nuse BlitzPHP\\Contracts\\Support\\Arrayable;\nuse BlitzPHP\\Contracts\\Support\\Jsonable;\nuse BlitzPHP\\Traits\\Macroable;\nuse CachingIterator;\nuse Closure;\nuse Countable;\nuse Exception;\nuse InvalidArgumentException;\nuse IteratorAggregate;\nuse JsonSerializable;\nuse stdClass;\nuse Traversable;\n\n\/** @phpstan-consistent-constructor *\/\nclass Collection implements ArrayAccess, Arrayable, Countable, IteratorAggregate, Jsonable, JsonSerializable\n{\n    use Macroable;\n\n    \/**\n     * The items contained in the collection.\n     *\n     * @var array\n     *\/\n    protected $items = [];\n\n    \/**\n     * The methods that can be proxied.\n     *\n     * @var array\n     *\/\n    protected static $proxies = [\n        'average', 'avg', 'contains', 'each', 'every', 'filter', 'first',\n        'flatMap', 'groupBy', 'keyBy', 'map', 'max', 'min', 'partition',\n        'reject', 'some', 'sortBy', 'sortByDesc', 'sum', 'unique',\n    ];\n\n    \/**\n     * Create a new collection.\n     *\n     * @param mixed $items\n     *\n     * @return void\n     *\/\n    public function __construct($items = [])\n    {\n        $this->items = $this->getArrayableItems($items);\n    }\n\n    \/**\n     * Create a new collection instance if the value isn't one already.\n     *\n     * @param mixed $items\n     *\n     * @return static\n     *\/\n    public static function make($items = [])\n    {\n        return new static($items);\n    }\n\n    \/**\n     * Wrap the given value in a collection if applicable.\n     *\n     * @param mixed $value\n     *\n     * @return static\n     *\/\n    public static function wrap($value)\n    {\n        return $value instanceof self\n            ? new static($value)\n            : new static(Arr::wrap($value));\n    }\n\n    \/**\n     * Get the underlying items from the given collection if applicable.\n     *\n     * @param array|static $value\n     *\n     * @return array\n     *\/\n    public static function unwrap($value)\n    {\n        return $value instanceof self ? $value->all() : $value;\n    }\n\n    \/**\n     * Create a new collection by invoking the callback a given amount of times.\n     *\n     * @param int      $number\n     * @param callable $callback\n     *\n     * @return static\n     *\/\n    public static function times($number, ?callable $callback = null)\n    {\n        if ($number < 1) {\n            return new static();\n        }\n\n        if (null === $callback) {\n            return new static(range(1, $number));\n        }\n\n        return (new static(range(1, $number)))->map($callback);\n    }\n\n    \/**\n     * Get all of the items in the collection.\n     *\n     * @return array\n     *\/\n    public function all()\n    {\n        return $this->items;\n    }\n\n    \/**\n     * Get the average value of a given key.\n     *\n     * @param callable|string|null $callback\n     *\n     * @return mixed\n     *\/\n    public function avg($callback = null)\n    {\n        $callback = $this->valueRetriever($callback);\n\n        $items = $this->map(static fn ($value) => $callback($value))->filter(static fn ($value) => null !== $value);\n\n        if ($count = $items->count()) {\n            return $items->sum() \/ $count;\n        }\n    }\n\n    \/**\n     * Alias for the \"avg\" method.\n     *\n     * @param callable|string|null $callback\n     *\n     * @return mixed\n     *\/\n    public function average($callback = null)\n    {\n        return $this->avg($callback);\n    }\n\n    \/**\n     * Get the median of a given key.\n     *\n     * @param array|string|null $key\n     *\n     * @return mixed\n     *\/\n    public function median($key = null)\n    {\n        $values = (isset($key) ? $this->pluck($key) : $this)\n            ->filter(static fn ($item) => null !== $item)->sort()->values();\n\n        $count = $values->count();\n\n        if ($count === 0) {\n            return;\n        }\n\n        $middle = (int) ($count \/ 2);\n\n        if ($count % 2) {\n            return $values->get($middle);\n        }\n\n        return (new static([\n            $values->get($middle - 1), $values->get($middle),\n        ]))->average();\n    }\n\n    \/**\n     * Get the mode of a given key.\n     *\n     * @param array|string|null $key\n     *\n     * @return array|null\n     *\/\n    public function mode($key = null)\n    {\n        if ($this->count() === 0) {\n            return;\n        }\n\n        $collection = isset($key) ? $this->pluck($key) : $this;\n\n        $counts = new self();\n\n        $collection->each(static function ($value) use ($counts) {\n            $counts[$value] = isset($counts[$value]) ? $counts[$value] + 1 : 1;\n        });\n\n        $sorted = $counts->sort();\n\n        $highestValue = $sorted->last();\n\n        return $sorted->filter(static fn ($value) => $value === $highestValue)->sort()->keys()->all();\n    }\n\n    \/**\n     * Collapse the collection of items into a single array.\n     *\n     * @return static\n     *\/\n    public function collapse()\n    {\n        return new static(Arr::collapse($this->items));\n    }\n\n    \/**\n     * Alias for the \"contains\" method.\n     *\n     * @param mixed $key\n     * @param mixed $operator\n     * @param mixed $value\n     *\n     * @return bool\n     *\/\n    public function some($key, $operator = null, $value = null)\n    {\n        return $this->contains(...func_get_args());\n    }\n\n    \/**\n     * Determine if an item exists in the collection.\n     *\n     * @param mixed $key\n     * @param mixed $operator\n     * @param mixed $value\n     *\n     * @return bool\n     *\/\n    public function contains($key, $operator = null, $value = null)\n    {\n        if (func_num_args() === 1) {\n            if ($this->useAsCallable($key)) {\n                $placeholder = new stdClass();\n\n                return $this->first($key, $placeholder) !== $placeholder;\n            }\n\n            return in_array($key, $this->items, true);\n        }\n\n        return $this->contains($this->operatorForWhere(...func_get_args()));\n    }\n\n    \/**\n     * Determine if an item exists in the collection using strict comparison.\n     *\n     * @param mixed $key\n     * @param mixed $value\n     *\n     * @return bool\n     *\/\n    public function containsStrict($key, $value = null)\n    {\n        if (func_num_args() === 2) {\n            return $this->contains(static fn ($item) => Arr::get($item, $key) === $value);\n        }\n\n        if ($this->useAsCallable($key)) {\n            return null !== $this->first($key);\n        }\n\n        return in_array($key, $this->items, true);\n    }\n\n    \/**\n     * Cross join with the given lists, returning all possible permutations.\n     *\n     * @param mixed ...$lists\n     *\n     * @return static\n     *\/\n    public function crossJoin(...$lists)\n    {\n        return new static(Arr::crossJoin(\n            $this->items,\n            ...array_map([$this, 'getArrayableItems'], $lists)\n        ));\n    }\n\n    \/**\n     * Dump the collection and end the script.\n     *\n     * @param mixed ...$args\n     *\n     * @return void\n     *\/\n    public function dd(...$args)\n    {\n        call_user_func_array([$this, 'dump'], $args);\n\n        exit(1);\n    }\n\n    \/**\n     * Dump the collection.\n     *\n     * @return $this\n     *\/\n    public function dump()\n    {\n        (new static(func_get_args()))\n            ->push($this)\n            ->each(static function ($item) {\n                Helpers::r($item);\n            });\n\n        return $this;\n    }\n\n    \/**\n     * Get the items in the collection that are not present in the given items.\n     *\n     * @param mixed $items\n     *\n     * @return static\n     *\/\n    public function diff($items)\n    {\n        return new static(array_diff($this->items, $this->getArrayableItems($items)));\n    }\n\n    \/**\n     * Get the items in the collection that are not present in the given items.\n     *\n     * @param mixed $items\n     *\n     * @return static\n     *\/\n    public function diffUsing($items, callable $callback)\n    {\n        return new static(array_udiff($this->items, $this->getArrayableItems($items), $callback));\n    }\n\n    \/**\n     * Get the items in the collection whose keys and values are not present in the given items.\n     *\n     * @param mixed $items\n     *\n     * @return static\n     *\/\n    public function diffAssoc($items)\n    {\n        return new static(array_diff_assoc($this->items, $this->getArrayableItems($items)));\n    }\n\n    \/**\n     * Get the items in the collection whose keys and values are not present in the given items.\n     *\n     * @param mixed $items\n     *\n     * @return static\n     *\/\n    public function diffAssocUsing($items, callable $callback)\n    {\n        return new static(array_diff_uassoc($this->items, $this->getArrayableItems($items), $callback));\n    }\n\n    \/**\n     * Get the items in the collection whose keys are not present in the given items.\n     *\n     * @param mixed $items\n     *\n     * @return static\n     *\/\n    public function diffKeys($items)\n    {\n        return new static(array_diff_key($this->items, $this->getArrayableItems($items)));\n    }\n\n    \/**\n     * Get the items in the collection whose keys are not present in the given items.\n     *\n     * @param mixed $items\n     *\n     * @return static\n     *\/\n    public function diffKeysUsing($items, callable $callback)\n    {\n        return new static(array_diff_ukey($this->items, $this->getArrayableItems($items), $callback));\n    }\n\n    \/**\n     * Retrieve duplicate items from the collection.\n     *\n     * @param callable|null $callback\n     * @param bool          $strict\n     *\n     * @return static\n     *\/\n    public function duplicates($callback = null, $strict = false)\n    {\n        $items = $this->map($this->valueRetriever($callback));\n\n        $uniqueItems = $items->unique(null, $strict);\n\n        $compare = $this->duplicateComparator($strict);\n\n        $duplicates = new static();\n\n        foreach ($items as $key => $value) {\n            if ($uniqueItems->isNotEmpty() && $compare($value, $uniqueItems->first())) {\n                $uniqueItems->shift();\n            } else {\n                $duplicates[$key] = $value;\n            }\n        }\n\n        return $duplicates;\n    }\n\n    \/**\n     * Retrieve duplicate items from the collection using strict comparison.\n     *\n     * @param callable|null $callback\n     *\n     * @return static\n     *\/\n    public function duplicatesStrict($callback = null)\n    {\n        return $this->duplicates($callback, true);\n    }\n\n    \/**\n     * Get the comparison function to detect duplicates.\n     *\n     * @param bool $strict\n     *\n     * @return Closure\n     *\/\n    protected function duplicateComparator($strict)\n    {\n        if ($strict) {\n            return static fn ($a, $b) => $a === $b;\n        }\n\n        return static fn ($a, $b) => $a === $b;\n    }\n\n    \/**\n     * Execute a callback over each item.\n     *\n     * @return $this\n     *\/\n    public function each(callable $callback)\n    {\n        foreach ($this->items as $key => $item) {\n            if ($callback($item, $key) === false) {\n                break;\n            }\n        }\n\n        return $this;\n    }\n\n    \/**\n     * Execute a callback over each nested chunk of items.\n     *\n     * @return static\n     *\/\n    public function eachSpread(callable $callback)\n    {\n        return $this->each(static function ($chunk, $key) use ($callback) {\n            $chunk[] = $key;\n\n            return $callback(...$chunk);\n        });\n    }\n\n    \/**\n     * Determine if all items in the collection pass the given test.\n     *\n     * @param callable|string $key\n     * @param mixed           $operator\n     * @param mixed           $value\n     *\n     * @return bool\n     *\/\n    public function every($key, $operator = null, $value = null)\n    {\n        if (func_num_args() === 1) {\n            $callback = $this->valueRetriever($key);\n\n            foreach ($this->items as $k => $v) {\n                if (! $callback($v, $k)) {\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        return $this->every($this->operatorForWhere(...func_get_args()));\n    }\n\n    \/**\n     * Get all items except for those with the specified keys.\n     *\n     * @param mixed $keys\n     *\n     * @return static\n     *\/\n    public function except($keys)\n    {\n        if ($keys instanceof self) {\n            $keys = $keys->all();\n        } elseif (! is_array($keys)) {\n            $keys = func_get_args();\n        }\n\n        return new static(Arr::except($this->items, $keys));\n    }\n\n    \/**\n     * Run a filter over each of the items.\n     *\n     * @return static\n     *\/\n    public function filter(?callable $callback = null)\n    {\n        if ($callback) {\n            return new static(Arr::where($this->items, $callback));\n        }\n\n        return new static(array_filter($this->items));\n    }\n\n    \/**\n     * Apply the callback if the value is truthy.\n     *\n     * @param bool     $value\n     * @param callable $default\n     *\n     * @return mixed|static\n     *\/\n    public function when($value, callable $callback, ?callable $default = null)\n    {\n        if ($value) {\n            return $callback($this, $value);\n        }\n        if ($default) {\n            return $default($this, $value);\n        }\n\n        return $this;\n    }\n\n    \/**\n     * Apply the callback if the collection is empty.\n     *\n     * @param callable $default\n     *\n     * @return mixed|static\n     *\/\n    public function whenEmpty(callable $callback, ?callable $default = null)\n    {\n        return $this->when($this->isEmpty(), $callback, $default);\n    }\n\n    \/**\n     * Apply the callback if the collection is not empty.\n     *\n     * @param callable $default\n     *\n     * @return mixed|static\n     *\/\n    public function whenNotEmpty(callable $callback, ?callable $default = null)\n    {\n        return $this->when($this->isNotEmpty(), $callback, $default);\n    }\n\n    \/**\n     * Apply the callback if the value is falsy.\n     *\n     * @param bool     $value\n     * @param callable $default\n     *\n     * @return mixed|static\n     *\/\n    public function unless($value, callable $callback, ?callable $default = null)\n    {\n        return $this->when(! $value, $callback, $default);\n    }\n\n    \/**\n     * Apply the callback unless the collection is empty.\n     *\n     * @param callable $default\n     *\n     * @return mixed|static\n     *\/\n    public function unlessEmpty(callable $callback, ?callable $default = null)\n    {\n        return $this->whenNotEmpty($callback, $default);\n    }\n\n    \/**\n     * Apply the callback unless the collection is not empty.\n     *\n     * @param callable $default\n     *\n     * @return mixed|static\n     *\/\n    public function unlessNotEmpty(callable $callback, ?callable $default = null)\n    {\n        return $this->whenEmpty($callback, $default);\n    }\n\n    \/**\n     * Filter items by the given key value pair.\n     *\n     * @param string $key\n     * @param mixed  $operator\n     * @param mixed  $value\n     *\n     * @return static\n     *\/\n    public function where($key, $operator = null, $value = null)\n    {\n        return $this->filter($this->operatorForWhere(...func_get_args()));\n    }\n\n    \/**\n     * Get an operator checker callback.\n     *\n     * @param string $key\n     * @param string $operator\n     * @param mixed  $value\n     *\n     * @return Closure\n     *\/\n    protected function operatorForWhere($key, $operator = null, $value = null)\n    {\n        if (func_num_args() === 1) {\n            $value = true;\n\n            $operator = '=';\n        }\n\n        if (func_num_args() === 2) {\n            $value = $operator;\n\n            $operator = '=';\n        }\n\n        return static function ($item) use ($key, $operator, $value) {\n            $retrieved = Arr::get($item, $key);\n\n            $strings = array_filter([$retrieved, $value], static fn ($value) => is_string($value) || (is_object($value) && method_exists($value, '__toString')));\n\n            if (count($strings) < 2 && count(array_filter([$retrieved, $value], 'is_object')) === 1) {\n                return in_array($operator, ['!=', '<>', '!=='], true);\n            }\n\n            switch ($operator) {\n                default:\n                case '=':\n                case '==':  return $retrieved === $value;\n\n                case '!=':\n                case '<>':  return $retrieved !== $value;\n\n                case '<':   return $retrieved < $value;\n\n                case '>':   return $retrieved > $value;\n\n                case '<=':  return $retrieved <= $value;\n\n                case '>=':  return $retrieved >= $value;\n\n                case '===': return $retrieved === $value;\n\n                case '!==': return $retrieved !== $value;\n            }\n        };\n    }\n\n    \/**\n     * Filter items by the given key value pair using strict comparison.\n     *\n     * @param string $key\n     * @param mixed  $value\n     *\n     * @return static\n     *\/\n    public function whereStrict($key, $value)\n    {\n        return $this->where($key, '===', $value);\n    }\n\n    \/**\n     * Filter items by the given key value pair.\n     *\n     * @param string $key\n     * @param mixed  $values\n     * @param bool   $strict\n     *\n     * @return static\n     *\/\n    public function whereIn($key, $values, $strict = false)\n    {\n        $values = $this->getArrayableItems($values);\n\n        return $this->filter(static fn ($item) => in_array(Arr::get($item, $key), $values, $strict));\n    }\n\n    \/**\n     * Filter items by the given key value pair using strict comparison.\n     *\n     * @param string $key\n     * @param mixed  $values\n     *\n     * @return static\n     *\/\n    public function whereInStrict($key, $values)\n    {\n        return $this->whereIn($key, $values, true);\n    }\n\n    \/**\n     * Filter items such that the value of the given key is between the given values.\n     *\n     * @param string $key\n     * @param array  $values\n     *\n     * @return static\n     *\/\n    public function whereBetween($key, $values)\n    {\n        return $this->where($key, '>=', reset($values))->where($key, '<=', end($values));\n    }\n\n    \/**\n     * Filter items such that the value of the given key is not between the given values.\n     *\n     * @param string $key\n     * @param array  $values\n     *\n     * @return static\n     *\/\n    public function whereNotBetween($key, $values)\n    {\n        return $this->filter(static fn ($item) => Arr::get($item, $key) < reset($values) || Arr::get($item, $key) > end($values));\n    }\n\n    \/**\n     * Filter items by the given key value pair.\n     *\n     * @param string $key\n     * @param mixed  $values\n     * @param bool   $strict\n     *\n     * @return static\n     *\/\n    public function whereNotIn($key, $values, $strict = false)\n    {\n        $values = $this->getArrayableItems($values);\n\n        return $this->reject(static fn ($item) => in_array(Arr::get($item, $key), $values, $strict));\n    }\n\n    \/**\n     * Filter items by the given key value pair using strict comparison.\n     *\n     * @param string $key\n     * @param mixed  $values\n     *\n     * @return static\n     *\/\n    public function whereNotInStrict($key, $values)\n    {\n        return $this->whereNotIn($key, $values, true);\n    }\n\n    \/**\n     * Filter the items, removing any items that don't match the given type.\n     *\n     * @param string $type\n     *\n     * @return static\n     *\/\n    public function whereInstanceOf($type)\n    {\n        return $this->filter(static fn ($value) => $value instanceof $type);\n    }\n\n    \/**\n     * Get the first item from the collection passing the given truth test.\n     *\n     * @param mixed $default\n     *\n     * @return mixed\n     *\/\n    public function first(?callable $callback = null, $default = null)\n    {\n        return Arr::first($this->items, $callback, $default);\n    }\n\n    \/**\n     * Get the first item by the given key value pair.\n     *\n     * @param string $key\n     * @param mixed  $operator\n     * @param mixed  $value\n     *\n     * @return mixed\n     *\/\n    public function firstWhere($key, $operator = null, $value = null)\n    {\n        return $this->first($this->operatorForWhere(...func_get_args()));\n    }\n\n    \/**\n     * Get a flattened array of the items in the collection.\n     *\n     * @param int $depth\n     *\n     * @return static\n     *\/\n    public function flatten($depth = INF)\n    {\n        return new static(Arr::flatten($this->items, $depth));\n    }\n\n    \/**\n     * Flip the items in the collection.\n     *\n     * @return static\n     *\/\n    public function flip()\n    {\n        return new static(array_flip($this->items));\n    }\n\n    \/**\n     * Remove an item from the collection by key.\n     *\n     * @param array|string $keys\n     *\n     * @return $this\n     *\/\n    public function forget($keys)\n    {\n        foreach ((array) $keys as $key) {\n            $this->offsetUnset($key);\n        }\n\n        return $this;\n    }\n\n    \/**\n     * Get an item from the collection by key.\n     *\n     * @param mixed $key\n     * @param mixed $default\n     *\n     * @return mixed\n     *\/\n    public function get($key, $default = null)\n    {\n        if ($this->offsetExists($key)) {\n            return $this->items[$key];\n        }\n\n        return $default;\n    }\n\n    \/**\n     * Group an associative array by a field or using a callback.\n     *\n     * @param array|callable|string $groupBy\n     * @param bool                  $preserveKeys\n     *\n     * @return static\n     *\/\n    public function groupBy($groupBy, $preserveKeys = false)\n    {\n        if (is_array($groupBy)) {\n            $nextGroups = $groupBy;\n\n            $groupBy = array_shift($nextGroups);\n        }\n\n        $groupBy = $this->valueRetriever($groupBy);\n\n        $results = [];\n\n        foreach ($this->items as $key => $value) {\n            $groupKeys = $groupBy($value, $key);\n\n            if (! is_array($groupKeys)) {\n                $groupKeys = [$groupKeys];\n            }\n\n            foreach ($groupKeys as $groupKey) {\n                $groupKey = is_bool($groupKey) ? (int) $groupKey : $groupKey;\n\n                if (! array_key_exists($groupKey, $results)) {\n                    $results[$groupKey] = new static();\n                }\n\n                $results[$groupKey]->offsetSet($preserveKeys ? $key : null, $value);\n            }\n        }\n\n        $result = new static($results);\n\n        if (! empty($nextGroups)) {\n            return $result->map->groupBy($nextGroups, $preserveKeys);\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Key an associative array by a field or using a callback.\n     *\n     * @param callable|string $keyBy\n     *\n     * @return static\n     *\/\n    public function keyBy($keyBy)\n    {\n        $keyBy = $this->valueRetriever($keyBy);\n\n        $results = [];\n\n        foreach ($this->items as $key => $item) {\n            $resolvedKey = $keyBy($item, $key);\n\n            if (is_object($resolvedKey)) {\n                $resolvedKey = (string) $resolvedKey;\n            }\n\n            $results[$resolvedKey] = $item;\n        }\n\n        return new static($results);\n    }\n\n    \/**\n     * Determine if an item exists in the collection by key.\n     *\n     * @param mixed $key\n     *\n     * @return bool\n     *\/\n    public function has($key)\n    {\n        $keys = is_array($key) ? $key : func_get_args();\n\n        foreach ($keys as $value) {\n            if (! $this->offsetExists($value)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * Concatenate values of a given key as a string.\n     *\n     * @param string $value\n     * @param string $glue\n     *\n     * @return string\n     *\/\n    public function implode($value, $glue = null)\n    {\n        $first = $this->first();\n\n        if (is_array($first) || is_object($first)) {\n            return implode($glue, $this->pluck($value)->all());\n        }\n\n        return implode($value, $this->items);\n    }\n\n    \/**\n     * Intersect the collection with the given items.\n     *\n     * @param mixed $items\n     *\n     * @return static\n     *\/\n    public function intersect($items)\n    {\n        return new static(array_intersect($this->items, $this->getArrayableItems($items)));\n    }\n\n    \/**\n     * Intersect the collection with the given items by key.\n     *\n     * @param mixed $items\n     *\n     * @return static\n     *\/\n    public function intersectByKeys($items)\n    {\n        return new static(array_intersect_key(\n            $this->items,\n            $this->getArrayableItems($items)\n        ));\n    }\n\n    \/**\n     * Determine if the collection is empty or not.\n     *\n     * @return bool\n     *\/\n    public function isEmpty()\n    {\n        return empty($this->items);\n    }\n\n    \/**\n     * Determine if the collection is not empty.\n     *\n     * @return bool\n     *\/\n    public function isNotEmpty()\n    {\n        return ! $this->isEmpty();\n    }\n\n    \/**\n     * Determine if the given value is callable, but not a string.\n     *\n     * @param mixed $value\n     *\n     * @return bool\n     *\/\n    protected function useAsCallable($value)\n    {\n        return ! is_string($value) && is_callable($value);\n    }\n\n    \/**\n     * Join all items from the collection using a string. The final items can use a separate glue string.\n     *\n     * @param string $glue\n     * @param string $finalGlue\n     *\n     * @return string\n     *\/\n    public function join($glue, $finalGlue = '')\n    {\n        if ($finalGlue === '') {\n            return $this->implode($glue);\n        }\n\n        $count = $this->count();\n\n        if ($count === 0) {\n            return '';\n        }\n\n        if ($count === 1) {\n            return $this->last();\n        }\n\n        $collection = new static($this->items);\n\n        $finalItem = $collection->pop();\n\n        return $collection->implode($glue) . $finalGlue . $finalItem;\n    }\n\n    \/**\n     * Get the keys of the collection items.\n     *\n     * @return static\n     *\/\n    public function keys()\n    {\n        return new static(array_keys($this->items));\n    }\n\n    \/**\n     * Get the last item from the collection.\n     *\n     * @param mixed $default\n     *\n     * @return mixed\n     *\/\n    public function last(?callable $callback = null, $default = null)\n    {\n        return Arr::last($this->items, $callback, $default);\n    }\n\n    \/**\n     * Get the values of a given key.\n     *\n     * @param array|string $value\n     * @param string|null  $key\n     *\n     * @return static\n     *\/\n    public function pluck($value, $key = null)\n    {\n        return new static(Arr::pluck($this->items, $value, $key));\n    }\n\n    \/**\n     * Run a map over each of the items.\n     *\n     * @return static\n     *\/\n    public function map(callable $callback)\n    {\n        $keys = array_keys($this->items);\n\n        $items = array_map($callback, $this->items, $keys);\n\n        return new static(array_combine($keys, $items));\n    }\n\n    \/**\n     * Run a map over each nested chunk of items.\n     *\n     * @return static\n     *\/\n    public function mapSpread(callable $callback)\n    {\n        return $this->map(static function ($chunk, $key) use ($callback) {\n            $chunk[] = $key;\n\n            return $callback(...$chunk);\n        });\n    }\n\n    \/**\n     * Run a dictionary map over the items.\n     *\n     * The callback should return an associative array with a single key\/value pair.\n     *\n     * @return static\n     *\/\n    public function mapToDictionary(callable $callback)\n    {\n        $dictionary = [];\n\n        foreach ($this->items as $key => $item) {\n            $pair = $callback($item, $key);\n\n            $key = key($pair);\n\n            $value = reset($pair);\n\n            if (! isset($dictionary[$key])) {\n                $dictionary[$key] = [];\n            }\n\n            $dictionary[$key][] = $value;\n        }\n\n        return new static($dictionary);\n    }\n\n    \/**\n     * Run a grouping map over the items.\n     *\n     * The callback should return an associative array with a single key\/value pair.\n     *\n     * @return static\n     *\/\n    public function mapToGroups(callable $callback)\n    {\n        $groups = $this->mapToDictionary($callback);\n\n        return $groups->map([$this, 'make']);\n    }\n\n    \/**\n     * Run an associative map over each of the items.\n     *\n     * The callback should return an associative array with a single key\/value pair.\n     *\n     * @return static\n     *\/\n    public function mapWithKeys(callable $callback)\n    {\n        $result = [];\n\n        foreach ($this->items as $key => $value) {\n            $assoc = $callback($value, $key);\n\n            foreach ($assoc as $mapKey => $mapValue) {\n                $result[$mapKey] = $mapValue;\n            }\n        }\n\n        return new static($result);\n    }\n\n    \/**\n     * Map a collection and flatten the result by a single level.\n     *\n     * @return static\n     *\/\n    public function flatMap(callable $callback)\n    {\n        return $this->map($callback)->collapse();\n    }\n\n    \/**\n     * Map the values into a new class.\n     *\n     * @param string $class\n     *\n     * @return static\n     *\/\n    public function mapInto($class)\n    {\n        return $this->map(static fn ($value, $key) => new $class($value, $key));\n    }\n\n    \/**\n     * Get the max value of a given key.\n     *\n     * @param callable|string|null $callback\n     *\n     * @return mixed\n     *\/\n    public function max($callback = null)\n    {\n        $callback = $this->valueRetriever($callback);\n\n        return $this->filter(static fn ($value) => null !== $value)->reduce(static function ($result, $item) use ($callback) {\n            $value = $callback($item);\n\n            return null === $result || $value > $result ? $value : $result;\n        });\n    }\n\n    \/**\n     * Merge the collection with the given items.\n     *\n     * @param mixed $items\n     *\n     * @return static\n     *\/\n    public function merge($items)\n    {\n        return new static(array_merge($this->items, $this->getArrayableItems($items)));\n    }\n\n    \/**\n     * Recursively merge the collection with the given items.\n     *\n     * @param mixed $items\n     *\n     * @return static\n     *\/\n    public function mergeRecursive($items)\n    {\n        return new static(array_merge_recursive($this->items, $this->getArrayableItems($items)));\n    }\n\n    \/**\n     * Create a collection by using this collection for keys and another for its values.\n     *\n     * @param mixed $values\n     *\n     * @return static\n     *\/\n    public function combine($values)\n    {\n        return new static(array_combine($this->all(), $this->getArrayableItems($values)));\n    }\n\n    \/**\n     * Union the collection with the given items.\n     *\n     * @param mixed $items\n     *\n     * @return static\n     *\/\n    public function union($items)\n    {\n        return new static($this->items + $this->getArrayableItems($items));\n    }\n\n    \/**\n     * Get the min value of a given key.\n     *\n     * @param callable|string|null $callback\n     *\n     * @return mixed\n     *\/\n    public function min($callback = null)\n    {\n        $callback = $this->valueRetriever($callback);\n\n        return $this->map(static fn ($value) => $callback($value))->filter(static fn ($value) => null !== $value)->reduce(static fn ($result, $value) => null === $result || $value < $result ? $value : $result);\n    }\n\n    \/**\n     * Create a new collection consisting of every n-th element.\n     *\n     * @param int $step\n     * @param int $offset\n     *\n     * @return static\n     *\/\n    public function nth($step, $offset = 0)\n    {\n        $new = [];\n\n        $position = 0;\n\n        foreach ($this->items as $item) {\n            if ($position % $step === $offset) {\n                $new[] = $item;\n            }\n\n            $position++;\n        }\n\n        return new static($new);\n    }\n\n    \/**\n     * Get the items with the specified keys.\n     *\n     * @param mixed $keys\n     *\n     * @return static\n     *\/\n    public function only($keys)\n    {\n        if (null === $keys) {\n            return new static($this->items);\n        }\n\n        if ($keys instanceof self) {\n            $keys = $keys->all();\n        }\n\n        $keys = is_array($keys) ? $keys : func_get_args();\n\n        return new static(Arr::only($this->items, $keys));\n    }\n\n    \/**\n     * \"Paginate\" the collection by slicing it into a smaller collection.\n     *\n     * @param int $page\n     * @param int $perPage\n     *\n     * @return static\n     *\/\n    public function forPage($page, $perPage)\n    {\n        $offset = max(0, ($page - 1) * $perPage);\n\n        return $this->slice($offset, $perPage);\n    }\n\n    \/**\n     * Partition the collection into two arrays using the given callback or key.\n     *\n     * @param callable|string $key\n     * @param mixed           $operator\n     * @param mixed           $value\n     *\n     * @return static\n     *\/\n    public function partition($key, $operator = null, $value = null)\n    {\n        $partitions = [new static(), new static()];\n\n        $callback = func_num_args() === 1\n                ? $this->valueRetriever($key)\n                : $this->operatorForWhere(...func_get_args());\n\n        foreach ($this->items as $key => $item) {\n            $partitions[(int) ! $callback($item, $key)][$key] = $item;\n        }\n\n        return new static($partitions);\n    }\n\n    \/**\n     * Pass the collection to the given callback and return the result.\n     *\n     * @return mixed\n     *\/\n    public function pipe(callable $callback)\n    {\n        return $callback($this);\n    }\n\n    \/**\n     * Get and remove the last item from the collection.\n     *\n     * @return mixed\n     *\/\n    public function pop()\n    {\n        return array_pop($this->items);\n    }\n\n    \/**\n     * Push an item onto the beginning of the collection.\n     *\n     * @param mixed $value\n     * @param mixed $key\n     *\n     * @return $this\n     *\/\n    public function prepend($value, $key = null)\n    {\n        $this->items = Arr::prepend($this->items, $value, $key);\n\n        return $this;\n    }\n\n    \/**\n     * Push an item onto the end of the collection.\n     *\n     * @param mixed $value\n     *\n     * @return $this\n     *\/\n    public function push($value)\n    {\n        $this->offsetSet(null, $value);\n\n        return $this;\n    }\n\n    \/**\n     * Push all of the given items onto the collection.\n     *\n     * @param iterable $source\n     *\n     * @return static\n     *\/\n    public function concat($source)\n    {\n        $result = new static($this);\n\n        foreach ($source as $item) {\n            $result->push($item);\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Get and remove an item from the collection.\n     *\n     * @param mixed $key\n     * @param mixed $default\n     *\n     * @return mixed\n     *\/\n    public function pull($key, $default = null)\n    {\n        return Arr::pull($this->items, $key, $default);\n    }\n\n    \/**\n     * Put an item in the collection by key.\n     *\n     * @param mixed $key\n     * @param mixed $value\n     *\n     * @return $this\n     *\/\n    public function put($key, $value)\n    {\n        $this->offsetSet($key, $value);\n\n        return $this;\n    }\n\n    \/**\n     * Get one or a specified number of items randomly from the collection.\n     *\n     * @param int|null $number\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return mixed|static\n     *\/\n    public function random($number = null)\n    {\n        if (null === $number) {\n            return Arr::random($this->items);\n        }\n\n        return new static(Arr::random($this->items, $number));\n    }\n\n    \/**\n     * Reduce the collection to a single value.\n     *\n     * @param mixed $initial\n     *\n     * @return mixed\n     *\/\n    public function reduce(callable $callback, $initial = null)\n    {\n        return array_reduce($this->items, $callback, $initial);\n    }\n\n    \/**\n     * Create a collection of all elements that do not pass a given truth test.\n     *\n     * @param callable|mixed $callback\n     *\n     * @return static\n     *\/\n    public function reject($callback = true)\n    {\n        $useAsCallable = $this->useAsCallable($callback);\n\n        return $this->filter(static function ($value, $key) use ($callback, $useAsCallable) {\n            return $useAsCallable\n                ? ! $callback($value, $key)\n                : $value !== $callback;\n        });\n    }\n\n    \/**\n     * Replace the collection items with the given items.\n     *\n     * @param mixed $items\n     *\n     * @return static\n     *\/\n    public function replace($items)\n    {\n        return new static(array_replace($this->items, $this->getArrayableItems($items)));\n    }\n\n    \/**\n     * Recursively replace the collection items with the given items.\n     *\n     * @param mixed $items\n     *\n     * @return static\n     *\/\n    public function replaceRecursive($items)\n    {\n        return new static(array_replace_recursive($this->items, $this->getArrayableItems($items)));\n    }\n\n    \/**\n     * Reverse items order.\n     *\n     * @return static\n     *\/\n    public function reverse()\n    {\n        return new static(array_reverse($this->items, true));\n    }\n\n    \/**\n     * Search the collection for a given value and return the corresponding key if successful.\n     *\n     * @param mixed $value\n     * @param bool  $strict\n     *\n     * @return mixed\n     *\/\n    public function search($value, $strict = false)\n    {\n        if (! $this->useAsCallable($value)) {\n            return array_search($value, $this->items, $strict);\n        }\n\n        foreach ($this->items as $key => $item) {\n            if ($value($item, $key)) {\n                return $key;\n            }\n        }\n\n        return false;\n    }\n\n    \/**\n     * Get and remove the first item from the collection.\n     *\n     * @return mixed\n     *\/\n    public function shift()\n    {\n        return array_shift($this->items);\n    }\n\n    \/**\n     * Shuffle the items in the collection.\n     *\n     * @param int $seed\n     *\n     * @return static\n     *\/\n    public function shuffle($seed = null)\n    {\n        return new static(Arr::shuffle($this->items, $seed));\n    }\n\n    \/**\n     * Slice the underlying collection array.\n     *\n     * @param int $offset\n     * @param int $length\n     *\n     * @return static\n     *\/\n    public function slice($offset, $length = null)\n    {\n        return new static(array_slice($this->items, $offset, $length, true));\n    }\n\n    \/**\n     * Split a collection into a certain number of groups.\n     *\n     * @param int $numberOfGroups\n     *\n     * @return static\n     *\/\n    public function split($numberOfGroups)\n    {\n        if ($this->isEmpty()) {\n            return new static();\n        }\n\n        $groups = new static();\n\n        $groupSize = floor($this->count() \/ $numberOfGroups);\n\n        $remain = $this->count() % $numberOfGroups;\n\n        $start = 0;\n\n        for ($i = 0; $i < $numberOfGroups; $i++) {\n            $size = $groupSize;\n\n            if ($i < $remain) {\n                $size++;\n            }\n\n            if ($size) {\n                $groups->push(new static(array_slice($this->items, $start, $size)));\n\n                $start += $size;\n            }\n        }\n\n        return $groups;\n    }\n\n    \/**\n     * Chunk the underlying collection array.\n     *\n     * @param int $size\n     *\n     * @return static\n     *\/\n    public function chunk($size)\n    {\n        if ($size <= 0) {\n            return new static();\n        }\n\n        $chunks = [];\n\n        foreach (array_chunk($this->items, $size, true) as $chunk) {\n            $chunks[] = new static($chunk);\n        }\n\n        return new static($chunks);\n    }\n\n    \/**\n     * Sort through each item with a callback.\n     *\n     * @return static\n     *\/\n    public function sort(?callable $callback = null)\n    {\n        $items = $this->items;\n\n        $callback\n            ? uasort($items, $callback)\n            : asort($items);\n\n        return new static($items);\n    }\n\n    \/**\n     * Sort the collection using the given callback.\n     *\n     * @param callable|string $callback\n     * @param int             $options\n     * @param bool            $descending\n     *\n     * @return static\n     *\/\n    public function sortBy($callback, $options = SORT_REGULAR, $descending = false)\n    {\n        $results = [];\n\n        $callback = $this->valueRetriever($callback);\n\n        \/\/ First we will loop through the items and get the comparator from a callback\n        \/\/ function which we were given. Then, we will sort the returned values and\n        \/\/ and grab the corresponding values for the sorted keys from this array.\n        foreach ($this->items as $key => $value) {\n            $results[$key] = $callback($value, $key);\n        }\n\n        $descending ? arsort($results, $options)\n            : asort($results, $options);\n\n        \/\/ Once we have sorted all of the keys in the array, we will loop through them\n        \/\/ and grab the corresponding model so we can set the underlying items list\n        \/\/ to the sorted version. Then we'll just return the collection instance.\n        foreach (array_keys($results) as $key) {\n            $results[$key] = $this->items[$key];\n        }\n\n        return new static($results);\n    }\n\n    \/**\n     * Sort the collection in descending order using the given callback.\n     *\n     * @param callable|string $callback\n     * @param int             $options\n     *\n     * @return static\n     *\/\n    public function sortByDesc($callback, $options = SORT_REGULAR)\n    {\n        return $this->sortBy($callback, $options, true);\n    }\n\n    \/**\n     * Sort the collection keys.\n     *\n     * @param int  $options\n     * @param bool $descending\n     *\n     * @return static\n     *\/\n    public function sortKeys($options = SORT_REGULAR, $descending = false)\n    {\n        $items = $this->items;\n\n        $descending ? krsort($items, $options) : ksort($items, $options);\n\n        return new static($items);\n    }\n\n    \/**\n     * Sort the collection keys in descending order.\n     *\n     * @param int $options\n     *\n     * @return static\n     *\/\n    public function sortKeysDesc($options = SORT_REGULAR)\n    {\n        return $this->sortKeys($options, true);\n    }\n\n    \/**\n     * Splice a portion of the underlying collection array.\n     *\n     * @param int      $offset\n     * @param int|null $length\n     * @param mixed    $replacement\n     *\n     * @return static\n     *\/\n    public function splice($offset, $length = null, $replacement = [])\n    {\n        if (func_num_args() === 1) {\n            return new static(array_splice($this->items, $offset));\n        }\n\n        return new static(array_splice($this->items, $offset, $length, $replacement));\n    }\n\n    \/**\n     * Get the sum of the given values.\n     *\n     * @param callable|string|null $callback\n     *\n     * @return mixed\n     *\/\n    public function sum($callback = null)\n    {\n        if (null === $callback) {\n            return array_sum($this->items);\n        }\n\n        $callback = $this->valueRetriever($callback);\n\n        return $this->reduce(static fn ($result, $item) => $result + $callback($item), 0);\n    }\n\n    \/**\n     * Take the first or last {$limit} items.\n     *\n     * @param int $limit\n     *\n     * @return static\n     *\/\n    public function take($limit)\n    {\n        if ($limit < 0) {\n            return $this->slice($limit, abs($limit));\n        }\n\n        return $this->slice(0, $limit);\n    }\n\n    \/**\n     * Pass the collection to the given callback and then return it.\n     *\n     * @return $this\n     *\/\n    public function tap(callable $callback)\n    {\n        $callback(new static($this->items));\n\n        return $this;\n    }\n\n    \/**\n     * Transform each item in the collection using a callback.\n     *\n     * @return $this\n     *\/\n    public function transform(callable $callback)\n    {\n        $this->items = $this->map($callback)->all();\n\n        return $this;\n    }\n\n    \/**\n     * Return only unique items from the collection array.\n     *\n     * @param callable|string|null $key\n     * @param bool                 $strict\n     *\n     * @return static\n     *\/\n    public function unique($key = null, $strict = false)\n    {\n        $callback = $this->valueRetriever($key);\n\n        $exists = [];\n\n        return $this->reject(static function ($item, $key) use ($callback, $strict, &$exists) {\n            if (in_array($id = $callback($item, $key), $exists, $strict)) {\n                return true;\n            }\n\n            $exists[] = $id;\n        });\n    }\n\n    \/**\n     * Return only unique items from the collection array using strict comparison.\n     *\n     * @param callable|string|null $key\n     *\n     * @return static\n     *\/\n    public function uniqueStrict($key = null)\n    {\n        return $this->unique($key, true);\n    }\n\n    \/**\n     * Reset the keys on the underlying array.\n     *\n     * @return static\n     *\/\n    public function values()\n    {\n        return new static(array_values($this->items));\n    }\n\n    \/**\n     * Get a value retrieving callback.\n     *\n     * @param callable|string|null $value\n     *\n     * @return callable\n     *\/\n    protected function valueRetriever($value)\n    {\n        if ($this->useAsCallable($value)) {\n            return $value;\n        }\n\n        return static fn ($item) => Arr::get($item, $value);\n    }\n\n    \/**\n     * Zip the collection together with one or more arrays.\n     *\n     * e.g. new Collection([1, 2, 3])->zip([4, 5, 6]);\n     *      => [[1, 4], [2, 5], [3, 6]]\n     *\n     * @param mixed ...$items\n     *\n     * @return static\n     *\/\n    public function zip($items)\n    {\n        $arrayableItems = array_map(fn ($items) => $this->getArrayableItems($items), func_get_args());\n\n        $params = array_merge([static fn () => new static(func_get_args()), $this->items], $arrayableItems);\n\n        return new static(array_map(...$params));\n    }\n\n    \/**\n     * Pad collection to the specified length with a value.\n     *\n     * @param int   $size\n     * @param mixed $value\n     *\n     * @return static\n     *\/\n    public function pad($size, $value)\n    {\n        return new static(array_pad($this->items, $size, $value));\n    }\n\n    \/**\n     * Obtenez la collection d'\u00e9l\u00e9ments sous la forme d'un tableau simple.\n     *\/\n    public function toArray(): array\n    {\n        return array_map(static fn ($value) => $value instanceof Arrayable ? $value->toArray() : $value, $this->items);\n    }\n\n    \/**\n     * Convertissez l'objet en quelque chose de JSON s\u00e9rialisable.\n     *\/\n    public function jsonSerialize(): array\n    {\n        return array_map(static function ($value) {\n            if ($value instanceof JsonSerializable) {\n                return $value->jsonSerialize();\n            }\n            if ($value instanceof Jsonable) {\n                return json_decode($value->toJson(), true);\n            }\n            if ($value instanceof Arrayable) {\n                return $value->toArray();\n            }\n\n            return $value;\n        }, $this->items);\n    }\n\n    \/**\n     * Obtenez la collection d'\u00e9l\u00e9ments au format JSON.\n     *\/\n    public function toJson(int $options = 0): string\n    {\n        return json_encode($this->jsonSerialize(), $options);\n    }\n\n    \/**\n     * Get an iterator for the items.\n     *\/\n    public function getIterator(): Traversable\n    {\n        return new ArrayIterator($this->items);\n    }\n\n    \/**\n     * Get a CachingIterator instance.\n     *\n     * @param int $flags\n     *\n     * @return CachingIterator\n     *\/\n    public function getCachingIterator($flags = CachingIterator::CALL_TOSTRING)\n    {\n        return new CachingIterator($this->getIterator(), $flags);\n    }\n\n    \/**\n     * Comptez le nombre d'\u00e9l\u00e9ments dans la collection.\n     *\/\n    public function count(): int\n    {\n        return count($this->items);\n    }\n\n    \/**\n     * Comptez le nombre d'\u00e9l\u00e9ments de la collection \u00e0 l'aide d'un test de v\u00e9rit\u00e9 donn\u00e9.\n     *\/\n    public function countBy(?callable $callback = null): self\n    {\n        if (null === $callback) {\n            $callback = static fn ($value) => $value;\n        }\n\n        return new static($this->groupBy($callback)->map(static fn ($value) => $value->count()));\n    }\n\n    \/**\n     * Ajoute un \u00e9l\u00e9ment \u00e0 la collection.\n     *\n     * @param mixed $item\n     *\n     * @return $this\n     *\/\n    public function add($item)\n    {\n        $this->items[] = $item;\n\n        return $this;\n    }\n\n    \/**\n     * Get a base Support collection instance from this collection.\n     *\n     * @return self\n     *\/\n    public function toBase()\n    {\n        return new self($this);\n    }\n\n    \/**\n     * D\u00e9termine si un \u00e9l\u00e9ment existe \u00e0 un d\u00e9calage.\n     *\n     * @param mixed $key\n     *\/\n    public function offsetExists($key): bool\n    {\n        return array_key_exists($key, $this->items);\n    }\n\n    \/**\n     * Obtenir un \u00e9l\u00e9ment \u00e0 un d\u00e9calage donn\u00e9.\n     *\n     * @param mixed $key\n     *\n     * @return mixed\n     *\/\n    public function offsetGet($key)\n    {\n        return $this->items[$key];\n    }\n\n    \/**\n     * D\u00e9finir l'\u00e9l\u00e9ment \u00e0 un d\u00e9calage donn\u00e9.\n     *\n     * @param mixed $key\n     * @param mixed $value\n     *\/\n    public function offsetSet($key, $value): void\n    {\n        if (null === $key) {\n            $this->items[] = $value;\n        } else {\n            $this->items[$key] = $value;\n        }\n    }\n\n    \/**\n     * Supprime l'\u00e9l\u00e9ment \u00e0 un d\u00e9calage donn\u00e9.\n     *\n     * @param string $key\n     *\/\n    public function offsetUnset($key): void\n    {\n        unset($this->items[$key]);\n    }\n\n    \/**\n     * Convertissez la collection en sa repr\u00e9sentation sous forme de cha\u00eene.\n     *\/\n    public function __toString(): string\n    {\n        return $this->toJson();\n    }\n\n    \/**\n     * Tableau de r\u00e9sultats des \u00e9l\u00e9ments de Collection ou Arrayable.\n     *\n     * @param mixed $items\n     *\/\n    protected function getArrayableItems($items): array\n    {\n        if (is_array($items)) {\n            return $items;\n        }\n        if ($items instanceof self) {\n            return $items->all();\n        }\n        if ($items instanceof Arrayable) {\n            return $items->toArray();\n        }\n        if ($items instanceof Jsonable) {\n            return json_decode($items->toJson(), true);\n        }\n        if ($items instanceof JsonSerializable) {\n            return (array) $items->jsonSerialize();\n        }\n        if ($items instanceof Traversable) {\n            return iterator_to_array($items);\n        }\n\n        return (array) $items;\n    }\n\n    \/**\n     * Ajoutez une m\u00e9thode \u00e0 la liste des m\u00e9thodes proxy.\n     *\/\n    public static function proxy(string $method): void\n    {\n        static::$proxies[] = $method;\n    }\n\n    \/**\n     * Acc\u00e9dez dynamiquement aux proxys de collecte.\n     *\n     * @param string $key\n     *\n     * @throws Exception\n     *\n     * @return mixed\n     *\/\n    public function __get($key)\n    {\n        if (! in_array($key, static::$proxies, true)) {\n            throw new Exception(\"Property [{$key}] does not exist on this collection instance.\");\n        }\n\n        return new HigherOrderCollectionProxy($this, $key);\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,null,0,0,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,0,null,null,null,0,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,0,null,null,null,0,null,0,null,null,0,null,null,null,null,null,0,null,null,0,null,0,null,0,null,0,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,0,null,null,0,null,null,0,null,null,null,0,null,null,0,null,null,0,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,0,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,0,null,0,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,0,null,0,null,0,0,null,null,0,null,null,null,0,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null]},{"name":"src\\Utilities\\Helpers.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Utilities;\n\nuse Exception;\nuse HTMLPurifier;\nuse HTMLPurifier_Config;\nuse InvalidArgumentException;\n\nclass Helpers\n{\n    \/**\n     * D\u00e9termine si la version actuelle de PHP est \u00e9gale ou sup\u00e9rieure \u00e0 la valeur fournie\n     *\/\n    public static function isPhp(string $version): bool\n    {\n        static $_is_php;\n\n        if (! isset($_is_php[$version])) {\n            $_is_php[$version] = version_compare(PHP_VERSION, $version, '>=');\n        }\n\n        return $_is_php[$version];\n    }\n\n    \/**\n     * Tester si une application s'ex\u00e9cute en local ou en ligne\n     *\/\n    public static function isOnline(): bool\n    {\n        $host = explode(':', $_SERVER['HTTP_HOST'] ?? '')[0];\n\n        return\n            ! empty($host) \/\/ Si c'est vide, ca veut certainement dire qu'on est en CLI, or le CLI << n'est pas >> utilis\u00e9 en ligne\n            && ! in_array($host, ['localhost', '127.0.0.1'], true)\n            && ! preg_match('#\\.dev$#', $host)\n            && ! preg_match('#\\.test$#', $host)\n            && ! preg_match('#\\.lab$#', $host)\n            && ! preg_match('#\\.loc(al)?$#', $host)\n            && ! preg_match('#^192\\.168#', $host);\n    }\n\n    \/**\n     * Tests d'inscriptibilit\u00e9 des fichiers\n     *\n     * is_writable() renvoie TRUE sur les serveurs Windows lorsque vous ne pouvez vraiment pas \u00e9crire\n     * le fichier, bas\u00e9 sur l'attribut en lecture seule. is_writable() n'est pas non plus fiable\n     * sur les serveurs Unix si safe_mode est activ\u00e9.\n     *\n     * @see https:\/\/bugs.php.net\/bug.php?id=54709\n     *\n     * @throws Exception\n     * @codeCoverageIgnore Pas pratique \u00e0 tester, car travis fonctionne sous linux\n     *\/\n    public static function isReallyWritable(string $file): bool\n    {\n        \/\/ If we're on a Unix server with safe_mode off we call is_writable\n        if (DIRECTORY_SEPARATOR === '\/' || ! ini_get('safe_mode')) {\n            return is_writable($file);\n        }\n\n        \/* Pour les serveurs Windows et les installations safe_mode \"on\", nous allons en fait\n         * \u00e9crire un fichier puis le lire. Bah...\n         *\/\n        if (is_dir($file)) {\n            $file = rtrim($file, '\/') . '\/' . bin2hex(random_bytes(16));\n            if (($fp = @fopen($file, 'ab')) === false) {\n                return false;\n            }\n\n            fclose($fp);\n            @chmod($file, 0777);\n            @unlink($file);\n\n            return true;\n        }\n        if (! is_file($file) || ($fp = @fopen($file, 'ab')) === false) {\n            return false;\n        }\n\n        fclose($fp);\n\n        return true;\n    }\n\n    public static function cleanUrl(string $url): string\n    {\n        $path  = parse_url($url);\n        $query = '';\n\n        if (! empty($path['host'])) {\n            $r = $path['scheme'] . ':\/\/';\n            if (! empty($path['user'])) {\n                $r .= $path['user'];\n                if (! empty($path['pass'])) {\n                    $r .= ':' . $path['pass'] . '@';\n                }\n                $r .= '@';\n            }\n            if (! empty($path['host'])) {\n                $r .= $path['host'];\n            }\n            if (! empty($path['port'])) {\n                $r .= ':' . $path['port'];\n            }\n            $url = $r . $path['path'];\n            if (! empty($path['query'])) {\n                $query = '?' . $path['query'];\n            }\n        }\n        $url = str_replace('\/.\/', '\/', $url);\n\n        while (substr_count($url, '..\/')) {\n            $url = preg_replace('!\/([\\\\w\\\\d]+\/\\\\.\\\\.)!', '', $url);\n        }\n\n        return $url . $query;\n    }\n\n    \/**\n     * Supprimer les caract\u00e8res invisibles\n     *\n     * Cela emp\u00eache de prendre en sandwich des caract\u00e8res nuls\n     * entre les caract\u00e8res ascii, comme Java\\0script.\n     *\/\n    public static function removeInvisibleCharacters(string $str, bool $url_encoded = true): string\n    {\n        $non_displayables = [];\n\n        if ($url_encoded) {\n            $non_displayables[] = '\/%0[0-8bcef]\/i';\t\/\/ url encoded 00-08, 11, 12, 14, 15\n            $non_displayables[] = '\/%1[0-9a-f]\/i';\t\/\/ url encoded 16-31\n            $non_displayables[] = '\/%7f\/i';\t\/\/ url encoded 127\n        }\n\n        $non_displayables[] = '\/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]+\/S';\t\/\/ 00-08, 11, 12, 14-31, 127\n\n        do {\n            $str = preg_replace($non_displayables, '', $str, -1, $count);\n        } while ($count);\n\n        return $str;\n    }\n\n    \/**\n     * Effectue un simple \u00e9chappement automatique des donn\u00e9es pour des raisons de s\u00e9curit\u00e9.\n     * Pourrait envisager de rendre cela plus complexe \u00e0 une date ult\u00e9rieure.\n     *\n     * Si $data est une cha\u00eene, il suffit alors de l'\u00e9chapper et de la renvoyer.\n     * Si $data est un tableau, alors il boucle dessus, s'\u00e9chappant de chaque\n     * 'valeur' des paires cl\u00e9\/valeur.\n     *\n     * Valeurs de contexte valides : html, js, css, url, attr, raw, null\n     *\n     * @param array|string $data\n     *\n     * @throws InvalidArgumentException\n     *\n     * @return array|string\n     *\/\n    public static function esc($data, ?string $context = 'html', ?string $encoding = null)\n    {\n        if (is_array($data)) {\n            foreach ($data as $key => &$value) {\n                $value = self::esc($value, $context);\n            }\n        }\n\n        if (is_string($data)) {\n            $context = strtolower($context);\n\n            \/\/ Fournit un moyen de NE PAS \u00e9chapper aux donn\u00e9es depuis\n            \/\/ cela pourrait \u00eatre appel\u00e9 automatiquement par\n            \/\/ la biblioth\u00e8que View.\n            if (empty($context) || $context === 'raw') {\n                return $data;\n            }\n\n            if (! in_array($context, ['html', 'js', 'css', 'url', 'attr'], true)) {\n                throw new InvalidArgumentException('Invalid escape context provided.');\n            }\n\n            if ($context === 'attr') {\n                $method = 'escapeHtmlAttr';\n            } else {\n                $method = 'escape' . ucfirst($context);\n            }\n\n            static $escaper;\n            if (! $escaper) {\n                $escaper = new \\Laminas\\Escaper\\Escaper($encoding);\n            }\n\n            if ($encoding && $escaper->getEncoding() !== $encoding) {\n                $escaper = new \\Laminas\\Escaper\\Escaper($encoding);\n            }\n\n            $data = $escaper->{$method}($data);\n        }\n\n        return $data;\n    }\n\n    \/**\n     * M\u00e9thode pratique pour htmlspecialchars.\n     *\n     * @param mixed       $text    Texte \u00e0 envelopper dans htmlspecialchars. Fonctionne \u00e9galement avec des tableaux et des objets.\n     *                             Les tableaux seront mapp\u00e9s et tous leurs \u00e9l\u00e9ments seront \u00e9chapp\u00e9s. Les objets seront transtyp\u00e9s s'ils\n     *                             impl\u00e9menter une m\u00e9thode `__toString`. Sinon, le nom de la classe sera utilis\u00e9.\n     *                             Les autres types de scalaires seront renvoy\u00e9s tels quels.\n     * @param bool        $double  Encodez les entit\u00e9s html existantes.\n     * @param string|null $charset Jeu de caract\u00e8res \u00e0 utiliser lors de l'\u00e9chappement. La valeur par d\u00e9faut est la valeur de configuration dans `mb_internal_encoding()` ou 'UTF-8'.\n     *\n     * @return mixed Texte envelopp\u00e9.\n     * @credit CackePHP (https:\/\/cakephp.org)\n     *\/\n    public static function h($text, bool $double = true, ?string $charset = null)\n    {\n        if (is_string($text)) {\n            \/\/ optimize for strings\n        } elseif (is_array($text)) {\n            $texts = [];\n\n            foreach ($text as $k => $t) {\n                $texts[$k] = self::h($t, $double, $charset);\n            }\n\n            return $texts;\n        } elseif (is_object($text)) {\n            if (method_exists($text, '__toString')) {\n                $text = (string) $text;\n            } else {\n                $text = '(object)' . get_class($text);\n            }\n        } elseif ($text === null || is_scalar($text)) {\n            return $text;\n        }\n\n        static $defaultCharset = false;\n        if ($defaultCharset === false) {\n            $defaultCharset = mb_internal_encoding();\n            if ($defaultCharset === null) {\n                $defaultCharset = 'UTF-8';\n            }\n        }\n        if (is_string($double)) {\n            self::deprecationWarning(\n                'Passing charset string for 2nd argument is deprecated. ' .\n                'Use the 3rd argument instead.'\n            );\n            $charset = $double;\n            $double  = true;\n        }\n\n        return htmlspecialchars($text, ENT_QUOTES | ENT_SUBSTITUTE, $charset ?: $defaultCharset, $double);\n    }\n\n    \/**\n     * Garantit qu'une extension se trouve \u00e0 la fin d'un nom de fichier\n     *\/\n    public static function ensureExt(string $path, string $ext = 'php'): string\n    {\n        if ($ext) {\n            $ext = '.' . preg_replace('#^\\.#', '', $ext);\n\n            if (substr($path, -strlen($ext)) !== $ext) {\n                $path .= $ext;\n            }\n        }\n\n        return trim($path);\n    }\n\n    \/**\n     * Purifiez l'entr\u00e9e \u00e0 l'aide de la classe autonome HTMLPurifier.\n     * Utilisez facilement plusieurs configurations de purificateur.\n     *\n     * @param string|string[] $dirty_html\n     * @param false|string    $config\n     *\n     * @return string|string[]\n     *\/\n    public static function purify($dirty_html, $config = false, string $charset = 'UTF-8')\n    {\n        if (is_array($dirty_html)) {\n            foreach ($dirty_html as $key => $val) {\n                $clean_html[$key] = self::purify($val, $config);\n            }\n        } else {\n            switch ($config) {\n\n                case 'comment':\n                    $config = HTMLPurifier_Config::createDefault();\n                    $config->set('Core.Encoding', $charset);\n                    $config->set('HTML.Doctype', 'XHTML 1.0 Strict');\n                    $config->set('HTML.Allowed', 'p,a[href|title],abbr[title],acronym[title],b,strong,blockquote[cite],code,em,i,strike');\n                    $config->set('AutoFormat.AutoParagraph', true);\n                    $config->set('AutoFormat.Linkify', true);\n                    $config->set('AutoFormat.RemoveEmpty', true);\n                    break;\n\n                case false:\n                    $config = HTMLPurifier_Config::createDefault();\n                    $config->set('Core.Encoding', $charset);\n                    $config->set('HTML.Doctype', 'XHTML 1.0 Strict');\n                    break;\n\n                default:\n                    throw new InvalidArgumentException('The HTMLPurifier configuration labeled \"' . htmlspecialchars($config, ENT_QUOTES, $charset) . '\" could not be found.');\n            }\n\n            $purifier   = new HTMLPurifier($config);\n            $clean_html = $purifier->purify($dirty_html);\n        }\n\n        return $clean_html;\n    }\n\n    \/**\n     * Cha\u00eener les attributs \u00e0 utiliser dans les balises HTML.\n     *\n     * Fonction d'assistance utilis\u00e9e pour convertir une cha\u00eene, un tableau ou un objet\n     * d'attributs \u00e0 une cha\u00eene.\n     *\n     * @param array|object|string $attributes\n     *\/\n    public static function stringifyAttributes($attributes, bool $js = false): string\n    {\n        $atts = '';\n\n        if (empty($attributes)) {\n            return $atts;\n        }\n\n        if (is_string($attributes)) {\n            return ' ' . $attributes;\n        }\n\n        $attributes = (array) $attributes;\n\n        foreach ($attributes as $key => $val) {\n            $atts .= ($js) ? $key . '=' . self::esc($val, 'js') . ',' : ' ' . $key . '=\"' . self::esc($val, 'attr') . '\"';\n        }\n\n        return rtrim($atts, ',');\n    }\n\n    \/**\n     * Obtient une variable d'environnement \u00e0 partir des sources disponibles et fournit une \u00e9mulation\n     * pour les variables d'environnement non prises en charge ou incoh\u00e9rentes (c'est-\u00e0-dire DOCUMENT_ROOT sur\n     * IIS, ou SCRIPT_NAME en mode CGI). Expose \u00e9galement quelques coutumes suppl\u00e9mentaires\n     * informations sur l'environnement.\n     *\n     * @param string     $key     Nom de la variable d'environnement\n     * @param mixed|null $default\n     *\n     * @return string Param\u00e9trage des variables d'environnement.\n     * @credit CakePHP - http:\/\/book.cakephp.org\/2.0\/en\/core-libraries\/global-constants-and-functions.html#env\n     *\/\n    public static function env(string $key, $default = null)\n    {\n        if ($key === 'HTTPS') {\n            if (isset($_SERVER['HTTPS'])) {\n                return ! empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off';\n            }\n            if (isset($_SERVER['HTTP_X_FORWARDED_PROTO'])) {\n                return ! empty($_SERVER['HTTP_X_FORWARDED_PROTO']) && strtolower($_SERVER['HTTP_X_FORWARDED_PROTO']) === 'https';\n            }\n            if (isset($_SERVER['HTTP_FRONT_END_HTTPS'])) {\n                return ! empty($_SERVER['HTTP_FRONT_END_HTTPS']) && strtolower($_SERVER['HTTP_FRONT_END_HTTPS']) !== 'off';\n            }\n\n            return strpos(self::env('SCRIPT_URI'), 'https:\/\/') === 0;\n        }\n\n        if ($key === 'SCRIPT_NAME') {\n            if (self::env('CGI_MODE') && isset($_ENV['SCRIPT_URL'])) {\n                $key = 'SCRIPT_URL';\n            }\n        }\n\n        $val = null;\n        if (isset($_SERVER[$key])) {\n            $val = $_SERVER[$key];\n        } elseif (isset($_ENV[$key])) {\n            $val = $_ENV[$key];\n        } elseif (getenv($key) !== false) {\n            $val = getenv($key);\n        }\n\n        if ($key === 'REMOTE_ADDR' && $val === self::env('SERVER_ADDR')) {\n            $addr = self::env('HTTP_PC_REMOTE_ADDR');\n            if ($addr !== null) {\n                $val = $addr;\n            }\n        }\n\n        if ($val !== null) {\n            return $val;\n        }\n\n        switch ($key) {\n            case 'DOCUMENT_ROOT':\n                $name     = self::env('SCRIPT_NAME');\n                $filename = self::env('SCRIPT_FILENAME');\n                $offset   = 0;\n                if (! strpos($name, '.php')) {\n                    $offset = 4;\n                }\n\n                return substr($filename, 0, -(strlen($name) + $offset));\n\n            case 'PHP_SELF':\n                return str_replace(self::env('DOCUMENT_ROOT'), '', self::env('SCRIPT_FILENAME'));\n\n            case 'CGI_MODE':\n                return PHP_SAPI === 'cgi';\n\n            case 'HTTP_BASE':\n                $host  = self::env('HTTP_HOST');\n                $parts = explode('.', $host);\n                $count = count($parts);\n\n                if ($count === 1) {\n                    return '.' . $host;\n                }\n                if ($count === 2) {\n                    return '.' . $host;\n                }\n                if ($count === 3) {\n                    $gTLD = [\n                        'aero',\n                        'asia',\n                        'biz',\n                        'cat',\n                        'com',\n                        'coop',\n                        'edu',\n                        'gov',\n                        'info',\n                        'int',\n                        'jobs',\n                        'mil',\n                        'mobi',\n                        'museum',\n                        'name',\n                        'net',\n                        'org',\n                        'pro',\n                        'tel',\n                        'travel',\n                        'xxx',\n                    ];\n                    if (in_array($parts[1], $gTLD, true)) {\n                        return '.' . $host;\n                    }\n                }\n                array_shift($parts);\n\n                return '.' . implode('.', $parts);\n        }\n\n        return $default;\n    }\n\n    \/**\n     * Jolie fonction de commodit\u00e9 d'impression JSON.\n     *\n     * Dans les terminaux, cela agira de la m\u00eame mani\u00e8re que json_encode() avec JSON_PRETTY_PRINT directement, lorsqu'il n'est pas ex\u00e9cut\u00e9 sur cli\n     * enveloppera \u00e9galement les balises <pre> autour de la sortie de la variable donn\u00e9e. Similaire \u00e0 pr().\n     *\n     * Cette fonction renvoie la m\u00eame variable qui a \u00e9t\u00e9 transmise.\n     *\n     * @param mixed $var Variable \u00e0 imprimer.\n     *\n     * @return mixed le m\u00eame $var qui a \u00e9t\u00e9 pass\u00e9 \u00e0 cette fonction\n     *\n     * @see pr()\n     *\/\n    public static function pj($var)\n    {\n        $template = (PHP_SAPI !== 'cli' && PHP_SAPI !== 'phpdbg') ? '<pre class=\"pj\">%s<\/pre>' : \"\\n%s\\n\\n\";\n        printf($template, trim(json_encode($var, JSON_PRETTY_PRINT)));\n\n        return $var;\n    }\n\n    \/**\n     * M\u00e9thode d'assistance pour g\u00e9n\u00e9rer des avertissements d'obsolescence\n     *\n     * @param string $message    Le message \u00e0 afficher comme avertissement d'obsolescence.\n     * @param int    $stackFrame Le cadre de pile \u00e0 inclure dans l'erreur. Par d\u00e9faut \u00e0 1\n     *                           car cela devrait pointer vers le code de l'application\/du plugin.\n     *\n     * @return void\n     *\/\n    public static function deprecationWarning(string $message, int $stackFrame = 1)\n    {\n        if (! (error_reporting() & E_USER_DEPRECATED)) {\n            return;\n        }\n\n        $trace = debug_backtrace();\n        if (isset($trace[$stackFrame])) {\n            $frame = $trace[$stackFrame];\n            $frame += ['file' => '[internal]', 'line' => '??'];\n\n            $message = sprintf(\n                '%s - %s, line: %s' . \"\\n\" .\n                ' You can disable deprecation warnings by setting `Error.errorLevel` to' .\n                ' `E_ALL & ~E_USER_DEPRECATED` in your config\/app.php.',\n                $message,\n                $frame['file'],\n                $frame['line']\n            );\n        }\n\n        @trigger_error($message, E_USER_DEPRECATED);\n    }\n\n    \/**\n     * D\u00e9clenche un E_USER_WARNING.\n     *\/\n    public static function triggerWarning(string $message)\n    {\n        $stackFrame = 1;\n        $trace      = debug_backtrace();\n        if (isset($trace[$stackFrame])) {\n            $frame = $trace[$stackFrame];\n            $frame += ['file' => '[internal]', 'line' => '??'];\n            $message = sprintf(\n                '%s - %s, line: %s',\n                $message,\n                $frame['file'],\n                $frame['line']\n            );\n        }\n        trigger_error($message, E_USER_WARNING);\n    }\n\n    \/**\n     * Divise un nom de plugin de syntaxe \u00e0 points en son plugin et son nom de classe.\n     * Si $name n'a pas de point, alors l'index 0 sera nul.\n     *\n     * Couramment utilis\u00e9 comme\n     * ```\n     * list($plugin, $name) = Helpers::pluginSplit($name);\n     * ```\n     *\n     * @param string      $name      Le nom que vous voulez diviser en plugin.\n     * @param bool        $dotAppend D\u00e9finir sur true si vous voulez que le plugin ait un '.' qui y est annex\u00e9.\n     * @param string|null $plugin    Plugin optionnel par d\u00e9faut \u00e0 utiliser si aucun plugin n'est trouv\u00e9. La valeur par d\u00e9faut est nulle.\n     *\n     * @return array Tableau avec 2 index. 0 => nom du plugin, 1 => nom de la classe.\n     * @credit <a href=\"https:\/\/book.cakephp.org\/4\/en\/core-libraries\/global-constants-and-functions.html#pluginSplit\">CakePHP<\/a>\n     * @psalm-return array{string|null, string}\n     *\/\n    public static function pluginSplit(string $name, bool $dotAppend = false, ?string $plugin = null): array\n    {\n        if (strpos($name, '.') !== false) {\n            $parts = explode('.', $name, 2);\n            if ($dotAppend) {\n                $parts[0] .= '.';\n            }\n\n            \/** @psalm-var array{string, string}*\/\n            return $parts;\n        }\n\n        return [$plugin, $name];\n    }\n\n    \/**\n     * S\u00e9parez l'espace de noms du nom de classe.\n     *\n     * Couramment utilis\u00e9 comme `list($namespace, $className) = Helpers::namespaceSplit($class);`.\n     *\n     * @param string $class Le nom complet de la classe, ie `BlitzPHP\\Core\\App`.\n     *\n     * @return array<string> Tableau avec 2 index. 0 => namespace, 1 => nom de la classe.\n     *\/\n    public static function namespaceSplit(string $class): array\n    {\n        $pos = strrpos($class, '\\\\');\n        if ($pos === false) {\n            return ['', $class];\n        }\n\n        return [substr($class, 0, $pos), substr($class, $pos + 1)];\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,0,null,0,null,null,0,0,0,null,0,null,null,0,null,null,0,null,0,null,null,null,null,0,0,null,null,0,null,0,null,0,null,0,null,null,0,null,null,0,null,0,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,0,0,null,null,0,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,null,0,null,null,null,0,null,null,null,0,null,0,null,null,0,null,0,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,0,null,null,0,null,null,0,null,0,null,0,null,null,null,null,null,null,0,0,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,0,0,0,0,0,0,0,0,null,null,0,0,0,0,null,null,0,null,null,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,0,null,null,null,0,null,0,null,0,null,0,null,null,null,0,null,0,null,null,null,null,0,null,null,null,null,0,0,0,null,0,null,null,0,null,null,0,null,null,0,null,null,0,0,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,0,null,0,0,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,null]},{"name":"src\\Utilities\\Str.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\Utilities;\n\nuse BlitzPHP\\Traits\\Macroable;\nuse Transliterator;\n\nif (! defined('MB_ENABLED')) {\n    if (extension_loaded('mbstring')) {\n        define('MB_ENABLED', true);\n        \/\/ mbstring.internal_encoding est obsol\u00e8te \u00e0 partir de PHP 5.6\n        \/\/ et son utilisation d\u00e9clenche des messages E_DEPRECATED.\n        @ini_set('mbstring.internal_encoding', $charset);\n        \/\/ Ceci est requis pour que mb_convert_encoding() supprime les caract\u00e8res invalides.\n        \/\/ C'est utilis\u00e9 par CI_Utf8, mais c'est aussi fait pour la coh\u00e9rence avec iconv.\n        mb_substitute_character('none');\n    } else {\n        define('MB_ENABLED', false);\n    }\n}\nif (! defined('ICONV_ENABLED')) {\n    if (extension_loaded('iconv')) {\n        define('ICONV_ENABLED', true);\n        \/\/ iconv.internal_encoding est obsol\u00e8te \u00e0 partir de PHP 5.6\n        \/\/ et son utilisation d\u00e9clenche des messages E_DEPRECATED.\n        @ini_set('iconv.internal_encoding', $charset);\n    } else {\n        define('ICONV_ENABLED', false);\n    }\n}\n\nclass Str\n{\n    use Macroable;\n\n    \/**\n     * Default transliterator.\n     *\n     * @var Transliterator Transliterator instance.\n     *\/\n    protected static $_defaultTransliterator;\n\n    \/**\n     * Default transliterator id string.\n     *\n     * @var string Transliterator identifier string.\n     *\/\n    protected static $_defaultTransliteratorId = 'Any-Latin; Latin-ASCII; [\\u0080-\\u7fff] remove';\n\n    \/**\n     * Default html tags who must not be count for truncate text.\n     *\n     * @var array\n     *\/\n    protected static $_defaultHtmlNoCount = [\n        'style',\n        'script',\n    ];\n\n    \/**\n     * Return the remainder of a string after a given value.\n     *\/\n    public static function after(string $subject, string $search): string\n    {\n        return $search === '' ? $subject : array_reverse(explode($search, $subject, 2))[0];\n    }\n\n    \/**\n     * Transliterate a UTF-8 value to ASCII.\n     *\/\n    public static function ascii(string $value, string $language = 'en'): string\n    {\n        $languageSpecific = static::languageSpecificCharsArray($language);\n\n        if (null !== $languageSpecific) {\n            $value = str_replace($languageSpecific[0], $languageSpecific[1], $value);\n        }\n\n        foreach (static::charsArray() as $key => $val) {\n            $value = str_replace($val, $key, $value);\n        }\n\n        return preg_replace('\/[^\\x20-\\x7E]\/u', '', $value);\n    }\n\n    \/**\n     * Get the portion of a string before a given value.\n     *\/\n    public static function before(string $subject, string $search): string\n    {\n        return $search === '' ? $subject : explode($search, $subject)[0];\n    }\n\n    \/**\n     * Cleans up a Text::insert() formatted string with given $options depending on the 'clean' key in\n     * $options. The default method used is text but html is also available. The goal of this function\n     * is to replace all whitespace and unneeded markup around placeholders that did not get replaced\n     * by Text::insert().\n     *\n     * @param string $str     String to clean.\n     * @param array  $options Options list.\n     *\/\n    public static function cleanInsert(string $str, array $options): string\n    {\n        $clean = $options['clean'];\n        if (! $clean) {\n            return $str;\n        }\n        if ($clean === true) {\n            $clean = ['method' => 'text'];\n        }\n        if (! is_array($clean)) {\n            $clean = ['method' => $options['clean']];\n        }\n\n        switch ($clean['method']) {\n            case 'html':\n                $clean += [\n                    'word'        => '[\\w,.]+',\n                    'andText'     => true,\n                    'replacement' => '',\n                ];\n                $kleenex = sprintf(\n                    '\/[\\s]*[a-z]+=(\")(%s%s%s[\\s]*)+\\\\1\/i',\n                    preg_quote($options['before'], '\/'),\n                    $clean['word'],\n                    preg_quote($options['after'], '\/')\n                );\n                $str = preg_replace($kleenex, $clean['replacement'], $str);\n                if ($clean['andText']) {\n                    $options['clean'] = ['method' => 'text'];\n                    $str              = static::cleanInsert($str, $options);\n                }\n                break;\n\n            case 'text':\n                $clean += [\n                    'word'        => '[\\w,.]+',\n                    'gap'         => '[\\s]*(?:(?:and|or)[\\s]*)?',\n                    'replacement' => '',\n                ];\n\n                $kleenex = sprintf(\n                    '\/(%s%s%s%s|%s%s%s%s)\/',\n                    preg_quote($options['before'], '\/'),\n                    $clean['word'],\n                    preg_quote($options['after'], '\/'),\n                    $clean['gap'],\n                    $clean['gap'],\n                    preg_quote($options['before'], '\/'),\n                    $clean['word'],\n                    preg_quote($options['after'], '\/')\n                );\n                $str = preg_replace($kleenex, $clean['replacement'], $str);\n                break;\n        }\n\n        return $str;\n    }\n\n    \/**\n     * Clean UTF-8 strings\n     *\n     * Ensures strings contain only valid UTF-8 characters.\n     *\n     * @param string $str String to clean\n     *\n     * @return string\n     *\/\n    public static function cleanStr(string $str, string $charset = 'UTF-8')\n    {\n        if (self::isAscii($str) === false) {\n            if (MB_ENABLED) {\n                $str = mb_convert_encoding($str, 'UTF-8', 'UTF-8');\n            } elseif (ICONV_ENABLED) {\n                $str = @iconv('UTF-8', 'UTF-8\/\/IGNORE', $str);\n            }\n        }\n\n        return $str;\n    }\n\n    \/**\n     * Determine if a given string contains a given substring.\n     *\n     * @param array|string $needles\n     *\/\n    public static function contains(string $haystack, $needles): bool\n    {\n        foreach ((array) $needles as $needle) {\n            if ($needle !== '' && mb_strpos($haystack, $needle) !== false) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    \/**\n     * Determine if a given string contains all array values.\n     *\/\n    public static function containsAll(string $haystack, array $needles): bool\n    {\n        foreach ($needles as $needle) {\n            if (! static::contains($haystack, $needle)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    \/**\n     * Convert to UTF-8\n     *\n     * Attempts to convert a string to UTF-8.\n     *\n     * @param string $str      Input string\n     * @param string $encoding Input encoding\n     *\n     * @return false|string $str encoded in UTF-8 or FALSE on failure\n     *\/\n    public static function toUTF8($str, $encoding)\n    {\n        if (MB_ENABLED) {\n            return mb_convert_encoding($str, 'UTF-8', $encoding);\n        }\n        if (ICONV_ENABLED) {\n            return @iconv($encoding, 'UTF-8', $str);\n        }\n\n        return false;\n    }\n\n    \/**\n     * Determine if a given string ends with a given substring.\n     *\n     * @param array|string $needles\n     *\/\n    public static function endsWith(string $haystack, $needles): bool\n    {\n        foreach ((array) $needles as $needle) {\n            if (substr($haystack, -strlen($needle)) === (string) $needle) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    \/**\n     * Extracts an excerpt from the text surrounding the phrase with a number of characters on each side\n     * determined by radius.\n     *\n     * @param string $text     String to search the phrase in\n     * @param string $phrase   Phrase that will be searched for\n     * @param int    $radius   The amount of characters that will be returned on each side of the founded phrase\n     * @param string $ellipsis Ending that will be appended\n     *\n     * @return string Modified string\n     *\/\n    public static function excerpt(string $text, string $phrase, int $radius = 100, string $ellipsis = '...'): string\n    {\n        if (empty($text) || empty($phrase)) {\n            return static::truncate($text, $radius * 2, ['ellipsis' => $ellipsis]);\n        }\n\n        $append = $prepend = $ellipsis;\n\n        $phraseLen = mb_strlen($phrase);\n        $textLen   = mb_strlen($text);\n\n        $pos = mb_stripos($text, $phrase);\n        if ($pos === false) {\n            return mb_substr($text, 0, $radius) . $ellipsis;\n        }\n\n        $startPos = $pos - $radius;\n        if ($startPos <= 0) {\n            $startPos = 0;\n            $prepend  = '';\n        }\n\n        $endPos = $pos + $phraseLen + $radius;\n        if ($endPos >= $textLen) {\n            $endPos = $textLen;\n            $append = '';\n        }\n\n        $excerpt = mb_substr($text, $startPos, $endPos - $startPos);\n        $excerpt = $prepend . $excerpt . $append;\n\n        return $excerpt;\n    }\n\n    \/**\n     * Cap a string with a single instance of a given value.\n     *\/\n    public static function finish(string $value, string $cap): string\n    {\n        $quoted = preg_quote($cap, '\/');\n\n        return preg_replace('\/(?:' . $quoted . ')+$\/u', '', $value) . $cap;\n    }\n\n    \/**\n     * Highlights a given phrase in a text. You can specify any expression in highlighter that\n     * may include the \\1 expression to include the $phrase found.\n     *\n     * ### Options:\n     *\n     * - `format` The piece of HTML with that the phrase will be highlighted\n     * - `html` If true, will ignore any HTML tags, ensuring that only the correct text is highlighted\n     * - `regex` A custom regex rule that is used to match words, default is '|$tag|iu'\n     * - `limit` A limit, optional, defaults to -1 (none)\n     *\n     * @param string       $text    Text to search the phrase in.\n     * @param array|string $phrase  The phrase or phrases that will be searched.\n     * @param array        $options An array of HTML attributes and options.\n     *\n     * @return string The highlighted text\n     *\/\n    public static function highlight(string $text, $phrase, array $options = [])\n    {\n        if (empty($phrase)) {\n            return $text;\n        }\n\n        $defaults = [\n            'format' => '<span class=\"highlight\">\\1<\/span>',\n            'html'   => false,\n            'regex'  => '|%s|iu',\n            'limit'  => -1,\n        ];\n        $options += $defaults;\n\n        $html = $format = $limit = null;\n        \/**\n         * @var bool         $html\n         * @var array|string $format\n         * @var int          $limit\n         *\/\n        extract($options);\n\n        if (is_array($phrase)) {\n            $replace = [];\n            $with    = [];\n\n            foreach ($phrase as $key => $segment) {\n                $segment = '(' . preg_quote($segment, '|') . ')';\n                if ($html) {\n                    $segment = \"(?![^<]+>){$segment}(?![^<]+>)\";\n                }\n\n                $with[]    = is_array($format) ? $format[$key] : $format;\n                $replace[] = sprintf($options['regex'], $segment);\n            }\n\n            return preg_replace($replace, $with, $text, $limit);\n        }\n\n        $phrase = '(' . preg_quote($phrase, '|') . ')';\n        if ($html) {\n            $phrase = \"(?![^<]+>){$phrase}(?![^<]+>)\";\n        }\n\n        return preg_replace(sprintf($options['regex'], $phrase), $format, $text, $limit);\n    }\n\n    \/**\n     * Replaces variable placeholders inside a $str with any given $data. Each key in the $data array\n     * corresponds to a variable placeholder name in $str.\n     * Example:\n     * ```\n     * Str::insert(':name is :age years old.', ['name' => 'Bob', 'age' => '65']);\n     * ```\n     * Returns: Bob is 65 years old.\n     *\n     * Available $options are:\n     *\n     * - before: The character or string in front of the name of the variable placeholder (Defaults to `:`)\n     * - after: The character or string after the name of the variable placeholder (Defaults to null)\n     * - escape: The character or string used to escape the before character \/ string (Defaults to `\\`)\n     * - format: A regex to use for matching variable placeholders. Default is: `\/(?<!\\\\)\\:%s\/`\n     *   (Overwrites before, after, breaks escape \/ clean)\n     * - clean: A boolean or array with instructions for Text::cleanInsert\n     *\n     * @param string $str     A string containing variable placeholders\n     * @param array  $data    A key => val array where each key stands for a placeholder variable name\n     *                        to be replaced with val\n     * @param array  $options An array of options, see description above\n     *\/\n    public static function insert(string $str, $data, array $options = []): string\n    {\n        $defaults = [\n            'before' => ':', 'after' => null, 'escape' => '\\\\', 'format' => null, 'clean' => false,\n        ];\n        $options += $defaults;\n        $format = $options['format'];\n        $data   = (array) $data;\n        if (empty($data)) {\n            return $options['clean'] ? static::cleanInsert($str, $options) : $str;\n        }\n\n        if (! isset($format)) {\n            $format = sprintf(\n                '\/(?<!%s)%s%%s%s\/',\n                preg_quote($options['escape'], '\/'),\n                str_replace('%', '%%', preg_quote($options['before'], '\/')),\n                str_replace('%', '%%', preg_quote($options['after'], '\/'))\n            );\n        }\n\n        if (strpos($str, '?') !== false && is_numeric(key($data))) {\n            $offset = 0;\n\n            while (($pos = strpos($str, '?', $offset)) !== false) {\n                $val    = array_shift($data);\n                $offset = $pos + strlen($val);\n                $str    = substr_replace($str, $val, $pos, 1);\n            }\n\n            return $options['clean'] ? static::cleanInsert($str, $options) : $str;\n        }\n\n        $dataKeys = array_keys($data);\n        $hashKeys = array_map('crc32', $dataKeys);\n        $tempData = array_combine($dataKeys, $hashKeys);\n        krsort($tempData);\n\n        foreach ($tempData as $key => $hashVal) {\n            $key = sprintf($format, preg_quote($key, '\/'));\n            $str = preg_replace($key, $hashVal, $str);\n        }\n        $dataReplacements = array_combine($hashKeys, array_values($data));\n\n        foreach ($dataReplacements as $tmpHash => $tmpValue) {\n            $tmpValue = is_array($tmpValue) ? '' : $tmpValue;\n            $str      = str_replace($tmpHash, $tmpValue, $str);\n        }\n\n        if (! isset($options['format']) && isset($options['before'])) {\n            $str = str_replace($options['escape'] . $options['before'], $options['before'], $str);\n        }\n\n        return $options['clean'] ? static::cleanInsert($str, $options) : $str;\n    }\n\n    \/**\n     * Determine if a given string matches a given pattern.\n     *\n     * @param array|string $pattern\n     *\/\n    public static function is(string $pattern, string $value): bool\n    {\n        $patterns = Arr::wrap($pattern);\n\n        if (empty($patterns)) {\n            return false;\n        }\n\n        foreach ($patterns as $pattern) {\n            \/\/ If the given value is an exact match we can of course return true right\n            \/\/ from the beginning. Otherwise, we will translate asterisks and do an\n            \/\/ actual pattern match against the two strings to see if they match.\n            if ($pattern === $value) {\n                return true;\n            }\n\n            $pattern = preg_quote($pattern, '#');\n\n            \/\/ Asterisks are translated into zero-or-more regular expression wildcards\n            \/\/ to make it convenient to check if the strings starts with the given\n            \/\/ pattern such as \"library\/*\", making any string check convenient.\n            $pattern = str_replace('\\*', '.*', $pattern);\n\n            if (preg_match('#^' . $pattern . '\\z#u', $value) === 1) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    \/**\n     * Is ASCII?\n     *\n     * Tests if a string is standard 7-bit ASCII or not.\n     *\n     * @param string $str String to check\n     *\/\n    public static function isAscii(string $str): bool\n    {\n        return preg_match('\/[^\\x00-\\x7F]\/S', $str) === 0;\n    }\n\n    \/**\n     * Return the length of the given string.\n     *\/\n    public static function length(string $value, ?string $encoding = null): int\n    {\n        if ($encoding) {\n            return mb_strlen($value, $encoding);\n        }\n\n        return mb_strlen($value);\n    }\n\n    \/**\n     * Limit the number of characters in a string.\n     *\/\n    public static function limit(string $value, int $limit = 100, string $end = '...'): string\n    {\n        if (mb_strwidth($value, 'UTF-8') <= $limit) {\n            return $value;\n        }\n\n        return rtrim(mb_strimwidth($value, 0, $limit, '', 'UTF-8')) . $end;\n    }\n\n    \/**\n     * Convert the given string to lower-case.\n     *\/\n    public static function lower(string $value): string\n    {\n        return mb_strtolower($value, 'UTF-8');\n    }\n\n    \/**\n     * Parse a Class@method style callback into class and method.\n     *\/\n    public static function parseCallback(string $callback, ?string $default = null): array\n    {\n        return static::contains($callback, '@') ? explode('@', $callback, 2) : [$callback, $default];\n    }\n\n    \/**\n     * Generate a more truly \"random\" alpha-numeric string.\n     *\/\n    public static function random(int $length = 16): string\n    {\n        $string = '';\n\n        while (($len = strlen($string)) < $length) {\n            $size = $length - $len;\n\n            $bytes = random_bytes($size);\n\n            $string .= substr(str_replace(['\/', '+', '='], '', base64_encode($bytes)), 0, $size);\n        }\n\n        return $string;\n    }\n\n    \/**\n     * Removes the last word from the input text.\n     *\n     * @param string $text The input text\n     *\/\n    public static function removeLastWord(string $text): string\n    {\n        $spacepos = mb_strrpos($text, ' ');\n        if ($spacepos !== false) {\n            $lastWord = mb_strrpos($text, $spacepos);\n\n            \/\/ Some languages are written without word separation.\n            \/\/ We recognize a string as a word if it doesn't contain any full-width characters.\n            if (mb_strwidth($lastWord) === mb_strlen($lastWord)) {\n                $text = mb_substr($text, 0, $spacepos);\n            }\n\n            return $text;\n        }\n\n        return '';\n    }\n\n    \/**\n     * Replace a given value in the string sequentially with an array.\n     *\/\n    public static function replaceArray(string $search, array $replace, string $subject): string\n    {\n        $segments = explode($search, $subject);\n\n        $result = array_shift($segments);\n\n        foreach ($segments as $segment) {\n            $result .= (array_shift($replace) ?? $search) . $segment;\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Replace the first occurrence of a given value in the string.\n     *\/\n    public static function replaceFirst(string $search, string $replace, string $subject): string\n    {\n        if ($search === '') {\n            return $subject;\n        }\n\n        $position = strpos($subject, $search);\n\n        if ($position !== false) {\n            return substr_replace($subject, $replace, $position, strlen($search));\n        }\n\n        return $subject;\n    }\n\n    \/**\n     * Replace the last occurrence of a given value in the string.\n     *\/\n    public static function replaceLast(string $search, string $replace, string $subject): string\n    {\n        $position = strrpos($subject, $search);\n\n        if ($position !== false) {\n            return substr_replace($subject, $replace, $position, strlen($search));\n        }\n\n        return $subject;\n    }\n\n    \/**\n     * Remove ASCII control characters\n     *\n     * Removes all ASCII control characters except horizontal tabs,\n     * line feeds, and carriage returns, as all others can cause\n     * problems in XML.\n     *\/\n    public function safeAsciiForXml(string $str): string\n    {\n        return Helpers::removeInvisibleCharacters($str, false);\n    }\n\n    \/**\n     * Returns a string with all spaces converted to dashes (by default),\n     * characters transliterated to ASCII characters, and non word characters removed.\n     *\n     * ### Options:\n     *\n     * - `replacement`: Replacement string. Default '-'.\n     * - `transliteratorId`: A valid transliterator id string.\n     *   If `null` (default) the transliterator (identifier) set via\n     *   `setTransliteratorId()` or `setTransliterator()` will be used.\n     *   If `false` no transliteration will be done, only non words will be removed.\n     * - `preserve`: Specific non-word character to preserve. Default `null`.\n     *   For e.g. this option can be set to '.' to generate clean file names.\n     *\n     * @param string $string  the string you want to slug\n     * @param array  $options If string it will be use as replacement character\n     *                        or an array of options.\n     *\n     * @see setTransliterator()\n     * @see setTransliteratorId()\n     *\/\n    public static function slug(string $string, array $options = []): string\n    {\n        if (is_string($options)) {\n            $options = ['replacement' => $options];\n        }\n        $options += [\n            'replacement'      => '-',\n            'transliteratorId' => null,\n            'preserve'         => null,\n        ];\n\n        if ($options['transliteratorId'] !== false) {\n            $string = static::transliterate($string, $options['transliteratorId']);\n        }\n\n        $regex = '^\\p{Ll}\\p{Lm}\\p{Lo}\\p{Lt}\\p{Lu}\\p{Nd}';\n        if ($options['preserve']) {\n            $regex .= preg_quote($options['preserve'], '\/');\n        }\n        $quotedReplacement = preg_quote($options['replacement'], '\/');\n        $map               = [\n            '\/[' . $regex . ']\/mu' => $options['replacement'],\n            sprintf('\/^[%s]+|[%s]+$\/', $quotedReplacement, $quotedReplacement) => '',\n        ];\n        if (is_string($options['replacement']) && $options['replacement'] !== '') {\n            $map[sprintf('\/[%s]+\/mu', $quotedReplacement)] = $options['replacement'];\n        }\n        $string = preg_replace(array_keys($map), $map, $string);\n\n        return $string;\n    }\n\n    \/**\n     * Begin a string with a single instance of a given value.\n     *\/\n    public static function start(string $value, string $prefix): string\n    {\n        $quoted = preg_quote($prefix, '\/');\n\n        return $prefix . preg_replace('\/^(?:' . $quoted . ')+\/u', '', $value);\n    }\n\n    \/**\n     * Determine if a given string starts with a given substring.\n     *\n     * @param array|string $needles\n     *\/\n    public static function startsWith(string $haystack, $needles): bool\n    {\n        foreach ((array) $needles as $needle) {\n            if ($needle !== '' && substr($haystack, 0, strlen($needle)) === (string) $needle) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    \/**\n     * Get string length.\n     *\n     * ### Options:\n     *\n     * - `html` If true, HTML entities will be handled as decoded characters.\n     * - `trimWidth` If true, the width will return.\n     *\n     * @param string $text    The string being checked for length\n     * @param array  $options An array of options.\n     *\/\n    public static function strlen(string $text, array $options): int\n    {\n        if (empty($options['trimWidth'])) {\n            $strlen = 'mb_strlen';\n        } else {\n            $strlen = 'mb_strwidth';\n        }\n\n        if (empty($options['html'])) {\n            return $strlen($text);\n        }\n\n        $pattern = '\/&[0-9a-z]{2,8};|&#[0-9]{1,7};|&#x[0-9a-f]{1,6};\/i';\n        $replace = preg_replace_callback(\n            $pattern,\n            static function ($match) use ($strlen) {\n                $utf8 = html_entity_decode($match[0], ENT_HTML5 | ENT_QUOTES, 'UTF-8');\n\n                return str_repeat(' ', $strlen($utf8, 'UTF-8'));\n            },\n            $text\n        );\n\n        return $strlen($replace);\n    }\n\n    \/**\n     * Returns the portion of string specified by the start and length parameters.\n     *\n     * ### Options:\n     *\n     * - `html` If true, HTML entities will be handled as decoded characters.\n     * - `trimWidth` If true, will be truncated with specified width.\n     *\/\n    protected static function substr(string $text, int $start, ?int $length = null, array $options = []): string\n    {\n        if (empty($options['trimWidth'])) {\n            $substr = 'mb_substr';\n        } else {\n            $substr = 'mb_strimwidth';\n        }\n\n        $maxPosition = self::strlen($text, ['trimWidth' => false] + $options);\n        if ($start < 0) {\n            $start += $maxPosition;\n            if ($start < 0) {\n                $start = 0;\n            }\n        }\n        if ($start >= $maxPosition) {\n            return '';\n        }\n\n        if ($length === null) {\n            $length = self::strlen($text, $options);\n        }\n\n        if ($length < 0) {\n            $text  = self::substr($text, $start, null, $options);\n            $start = 0;\n            $length += self::strlen($text, $options);\n        }\n\n        if ($length <= 0) {\n            return '';\n        }\n\n        if (empty($options['html'])) {\n            return (string) $substr($text, $start, $length);\n        }\n\n        $totalOffset = 0;\n        $totalLength = 0;\n        $result      = '';\n\n        $pattern = '\/(&[0-9a-z]{2,8};|&#[0-9]{1,7};|&#x[0-9a-f]{1,6};)\/i';\n        $parts   = preg_split($pattern, $text, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);\n\n        foreach ($parts as $part) {\n            $offset = 0;\n\n            if ($totalOffset < $start) {\n                $len = self::strlen($part, ['trimWidth' => false] + $options);\n                if ($totalOffset + $len <= $start) {\n                    $totalOffset += $len;\n\n                    continue;\n                }\n\n                $offset      = $start - $totalOffset;\n                $totalOffset = $start;\n            }\n\n            $len = self::strlen($part, $options);\n            if ($offset !== 0 || $totalLength + $len > $length) {\n                if (\n                    strpos($part, '&') === 0 && preg_match($pattern, $part)\n                    && $part !== html_entity_decode($part, ENT_HTML5 | ENT_QUOTES, 'UTF-8')\n                ) {\n                    \/\/ Entities cannot be passed substr.\n                    continue;\n                }\n\n                $part = $substr($part, $offset, $length - $totalLength);\n                $len  = self::strlen($part, $options);\n            }\n\n            $result .= $part;\n            $totalLength += $len;\n            if ($totalLength >= $length) {\n                break;\n            }\n        }\n\n        return $result;\n    }\n\n    \/**\n     * Truncates text starting from the end.\n     *\n     * Cuts a string to the length of $length and replaces the first characters\n     * with the ellipsis if the text is longer than length.\n     *\n     * ### Options:\n     *\n     * - `ellipsis` Will be used as beginning and prepended to the trimmed string\n     * - `exact` If false, $text will not be cut mid-word\n     *\n     * @param string $text    String to truncate.\n     * @param int    $length  Length of returned string, including ellipsis.\n     * @param array  $options An array of options.\n     *\n     * @return string Trimmed string.\n     *\/\n    public static function tail(string $text, int $length = 100, array $options = []): string\n    {\n        $default = [\n            'ellipsis' => '...', 'exact' => true,\n        ];\n        $options += $default;\n        $exact = $ellipsis = null;\n        \/**\n         * @var string $ellipsis\n         * @var bool   $exact\n         *\/\n        extract($options);\n\n        if (mb_strlen($text) <= $length) {\n            return $text;\n        }\n\n        $truncate = mb_substr($text, mb_strlen($text) - $length + mb_strlen($ellipsis));\n        if (! $exact) {\n            $spacepos = mb_strpos($truncate, ' ');\n            $truncate = $spacepos === false ? '' : trim(mb_substr($truncate, $spacepos));\n        }\n\n        return $ellipsis . $truncate;\n    }\n\n    \/**\n     * Convert the given string to title case.\n     *\/\n    public static function title(string $value): string\n    {\n        return mb_convert_case($value, MB_CASE_TITLE, 'UTF-8');\n    }\n\n    \/**\n     * Tokenizes a string using $separator, ignoring any instance of $separator that appears between\n     * $leftBound and $rightBound.\n     *\n     * @param string $data       The data to tokenize.\n     * @param string $separator  The token to split the data on.\n     * @param string $leftBound  The left boundary to ignore separators in.\n     * @param string $rightBound The right boundary to ignore separators in.\n     *\n     * @return mixed Array of tokens in $data or original input if empty.\n     *\/\n    public static function tokenize(string $data, string $separator = ',', string $leftBound = '(', string $rightBound = ')')\n    {\n        if (empty($data)) {\n            return [];\n        }\n\n        $depth   = 0;\n        $offset  = 0;\n        $buffer  = '';\n        $results = [];\n        $length  = strlen($data);\n        $open    = false;\n\n        while ($offset <= $length) {\n            $tmpOffset = -1;\n            $offsets   = [\n                strpos($data, $separator, $offset),\n                strpos($data, $leftBound, $offset),\n                strpos($data, $rightBound, $offset),\n            ];\n\n            for ($i = 0; $i < 3; $i++) {\n                if ($offsets[$i] !== false && ($offsets[$i] < $tmpOffset || $tmpOffset === -1)) {\n                    $tmpOffset = $offsets[$i];\n                }\n            }\n            if ($tmpOffset !== -1) {\n                $buffer .= substr($data, $offset, ($tmpOffset - $offset));\n                if (! $depth && $data[$tmpOffset] === $separator) {\n                    $results[] = $buffer;\n                    $buffer    = '';\n                } else {\n                    $buffer .= $data[$tmpOffset];\n                }\n                if ($leftBound !== $rightBound) {\n                    if ($data[$tmpOffset] === $leftBound) {\n                        $depth++;\n                    }\n                    if ($data[$tmpOffset] === $rightBound) {\n                        $depth--;\n                    }\n                } else {\n                    if ($data[$tmpOffset] === $leftBound) {\n                        if (! $open) {\n                            $depth++;\n                            $open = true;\n                        } else {\n                            $depth--;\n                        }\n                    }\n                }\n                $offset = ++$tmpOffset;\n            } else {\n                $results[] = $buffer . substr($data, $offset);\n                $offset    = $length + 1;\n            }\n        }\n        if (empty($results) && ! empty($buffer)) {\n            $results[] = $buffer;\n        }\n\n        if (! empty($results)) {\n            return array_map('trim', $results);\n        }\n\n        return [];\n    }\n\n    \/**\n     * Creates a comma separated list where the last two items are joined with 'and', forming natural language.\n     *\n     * @param string[] $list      The list to be joined.\n     * @param string   $separator The separator used to join all the other items together. Defaults to ', '.\n     * @param string   $and       The word used to join the last and second last items together with. Defaults to 'and'.\n     *\n     * @return string The glued together string.\n     *\/\n    public static function toList(array $list, string $separator = ', ', string $and = 'and')\n    {\n        if (count($list) > 1) {\n            return implode($separator, array_slice($list, 0, -1)) . ' ' . $and . ' ' . array_pop($list);\n        }\n\n        return array_pop($list);\n    }\n\n    \/**\n     * Transliterate string.\n     *\n     * @param string                     $string         String to transliterate.\n     * @param string|Transliterator|null $transliterator Either a Transliterator\n     *                                                   instance, or a transliterator identifier string. If `null`, the default\n     *                                                   transliterator (identifier) set via `setTransliteratorId()` or\n     *                                                   `setTransliterator()` will be used.\n     *\n     * @return string\n     *\n     * @see https:\/\/secure.php.net\/manual\/en\/transliterator.transliterate.php\n     *\/\n    public static function transliterate(string $string, $transliterator = null)\n    {\n        if (! $transliterator) {\n            $transliterator = static::$_defaultTransliterator ?: static::$_defaultTransliteratorId;\n        }\n\n        return transliterator_transliterate($transliterator, $string);\n    }\n\n    \/**\n     * Truncates text.\n     *\n     * Cuts a string to the length of $length and replaces the last characters\n     * with the ellipsis if the text is longer than length.\n     *\n     * ### Options:\n     *\n     * - `ellipsis` Will be used as ending and appended to the trimmed string\n     * - `exact` If false, $text will not be cut mid-word\n     * - `html` If true, HTML tags would be handled correctly\n     * - `trimWidth` If true, $text will be truncated with the width\n     *\n     * @param string $text    String to truncate.\n     * @param int    $length  Length of returned string, including ellipsis.\n     * @param array  $options An array of HTML attributes and options.\n     *\n     * @return string Trimmed string.\n     *\/\n    public static function truncate(string $text, int $length = 100, array $options = []): string\n    {\n        $default = [\n            'ellipsis' => '...', 'exact' => true, 'html' => false, 'trimWidth' => false,\n        ];\n        if (! empty($options['html']) && strtolower(mb_internal_encoding()) === 'utf-8') {\n            $default['ellipsis'] = \"\\xe2\\x80\\xa6\";\n        }\n        $options += $default;\n\n        $prefix = '';\n        $suffix = $options['ellipsis'];\n\n        if ($options['html']) {\n            $ellipsisLength = self::strlen(strip_tags($options['ellipsis']), $options);\n\n            $truncateLength = 0;\n            $totalLength    = 0;\n            $openTags       = [];\n            $truncate       = '';\n\n            preg_match_all('\/(<\\\/?([\\w+]+)[^>]*>)?([^<>]*)\/', $text, $tags, PREG_SET_ORDER);\n\n            foreach ($tags as $tag) {\n                $contentLength = 0;\n                if (! in_array($tag[2], static::$_defaultHtmlNoCount, true)) {\n                    $contentLength = self::strlen($tag[3], $options);\n                }\n\n                if ($truncate === '') {\n                    if (! preg_match('\/img|br|input|hr|area|base|basefont|col|frame|isindex|link|meta|param\/i', $tag[2])) {\n                        if (preg_match('\/<[\\w]+[^>]*>\/', $tag[0])) {\n                            array_unshift($openTags, $tag[2]);\n                        } elseif (preg_match('\/<\\\/([\\w]+)[^>]*>\/', $tag[0], $closeTag)) {\n                            $pos = array_search($closeTag[1], $openTags, true);\n                            if ($pos !== false) {\n                                array_splice($openTags, $pos, 1);\n                            }\n                        }\n                    }\n\n                    $prefix .= $tag[1];\n\n                    if ($totalLength + $contentLength + $ellipsisLength > $length) {\n                        $truncate       = $tag[3];\n                        $truncateLength = $length - $totalLength;\n                    } else {\n                        $prefix .= $tag[3];\n                    }\n                }\n\n                $totalLength += $contentLength;\n                if ($totalLength > $length) {\n                    break;\n                }\n            }\n\n            if ($totalLength <= $length) {\n                return $text;\n            }\n\n            $text   = $truncate;\n            $length = $truncateLength;\n\n            foreach ($openTags as $tag) {\n                $suffix .= '<\/' . $tag . '>';\n            }\n        } else {\n            if (self::strlen($text, $options) <= $length) {\n                return $text;\n            }\n            $ellipsisLength = self::strlen($options['ellipsis'], $options);\n        }\n\n        $result = self::substr($text, 0, $length - $ellipsisLength, $options);\n\n        if (! $options['exact']) {\n            if (self::substr($text, $length - $ellipsisLength, 1, $options) !== ' ') {\n                $result = self::removeLastWord($result);\n            }\n\n            \/\/ If result is empty, then we don't need to count ellipsis in the cut.\n            if (! strlen($result)) {\n                $result = self::substr($text, 0, $length, $options);\n            }\n        }\n\n        return $prefix . $result . $suffix;\n    }\n\n    \/**\n     * Mettez le premier caract\u00e8re d'une cha\u00eene en majuscule.\n     *\/\n    public static function ucfirst(string $string): string\n    {\n        return static::upper(static::substr($string, 0, 1)) . static::substr($string, 1);\n    }\n\n    \/**\n     * Convertit la cha\u00eene donn\u00e9e en majuscule.\n     *\/\n    public static function upper(string $value, string $encoding = 'UTF-8'): string\n    {\n        return mb_strtoupper($value, $encoding);\n    }\n\n    \/**\n     * Limit the number of words in a string.\n     *\/\n    public static function words(string $value, int $words = 100, string $end = '...'): string\n    {\n        preg_match('\/^\\s*+(?:\\S++\\s*+){1,' . $words . '}\/u', $value, $matches);\n\n        if (! isset($matches[0]) || static::length($value) === static::length($matches[0])) {\n            return $value;\n        }\n\n        return rtrim($matches[0]) . $end;\n    }\n\n    \/**\n     * Returns the replacements for the ascii method.\n     *\n     * Note: Adapted from Stringy\\Stringy.\n     *\n     * @see https:\/\/github.com\/danielstjules\/Stringy\/blob\/3.1.0\/LICENSE.txt\n     *\/\n    protected static function charsArray(): array\n    {\n        static $charsArray;\n\n        if (isset($charsArray)) {\n            return $charsArray;\n        }\n\n        return $charsArray = [\n            '0'    => ['\u00b0', '\u2080', '\u06f0', '\uff10'],\n            '1'    => ['\u00b9', '\u2081', '\u06f1', '\uff11'],\n            '2'    => ['\u00b2', '\u2082', '\u06f2', '\uff12'],\n            '3'    => ['\u00b3', '\u2083', '\u06f3', '\uff13'],\n            '4'    => ['\u2074', '\u2084', '\u06f4', '\u0664', '\uff14'],\n            '5'    => ['\u2075', '\u2085', '\u06f5', '\u0665', '\uff15'],\n            '6'    => ['\u2076', '\u2086', '\u06f6', '\u0666', '\uff16'],\n            '7'    => ['\u2077', '\u2087', '\u06f7', '\uff17'],\n            '8'    => ['\u2078', '\u2088', '\u06f8', '\uff18'],\n            '9'    => ['\u2079', '\u2089', '\u06f9', '\uff19'],\n            'a'    => ['\u00e0', '\u00e1', '\u1ea3', '\u00e3', '\u1ea1', '\u0103', '\u1eaf', '\u1eb1', '\u1eb3', '\u1eb5', '\u1eb7', '\u00e2', '\u1ea5', '\u1ea7', '\u1ea9', '\u1eab', '\u1ead', '\u0101', '\u0105', '\u00e5', '\u03b1', '\u03ac', '\u1f00', '\u1f01', '\u1f02', '\u1f03', '\u1f04', '\u1f05', '\u1f06', '\u1f07', '\u1f80', '\u1f81', '\u1f82', '\u1f83', '\u1f84', '\u1f85', '\u1f86', '\u1f87', '\u1f70', '\u03ac', '\u1fb0', '\u1fb1', '\u1fb2', '\u1fb3', '\u1fb4', '\u1fb6', '\u1fb7', '\u0430', '\u0623', '\u1021', '\u102c', '\u102b', '\u01fb', '\u01ce', '\u00aa', '\u10d0', '\u0905', '\u0627', '\uff41', '\u00e4', '\u05d0'],\n            'b'    => ['\u0431', '\u03b2', '\u0628', '\u1017', '\u10d1', '\uff42', '\u05d1'],\n            'c'    => ['\u00e7', '\u0107', '\u010d', '\u0109', '\u010b', '\uff43'],\n            'd'    => ['\u010f', '\u00f0', '\u0111', '\u018c', '\u0221', '\u0256', '\u0257', '\u1d6d', '\u1d81', '\u1d91', '\u0434', '\u03b4', '\u062f', '\u0636', '\u100d', '\u1012', '\u10d3', '\uff44', '\u05d3'],\n            'e'    => ['\u00e9', '\u00e8', '\u1ebb', '\u1ebd', '\u1eb9', '\u00ea', '\u1ebf', '\u1ec1', '\u1ec3', '\u1ec5', '\u1ec7', '\u00eb', '\u0113', '\u0119', '\u011b', '\u0115', '\u0117', '\u03b5', '\u03ad', '\u1f10', '\u1f11', '\u1f12', '\u1f13', '\u1f14', '\u1f15', '\u1f72', '\u03ad', '\u0435', '\u0451', '\u044d', '\u0454', '\u0259', '\u1027', '\u1031', '\u1032', '\u10d4', '\u090f', '\u0625', '\u0626', '\uff45'],\n            'f'    => ['\u0444', '\u03c6', '\u0641', '\u0192', '\u10e4', '\uff46', '\u05e4', '\u05e3'],\n            'g'    => ['\u011d', '\u011f', '\u0121', '\u0123', '\u0433', '\u0491', '\u03b3', '\u1002', '\u10d2', '\u06af', '\uff47', '\u05d2'],\n            'h'    => ['\u0125', '\u0127', '\u03b7', '\u03ae', '\u062d', '\u0647', '\u101f', '\u103e', '\u10f0', '\uff48', '\u05d4'],\n            'i'    => ['\u00ed', '\u00ec', '\u1ec9', '\u0129', '\u1ecb', '\u00ee', '\u00ef', '\u012b', '\u012d', '\u012f', '\u0131', '\u03b9', '\u03af', '\u03ca', '\u0390', '\u1f30', '\u1f31', '\u1f32', '\u1f33', '\u1f34', '\u1f35', '\u1f36', '\u1f37', '\u1f76', '\u03af', '\u1fd0', '\u1fd1', '\u1fd2', '\u0390', '\u1fd6', '\u1fd7', '\u0456', '\u0457', '\u0438', '\u1023', '\u102d', '\u102e', '\u100a\u103a', '\u01d0', '\u10d8', '\u0907', '\u06cc', '\uff49', '\u05d9'],\n            'j'    => ['\u0135', '\u0458', '\u0408', '\u10ef', '\u062c', '\uff4a'],\n            'k'    => ['\u0137', '\u0138', '\u043a', '\u03ba', '\u0136', '\u0642', '\u0643', '\u1000', '\u10d9', '\u10e5', '\u06a9', '\uff4b', '\u05e7'],\n            'l'    => ['\u0142', '\u013e', '\u013a', '\u013c', '\u0140', '\u043b', '\u03bb', '\u0644', '\u101c', '\u10da', '\uff4c', '\u05dc'],\n            'm'    => ['\u043c', '\u03bc', '\u0645', '\u1019', '\u10db', '\uff4d', '\u05de', '\u05dd'],\n            'n'    => ['\u00f1', '\u0144', '\u0148', '\u0146', '\u0149', '\u014b', '\u03bd', '\u043d', '\u0646', '\u1014', '\u10dc', '\uff4e', '\u05e0'],\n            'o'    => ['\u00f3', '\u00f2', '\u1ecf', '\u00f5', '\u1ecd', '\u00f4', '\u1ed1', '\u1ed3', '\u1ed5', '\u1ed7', '\u1ed9', '\u01a1', '\u1edb', '\u1edd', '\u1edf', '\u1ee1', '\u1ee3', '\u00f8', '\u014d', '\u0151', '\u014f', '\u03bf', '\u1f40', '\u1f41', '\u1f42', '\u1f43', '\u1f44', '\u1f45', '\u1f78', '\u03cc', '\u043e', '\u0648', '\u102d\u102f', '\u01d2', '\u01ff', '\u00ba', '\u10dd', '\u0913', '\uff4f', '\u00f6'],\n            'p'    => ['\u043f', '\u03c0', '\u1015', '\u10de', '\u067e', '\uff50', '\u05e4', '\u05e3'],\n            'q'    => ['\u10e7', '\uff51'],\n            'r'    => ['\u0155', '\u0159', '\u0157', '\u0440', '\u03c1', '\u0631', '\u10e0', '\uff52', '\u05e8'],\n            's'    => ['\u015b', '\u0161', '\u015f', '\u0441', '\u03c3', '\u0219', '\u03c2', '\u0633', '\u0635', '\u1005', '\u017f', '\u10e1', '\uff53', '\u05e1'],\n            't'    => ['\u0165', '\u0163', '\u0442', '\u03c4', '\u021b', '\u062a', '\u0637', '\u100b', '\u1010', '\u0167', '\u10d7', '\u10e2', '\uff54', '\u05ea'],\n            'u'    => ['\u00fa', '\u00f9', '\u1ee7', '\u0169', '\u1ee5', '\u01b0', '\u1ee9', '\u1eeb', '\u1eed', '\u1eef', '\u1ef1', '\u00fb', '\u016b', '\u016f', '\u0171', '\u016d', '\u0173', '\u00b5', '\u0443', '\u1009', '\u102f', '\u1030', '\u01d4', '\u01d6', '\u01d8', '\u01da', '\u01dc', '\u10e3', '\u0909', '\uff55', '\u045e', '\u00fc'],\n            'v'    => ['\u0432', '\u10d5', '\u03d0', '\uff56', '\u05d5'],\n            'w'    => ['\u0175', '\u03c9', '\u03ce', '\u101d', '\u103d', '\uff57'],\n            'x'    => ['\u03c7', '\u03be', '\uff58'],\n            'y'    => ['\u00fd', '\u1ef3', '\u1ef7', '\u1ef9', '\u1ef5', '\u00ff', '\u0177', '\u0439', '\u044b', '\u03c5', '\u03cb', '\u03cd', '\u03b0', '\u064a', '\u101a', '\uff59'],\n            'z'    => ['\u017a', '\u017e', '\u017c', '\u0437', '\u03b6', '\u0632', '\u1007', '\u10d6', '\uff5a', '\u05d6'],\n            'aa'   => ['\u0639', '\u0906', '\u0622'],\n            'ae'   => ['\u00e6', '\u01fd'],\n            'ai'   => ['\u0910'],\n            'ch'   => ['\u0447', '\u10e9', '\u10ed', '\u0686'],\n            'dj'   => ['\u0452', '\u0111'],\n            'dz'   => ['\u045f', '\u10eb', '\u05d3\u05d6'],\n            'ei'   => ['\u090d'],\n            'gh'   => ['\u063a', '\u10e6'],\n            'ii'   => ['\u0908'],\n            'ij'   => ['\u0133'],\n            'kh'   => ['\u0445', '\u062e', '\u10ee'],\n            'lj'   => ['\u0459'],\n            'nj'   => ['\u045a'],\n            'oe'   => ['\u00f6', '\u0153', '\u0624'],\n            'oi'   => ['\u0911'],\n            'oii'  => ['\u0912'],\n            'ps'   => ['\u03c8'],\n            'sh'   => ['\u0448', '\u10e8', '\u0634', '\u05e9'],\n            'shch' => ['\u0449'],\n            'ss'   => ['\u00df'],\n            'sx'   => ['\u015d'],\n            'th'   => ['\u00fe', '\u03d1', '\u03b8', '\u062b', '\u0630', '\u0638'],\n            'ts'   => ['\u0446', '\u10ea', '\u10ec'],\n            'ue'   => ['\u00fc'],\n            'uu'   => ['\u090a'],\n            'ya'   => ['\u044f'],\n            'yu'   => ['\u044e'],\n            'zh'   => ['\u0436', '\u10df', '\u0698'],\n            '(c)'  => ['\u00a9'],\n            'A'    => ['\u00c1', '\u00c0', '\u1ea2', '\u00c3', '\u1ea0', '\u0102', '\u1eae', '\u1eb0', '\u1eb2', '\u1eb4', '\u1eb6', '\u00c2', '\u1ea4', '\u1ea6', '\u1ea8', '\u1eaa', '\u1eac', '\u00c5', '\u0100', '\u0104', '\u0391', '\u0386', '\u1f08', '\u1f09', '\u1f0a', '\u1f0b', '\u1f0c', '\u1f0d', '\u1f0e', '\u1f0f', '\u1f88', '\u1f89', '\u1f8a', '\u1f8b', '\u1f8c', '\u1f8d', '\u1f8e', '\u1f8f', '\u1fb8', '\u1fb9', '\u1fba', '\u0386', '\u1fbc', '\u0410', '\u01fa', '\u01cd', '\uff21', '\u00c4'],\n            'B'    => ['\u0411', '\u0392', '\u092c', '\uff22'],\n            'C'    => ['\u00c7', '\u0106', '\u010c', '\u0108', '\u010a', '\uff23'],\n            'D'    => ['\u010e', '\u00d0', '\u0110', '\u0189', '\u018a', '\u018b', '\u1d05', '\u1d06', '\u0414', '\u0394', '\uff24'],\n            'E'    => ['\u00c9', '\u00c8', '\u1eba', '\u1ebc', '\u1eb8', '\u00ca', '\u1ebe', '\u1ec0', '\u1ec2', '\u1ec4', '\u1ec6', '\u00cb', '\u0112', '\u0118', '\u011a', '\u0114', '\u0116', '\u0395', '\u0388', '\u1f18', '\u1f19', '\u1f1a', '\u1f1b', '\u1f1c', '\u1f1d', '\u0388', '\u1fc8', '\u0415', '\u0401', '\u042d', '\u0404', '\u018f', '\uff25'],\n            'F'    => ['\u0424', '\u03a6', '\uff26'],\n            'G'    => ['\u011e', '\u0120', '\u0122', '\u0413', '\u0490', '\u0393', '\uff27'],\n            'H'    => ['\u0397', '\u0389', '\u0126', '\uff28'],\n            'I'    => ['\u00cd', '\u00cc', '\u1ec8', '\u0128', '\u1eca', '\u00ce', '\u00cf', '\u012a', '\u012c', '\u012e', '\u0130', '\u0399', '\u038a', '\u03aa', '\u1f38', '\u1f39', '\u1f3b', '\u1f3c', '\u1f3d', '\u1f3e', '\u1f3f', '\u1fd8', '\u1fd9', '\u1fda', '\u038a', '\u0418', '\u0406', '\u0407', '\u01cf', '\u03d2', '\uff29'],\n            'J'    => ['\uff2a'],\n            'K'    => ['\u041a', '\u039a', '\uff2b'],\n            'L'    => ['\u0139', '\u0141', '\u041b', '\u039b', '\u013b', '\u013d', '\u013f', '\u0932', '\uff2c'],\n            'M'    => ['\u041c', '\u039c', '\uff2d'],\n            'N'    => ['\u0143', '\u00d1', '\u0147', '\u0145', '\u014a', '\u041d', '\u039d', '\uff2e'],\n            'O'    => ['\u00d3', '\u00d2', '\u1ece', '\u00d5', '\u1ecc', '\u00d4', '\u1ed0', '\u1ed2', '\u1ed4', '\u1ed6', '\u1ed8', '\u01a0', '\u1eda', '\u1edc', '\u1ede', '\u1ee0', '\u1ee2', '\u00d8', '\u014c', '\u0150', '\u014e', '\u039f', '\u038c', '\u1f48', '\u1f49', '\u1f4a', '\u1f4b', '\u1f4c', '\u1f4d', '\u1ff8', '\u038c', '\u041e', '\u04e8', '\u01d1', '\u01fe', '\uff2f', '\u00d6'],\n            'P'    => ['\u041f', '\u03a0', '\uff30'],\n            'Q'    => ['\uff31'],\n            'R'    => ['\u0158', '\u0154', '\u0420', '\u03a1', '\u0156', '\uff32'],\n            'S'    => ['\u015e', '\u015c', '\u0218', '\u0160', '\u015a', '\u0421', '\u03a3', '\uff33'],\n            'T'    => ['\u0164', '\u0162', '\u0166', '\u021a', '\u0422', '\u03a4', '\uff34'],\n            'U'    => ['\u00da', '\u00d9', '\u1ee6', '\u0168', '\u1ee4', '\u01af', '\u1ee8', '\u1eea', '\u1eec', '\u1eee', '\u1ef0', '\u00db', '\u016a', '\u016e', '\u0170', '\u016c', '\u0172', '\u0423', '\u01d3', '\u01d5', '\u01d7', '\u01d9', '\u01db', '\uff35', '\u040e', '\u00dc'],\n            'V'    => ['\u0412', '\uff36'],\n            'W'    => ['\u03a9', '\u038f', '\u0174', '\uff37'],\n            'X'    => ['\u03a7', '\u039e', '\uff38'],\n            'Y'    => ['\u00dd', '\u1ef2', '\u1ef6', '\u1ef8', '\u1ef4', '\u0178', '\u1fe8', '\u1fe9', '\u1fea', '\u038e', '\u042b', '\u0419', '\u03a5', '\u03ab', '\u0176', '\uff39'],\n            'Z'    => ['\u0179', '\u017d', '\u017b', '\u0417', '\u0396', '\uff3a'],\n            'AE'   => ['\u00c6', '\u01fc'],\n            'Ch'   => ['\u0427'],\n            'Dj'   => ['\u0402'],\n            'Dz'   => ['\u040f'],\n            'Gx'   => ['\u011c'],\n            'Hx'   => ['\u0124'],\n            'Ij'   => ['\u0132'],\n            'Jx'   => ['\u0134'],\n            'Kh'   => ['\u0425'],\n            'Lj'   => ['\u0409'],\n            'Nj'   => ['\u040a'],\n            'Oe'   => ['\u0152'],\n            'Ps'   => ['\u03a8'],\n            'Sh'   => ['\u0428', '\u05e9'],\n            'Shch' => ['\u0429'],\n            'Ss'   => ['\u1e9e'],\n            'Th'   => ['\u00de', '\u0398', '\u05ea'],\n            'Ts'   => ['\u0426'],\n            'Ya'   => ['\u042f', '\u05d9\u05d0'],\n            'Yu'   => ['\u042e', '\u05d9\u05d5'],\n            'Zh'   => ['\u0416'],\n            ' '    => [\"\\xC2\\xA0\", \"\\xE2\\x80\\x80\", \"\\xE2\\x80\\x81\", \"\\xE2\\x80\\x82\", \"\\xE2\\x80\\x83\", \"\\xE2\\x80\\x84\", \"\\xE2\\x80\\x85\", \"\\xE2\\x80\\x86\", \"\\xE2\\x80\\x87\", \"\\xE2\\x80\\x88\", \"\\xE2\\x80\\x89\", \"\\xE2\\x80\\x8A\", \"\\xE2\\x80\\xAF\", \"\\xE2\\x81\\x9F\", \"\\xE3\\x80\\x80\", \"\\xEF\\xBE\\xA0\"],\n        ];\n    }\n\n    \/**\n     * Returns the language specific replacements for the ascii method.\n     *\n     * Note: Adapted from Stringy\\Stringy.\n     *\n     * @see https:\/\/github.com\/danielstjules\/Stringy\/blob\/3.1.0\/LICENSE.txt\n     *\/\n    protected static function languageSpecificCharsArray(string $language): ?array\n    {\n        static $languageSpecific;\n\n        if (! isset($languageSpecific)) {\n            $languageSpecific = [\n                'bg' => [\n                    ['\u0445', '\u0425', '\u0449', '\u0429', '\u044a', '\u042a', '\u044c', '\u042c'],\n                    ['h', 'H', 'sht', 'SHT', 'a', '\u0410', 'y', 'Y'],\n                ],\n                'da' => [\n                    ['\u00e6', '\u00f8', '\u00e5', '\u00c6', '\u00d8', '\u00c5'],\n                    ['ae', 'oe', 'aa', 'Ae', 'Oe', 'Aa'],\n                ],\n                'de' => [\n                    ['\u00e4',  '\u00f6',  '\u00fc',  '\u00c4',  '\u00d6',  '\u00dc'],\n                    ['ae', 'oe', 'ue', 'AE', 'OE', 'UE'],\n                ],\n                'he' => [\n                    ['\u05d0', '\u05d1', '\u05d2', '\u05d3', '\u05d4', '\u05d5'],\n                    ['\u05d6', '\u05d7', '\u05d8', '\u05d9', '\u05db', '\u05dc'],\n                    ['\u05de', '\u05e0', '\u05e1', '\u05e2', '\u05e4', '\u05e6'],\n                    ['\u05e7', '\u05e8', '\u05e9', '\u05ea', '\u05df', '\u05e5', '\u05da', '\u05dd', '\u05e3'],\n                ],\n                'ro' => [\n                    ['\u0103', '\u00e2', '\u00ee', '\u0219', '\u021b', '\u0102', '\u00c2', '\u00ce', '\u0218', '\u021a'],\n                    ['a', 'a', 'i', 's', 't', 'A', 'A', 'I', 'S', 'T'],\n                ],\n            ];\n        }\n\n        return $languageSpecific[$language] ?? null;\n    }\n\n    \/**\n     * Get the default transliterator.\n     *\n     * @return Transliterator|null Either a Transliterator instance, or `null`\n     *                             in case no transliterator has been set yet.\n     *\n     * @since 3.3.2\n     *\/\n    public static function getTransliterator(): ?Transliterator\n    {\n        return static::$_defaultTransliterator;\n    }\n\n    \/**\n     * Set the default transliterator.\n     *\n     * @param Transliterator $transliterator A `Transliterator` instance.\n     *\n     * @return void\n     *\n     * @since 3.3.2\n     *\/\n    public static function setTransliterator(Transliterator $transliterator)\n    {\n        static::$_defaultTransliterator = $transliterator;\n    }\n\n    \/**\n     * Get default transliterator identifier string.\n     *\n     * @return string Transliterator identifier.\n     *\/\n    public static function getTransliteratorId(): string\n    {\n        return static::$_defaultTransliteratorId;\n    }\n\n    \/**\n     * Set default transliterator identifier string.\n     *\n     * @param string $transliteratorId Transliterator identifier.\n     *\n     * @return void\n     *\/\n    public static function setTransliteratorId(string $transliteratorId)\n    {\n        static::setTransliterator(transliterator_create($transliteratorId));\n        static::$_defaultTransliteratorId = $transliteratorId;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,0,null,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,0,0,null,0,0,null,0,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,0,0,null,0,null,0,null,null,0,null,0,0,null,null,0,null,0,0,null,null,0,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,0,null,null,0,0,null,null,0,null,0,null,null,0,0,null,null,0,null,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,0,null,0,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,0,0,0,null,null,0,null,null,0,0,0,0,null,null,0,0,null,0,null,null,0,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,0,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,0,null,0,null,0,null,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,0,null,null,0,null,null,0,null,0,null,0,null,null,null,0,null,0,null,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,null,0,null,null,null,0,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,0,null,0,null,null,null,0,null,null,null,0,null,null,null,0,0,0,null,null,null,0,null,null,null,0,null,null,0,0,0,null,0,0,null,null,0,null,null,0,null,0,null,0,null,null,0,0,null,null,0,null,null,null,null,null,null,0,null,null,0,0,null,null,0,0,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,null,null,null,0,null,null,0,null,null,0,null,0,0,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,0,0,0,0,0,null,null,0,null,null,null,null,0,null,0,null,0,null,null,null,0,null,0,0,null,0,null,null,null,0,null,null,0,null,null,null,null,0,0,null,0,null,null,null,0,null,0,0,null,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,0,0,null,null,0,null,0,0,0,0,null,0,null,null,0,null,0,null,null,null,null,null,0,null,0,null,0,null,null,null,null,0,null,null,0,0,null,0,null,null,null,0,null,0,null,null,null,null,0,null,null,0,0,null,null,0,null,null,null,0,null,0,null,null,0,null,null,null,0,null,null,null,null,0,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null]},{"name":"src\\View\\Adapters\\AbstractAdapter.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\View\\Adapters;\n\nuse BlitzPHP\\View\\RendererInterface;\n\nabstract class AbstractAdapter implements RendererInterface\n{\n    \/**\n     * Donn\u00e9es mises \u00e0 la disposition des vues.\n     *\n     * @var array\n     *\/\n    protected $data = [];\n\n    \/**\n     * Les variables de rendu\n     *\n     * @var array\n     *\/\n    protected $renderVars = [];\n\n    \/**\n     * Le r\u00e9pertoire de base dans lequel rechercher nos vues.\n     *\n     * @var string\n     *\/\n    protected $viewPath;\n\n    \/**\n     * Configuration actuelle de l'adapter\n     *\n     * @var array\n     *\/\n    protected $config;\n\n    \/**\n     * Le nom de la mise en page utilis\u00e9e, le cas \u00e9ch\u00e9ant.\n     * D\u00e9fini par la m\u00e9thode \"extend\" utilis\u00e9e dans les vues.\n     *\n     * @var string|null\n     *\/\n    protected $layout;\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function __construct(array $config, string $viewPath = VIEW_PATH)\n    {\n        $this->config   = $config;\n        $this->viewPath = rtrim($viewPath, '\\\\\/ ') . DS;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function setData(array $data = [], ?string $context = null): self\n    {\n        if ($context) {\n            \/\/ $data = \\esc($data, $context);\n        }\n\n        $this->data = $data;\n\n        return $this;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function addData(array $data = [], ?string $context = null): self\n    {\n        if ($context) {\n            \/\/ $data = \\esc($data, $context);\n        }\n\n        $this->data = array_merge($this->data, $data);\n\n        return $this;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function setVar(string $name, $value = null, ?string $context = null): self\n    {\n        if ($context) {\n            \/\/ $value = esc($value, $context);\n        }\n\n        $this->data[$name] = $value;\n\n        return $this;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function resetData(): self\n    {\n        $this->data = [];\n\n        return $this;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function setLayout(?string $layout): self\n    {\n        $this->layout = $layout;\n\n        return $this;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function renderString(string $view, ?array $options = null, bool $saveData = false): string\n    {\n        return $this->render($view, $options, $saveData);\n    }\n\n    \/**\n     * Construit la sortie en fonction d'un nom de fichier et de tout donn\u00e9es d\u00e9j\u00e0 d\u00e9finies.\n     *\n     * Options valides :\n     * - cache Nombre de secondes \u00e0 mettre en cache pour\n     * - cache_name Nom \u00e0 utiliser pour le cache\n     *\n     * @param string     $view     Nom de fichier de la source de la vue\n     * @param array|null $options  R\u00e9serv\u00e9 \u00e0 des utilisations tierces car\n     *                             il peut \u00eatre n\u00e9cessaire de transmettre des\n     *                             informations suppl\u00e9mentaires \u00e0 d'autres moteurs de mod\u00e8les.\n     * @param bool|null  $saveData Si vrai, enregistre les donn\u00e9es pour les appels suivants,\n     *                             si faux, nettoie les donn\u00e9es apr\u00e8s affichage,\n     *                             si null, utilise le param\u00e8tre de configuration.\n     *\/\n    abstract public function render(string $view, ?array $options = null, ?bool $saveData = null): string;\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]},{"name":"src\\View\\Adapters\\BladeAdapter.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\View\\Adapters;\n\nuse Jenssegers\\Blade\\Blade;\n\nclass BladeAdapter extends AbstractAdapter\n{\n    \/**\n     * Instance Blade\n     *\n     * @var Blade\n     *\/\n    private $engine;\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function __construct(array $config, string $viewPath = VIEW_PATH)\n    {\n        parent::__construct($config, $viewPath);\n\n        $this->engine = new Blade(\n            $this->viewPath,\n            $this->config['cache_path'] ?? VIEW_CACHE_PATH . 'blade' . DIRECTORY_SEPARATOR . 'cache'\n        );\n\n        $this->configure();\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function render(string $view, ?array $options = null, ?bool $saveData = null): string\n    {\n        $view = str_replace([$this->viewPath, ' '], '', $view);\n\n        $this->renderVars['start'] = microtime(true);\n\n        $this->renderVars['view']    = $view;\n        $this->renderVars['options'] = $options ?? [];\n\n        $this->renderVars['file'] = str_replace('\/', DS, rtrim($this->viewPath, '\/\\\\') . DS . ltrim($this->renderVars['view'], '\/\\\\'));\n\n        return $this->engine->render($this->renderVars['view'], $this->data);\n    }\n\n    \/**\n     * Configure le moteur de template\n     *\/\n    private function configure(): void\n    {\n        $directives = (array) ($this->config['directives'] ?? []);\n\n        foreach ($directives as $name => $callable) {\n            if (is_callable($callable)) {\n                $this->engine->directive($name, $callable);\n            }\n        }\n\n        $if = (array) ($this->config['if'] ?? []);\n\n        foreach ($if as $name => $callable) {\n            if (is_callable($callable)) {\n                $this->engine->if($name, $callable);\n            }\n        }\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,0,null,0,0,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,0,null,null,null,0,null,null,null,null,null]},{"name":"src\\View\\Adapters\\LatteAdapter.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\View\\Adapters;\n\nuse Latte\\Engine;\nuse Latte\\Loaders\\FileLoader;\n\nclass LatteAdapter extends AbstractAdapter\n{\n    \/**\n     * Instance Latte\n     *\n     * @var \\Latte\\Engine\n     *\/\n    private $latte;\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function __construct(array $config, string $viewPath = VIEW_PATH)\n    {\n        parent::__construct($config, $viewPath);\n\n        $this->latte = new Engine();\n\n        $this->configure();\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function render(string $view, ?array $options = null, ?bool $saveData = null): string\n    {\n        $view = str_replace([$this->viewPath, ' '], '', $view);\n        if (empty(pathinfo($view, PATHINFO_EXTENSION))) {\n            $view .= '.' . str_replace('.', '', $this->config['extension'] ?? 'latte');\n        }\n\n        $this->renderVars['start'] = microtime(true);\n\n        $this->renderVars['view']    = $view;\n        $this->renderVars['options'] = $options ?? [];\n\n        $this->renderVars['file'] = str_replace('\/', DS, rtrim($this->viewPath, '\/\\\\') . DS . ltrim($this->renderVars['view'], '\/\\\\'));\n\n        return $this->latte->renderToString($this->renderVars['view'], $this->data);\n    }\n\n    \/**\n     * Configure le moteur de template\n     *\/\n    private function configure()\n    {\n        if (isset($this->config['configure']) && is_callable($this->config['configure'])) {\n            $newInstance = $this->config['configure']($this->latte);\n            if ($newInstance instanceof Engine) {\n                $this->latte = $newInstance;\n            }\n        }\n\n        $auto_refresh = $this->config['auto_refresh'] ?? 'auto';\n        if ($auto_refresh === 'auto') {\n            $auto_refresh = ! is_online();\n        }\n        $this->latte->setAutoRefresh($auto_refresh);\n\n        $this->latte->setTempDirectory($this->config['temp_path'] ?? TEMP_PATH . 'views');\n        $this->latte->setLoader(new FileLoader(rtrim($this->viewPath, '\/\\\\')));\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,0,null,0,0,null,0,null,0,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,0,null,0,null,0,0,null,null,null]},{"name":"src\\View\\Adapters\\NativeAdapter.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\View\\Adapters;\n\nuse BlitzPHP\\Exceptions\\ViewException;\nuse RuntimeException;\n\n\/**\n * Class View\n *\/\nclass NativeAdapter extends AbstractAdapter\n{\n    \/**\n     * Fusionner les donn\u00e9es enregistr\u00e9es et les donn\u00e9es utilisateur\n     *\/\n    protected $tempData;\n\n    \/**\n     * Devrions-nous stocker des informations sur les performances ?\n     *\n     * @var bool\n     *\/\n    protected $debug = false;\n\n    \/**\n     * Cachez les statistiques sur nos performances ici\n     *\n     * @var array\n     *\/\n    protected $performanceData = [];\n\n    \/**\n     * Indique si les donn\u00e9es doivent \u00eatre enregistr\u00e9es entre les rendus.\n     *\n     * @var bool\n     *\/\n    protected $saveData;\n\n    \/**\n     * Nombre de vues charg\u00e9es\n     *\n     * @var int\n     *\/\n    protected $viewsCount = 0;\n\n    \/**\n     * Contient les sections et leurs donn\u00e9es.\n     *\n     * @var array\n     *\/\n    protected $sections = [];\n\n    \/**\n     * Le nom de la section actuelle en cours de rendu, le cas \u00e9ch\u00e9ant.\n     *\n     * @var string[]\n     *\/\n    protected $sectionStack = [];\n\n    \/**\n     * Constructor.\n     *\/\n    public function __construct(array $config, string $viewPath = VIEW_PATH)\n    {\n        parent::__construct($config, $viewPath);\n\n        $this->saveData = (bool) ($config['save_data'] ?? true);\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function render(string $view, ?array $options = null, ?bool $saveData = null): string\n    {\n        $view = str_replace([$this->viewPath, ' '], '', $view);\n        if (empty(pathinfo($view, PATHINFO_EXTENSION))) {\n            $view .= '.' . str_replace('.', '', $this->config['extension'] ?? 'php');\n        }\n\n        $this->renderVars['start']   = microtime(true);\n        $this->renderVars['view']    = $view;\n        $this->renderVars['options'] = $options ?? [];\n\n        \/\/ Stocke les r\u00e9sultats ici donc m\u00eame si\n        \/\/ plusieurs vues sont appel\u00e9es dans une vue, ce ne sera pas le cas\n        \/\/ nettoyez-le sauf si nous le voulons.\n        $saveData ??= $this->saveData;\n\n        \/\/ A-t-il \u00e9t\u00e9 mis en cache ?\n        if (isset($this->renderVars['options']['cache'])) {\n            $cacheName = $this->renderVars['options']['cache_name'] ?? str_replace('.php', '', $this->renderVars['view']);\n            $cacheName = str_replace(['\\\\', '\/'], '', $cacheName);\n\n            $this->renderVars['cacheName'] = $cacheName;\n\n            if ($output = cache($this->renderVars['cacheName'])) {\n                $this->logPerformance($this->renderVars['start'], microtime(true), $this->renderVars['view']);\n\n                return $output;\n            }\n        }\n\n        $this->renderVars['file'] = str_replace('\/', DS, rtrim($this->viewPath, '\/\\\\') . DS . ltrim($this->renderVars['view'], '\/\\\\'));\n\n        if (! is_file($this->renderVars['file'])) {\n            throw ViewException::invalidFile($this->renderVars['view']);\n        }\n\n        \/\/ Rendre nos donn\u00e9es de vue disponibles pour la vue.\n        $this->prepareTemplateData($saveData);\n\n        \/\/ Enregistrer les variables actuelles\n        $renderVars = $this->renderVars;\n\n        $output = (function (): string {\n            extract($this->tempData);\n            ob_start();\n            include $this->renderVars['file'];\n\n            return ob_get_clean() ?: '';\n        })();\n\n        \/\/ R\u00e9cup\u00e8re les variables actuelles\n        $this->renderVars = $renderVars;\n\n        \/\/ Lors de l'utilisation de mises en page, les donn\u00e9es ont d\u00e9j\u00e0 \u00e9t\u00e9 stock\u00e9es\n        \/\/ dans $this->sections, et aucune autre sortie valide\n        \/\/ est autoris\u00e9 dans $output donc nous allons l'\u00e9craser.\n        if ($this->layout !== null && $this->sectionStack === []) {\n            $layoutView   = $this->layout;\n            $this->layout = null;\n            \/\/ Enregistrer les variables actuelles\n            $renderVars = $this->renderVars;\n            $output     = $this->render($layoutView, $options, $saveData);\n            \/\/ R\u00e9cup\u00e8re les variables actuelles\n            $this->renderVars = $renderVars;\n        }\n\n        $this->logPerformance($this->renderVars['start'], microtime(true), $this->renderVars['view']);\n\n        if (($this->debug && (! isset($options['debug']) || $options['debug'] === true))) {\n            \/\/ Nettoyer nos noms de chemins pour les rendre un peu plus propres\n            $this->renderVars['file'] = clean_path($this->renderVars['file']);\n            $this->renderVars['file'] = ++$this->viewsCount . ' ' . $this->renderVars['file'];\n\n            $output = '<!-- DEBUG-VIEW START ' . $this->renderVars['file'] . ' -->' . PHP_EOL\n                . $output . PHP_EOL\n                . '<!-- DEBUG-VIEW ENDED ' . $this->renderVars['file'] . ' -->' . PHP_EOL;\n        }\n\n        \/\/ Faut-il mettre en cache ?\n        if (isset($this->renderVars['options']['cache'])) {\n            cache()->write($this->renderVars['cacheName'], $output, (int) $this->renderVars['options']['cache']);\n        }\n\n        $this->tempData = null;\n\n        return $output;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function renderString(string $view, ?array $options = null, ?bool $saveData = null): string\n    {\n        $start = microtime(true);\n        $saveData ??= $this->saveData;\n        $this->prepareTemplateData($saveData);\n\n        $output = (function (string $view): string {\n            extract($this->tempData);\n            ob_start();\n            eval('?>' . $view);\n\n            return ob_get_clean() ?: '';\n        })($view);\n\n        $this->logPerformance($start, microtime(true), $this->excerpt($view));\n        $this->tempData = null;\n\n        return $output;\n    }\n\n    \/**\n     * Extraire le premier bit d'une longue cha\u00eene et ajouter des points de suspension\n     *\/\n    public function excerpt(string $string, int $length = 20): string\n    {\n        return (strlen($string) > $length) ? substr($string, 0, $length - 3) . '...' : $string;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function setData(array $data = [], ?string $context = null): self\n    {\n        if ($context) {\n            \/\/ $data = \\esc($data, $context);\n        }\n\n        $this->tempData = $data;\n\n        return $this;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function addData(array $data = [], ?string $context = null): self\n    {\n        if ($context) {\n            \/\/ $data = \\esc($data, $context);\n        }\n\n        $this->tempData ??= $this->data;\n        $this->tempData = array_merge($this->tempData, $data);\n\n        return $this;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function setVar(string $name, $value = null, ?string $context = null): self\n    {\n        if ($context) {\n            \/\/ $value = esc($value, $context);\n        }\n\n        $this->tempData ??= $this->data;\n        $this->tempData[$name] = $value;\n\n        return $this;\n    }\n\n    \/**\n     * Renvoie les donn\u00e9es actuelles qui seront affich\u00e9es dans la vue.\n     *\/\n    public function getData(): array\n    {\n        return $this->tempData ?? $this->data;\n    }\n\n    \/**\n     * Sp\u00e9cifie que la vue actuelle doit \u00e9tendre une mise en page existante.\n     *\/\n    public function extend(string $layout)\n    {\n        $this->layout = $layout;\n    }\n\n    \/**\n     * Commence contient le contenu d'une section dans la mise en page.\n     *\/\n    public function start(string $name)\n    {\n        $this->sectionStack[] = $name;\n\n        ob_start();\n    }\n\n    \/**\n     * Commence contient le contenu d'une section dans la mise en page.\n     *\n     * @alias self::start()\n     *\/\n    public function section(string $name): void\n    {\n        $this->start($name);\n    }\n\n    \/**\n     * Commence contient le contenu d'une section dans la mise en page.\n     *\n     * @alias self::start()\n     *\/\n    public function begin(string $name): void\n    {\n        $this->start($name);\n    }\n\n    \/**\n     * Capture la derni\u00e8re section\n     *\n     * @throws RuntimeException\n     *\/\n    public function stop()\n    {\n        $contents = ob_get_clean();\n\n        if ($this->sectionStack === []) {\n            throw new RuntimeException('View themes, no current section.');\n        }\n\n        $section = array_pop($this->sectionStack);\n\n        \/\/ Assurez-vous qu'un tableau existe afin que nous puissions stocker plusieurs entr\u00e9es pour cela.\n        if (! array_key_exists($section, $this->sections)) {\n            $this->sections[$section] = [];\n        }\n\n        $this->sections[$section][] = $contents;\n    }\n\n    \/**\n     * Capture la derni\u00e8re section\n     *\n     * @throws RuntimeException\n     * @alias self::stop()\n     *\/\n    public function endSection(): void\n    {\n        $this->stop();\n    }\n\n    \/**\n     * Capture la derni\u00e8re section\n     *\n     * @throws RuntimeException\n     * @alias self::stop()\n     *\/\n    public function end(): void\n    {\n        $this->stop();\n    }\n\n    \/**\n     * Restitue le contenu d'une section.\n     *\/\n    public function show(string $sectionName)\n    {\n        if (! isset($this->sections[$sectionName])) {\n            echo '';\n\n            return;\n        }\n\n        $start = $end = '';\n        if ($sectionName === 'css') {\n            $start = \"<style type=\\\"text\/css\\\">\\n\";\n            $end   = \"<\/style>\\n\";\n        }\n        if ($sectionName === 'js') {\n            $start = \"<script type=\\\"text\/javascript\\\">\\n\";\n            $end   = \"<\/script>\\n\";\n        }\n\n        echo $start;\n\n        foreach ($this->sections[$sectionName] as $key => $contents) {\n            echo $contents;\n            unset($this->sections[$sectionName][$key]);\n        }\n        echo $end;\n    }\n\n    \/**\n     * Affichage rapide du contenu principal\n     *\/\n    public function renderView(): void\n    {\n        $this->show('content');\n    }\n\n    \/**\n     * Utilis\u00e9 dans les vues de mise en page pour inclure des vues suppl\u00e9mentaires.\n     *\n     * @param mixed $saveData\n     *\/\n    public function insert(string $view, ?array $data = [], ?array $options = null, $saveData = true): string\n    {\n        $view = preg_replace('#\\.php$#i', '', $view) . '.php';\n        $view = str_replace(' ', '', $view);\n\n        if ($view[0] !== '\/') {\n            $current_dir = pathinfo($this->renderVars['file'] ?? '', PATHINFO_DIRNAME);\n            if (file_exists(rtrim($current_dir, DS) . DS . $view)) {\n                $view = rtrim($current_dir, DS) . DS . $view;\n            } elseif (file_exists($this->viewPath . 'partials' . DS . $view)) {\n                $view = $this->viewPath . 'partials' . DS . $view;\n            } elseif (file_exists($this->viewPath . trim(dirname($current_dir), '\/\\\\') . DS . $view)) {\n                $view = $this->viewPath . trim(dirname($current_dir), '\/\\\\') . DS . $view;\n            } elseif (file_exists(VIEW_PATH . 'partials' . DS . $view)) {\n                $view = VIEW_PATH . 'partials' . DS . $view;\n            } elseif (file_exists(VIEW_PATH . trim(dirname($current_dir), '\/\\\\') . DS . $view)) {\n                $view = VIEW_PATH . trim(dirname($current_dir), '\/\\\\') . DS . $view;\n            }\n        }\n\n        return $this->addData($data)->render($view, $options, $saveData);\n    }\n\n    \/**\n     * Utilis\u00e9 dans les vues de mise en page pour inclure des vues suppl\u00e9mentaires.\n     *\n     * @alias self::insert()\n     *\n     * @param mixed $saveData\n     *\/\n    public function include(string $view, ?array $data = [], ?array $options = null, $saveData = true): string\n    {\n        return $this->insert($view, $data, $options, $saveData);\n    }\n\n    \/**\n     * Renvoie les donn\u00e9es de performances qui ont pu \u00eatre collect\u00e9es\n     * lors de l'ex\u00e9cution. Utilis\u00e9 principalement dans la barre d'outils de d\u00e9bogage.\n     *\/\n    public function getPerformanceData(): array\n    {\n        return $this->performanceData;\n    }\n\n    \/**\n     * Consigne les donn\u00e9es de performances pour le rendu d'une vue.\n     *\/\n    protected function logPerformance(float $start, float $end, string $view)\n    {\n        if ($this->debug) {\n            $this->performanceData[] = [\n                'start' => $start,\n                'end'   => $end,\n                'view'  => $view,\n            ];\n        }\n    }\n\n    protected function prepareTemplateData(bool $saveData): void\n    {\n        $this->tempData ??= $this->data;\n\n        if ($saveData) {\n            $this->data = $this->tempData;\n        }\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,0,0,0,null,null,null,null,0,null,null,null,0,0,null,0,null,null,0,null,0,null,null,null,0,null,null,0,null,null,null,0,null,null,0,null,null,0,0,0,null,0,0,null,null,0,null,null,null,null,null,0,0,null,0,0,null,0,null,null,0,null,null,null,0,0,null,null,null,0,null,null,null,null,0,null,null,0,null,0,null,null,null,null,null,null,null,0,0,0,null,null,0,0,0,null,0,0,null,0,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,null,null,0,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,0,0,null,null,0,0,null,null,0,null,null,0,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,0,null,null,0,null,0,null,0,null,0,null,0,null,0,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,0,null,null,0,null,null,null,null]},{"name":"src\\View\\Adapters\\PlatesAdapter.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\View\\Adapters;\n\nuse League\\Plates\\Engine;\nuse League\\Plates\\Extension\\Asset;\n\nclass PlatesAdapter extends AbstractAdapter\n{\n    \/**\n     * Instance Plate\n     *\n     * @var Engine\n     *\/\n    private $engine;\n\n    \/**\n     * Extension de fichier \u00e0 utiliser\n     *\n     * @var string\n     *\/\n    private $extension;\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function __construct(array $config, string $viewPath = VIEW_PATH)\n    {\n        parent::__construct($config, $viewPath);\n\n        $this->extension = str_replace('.', '', $this->config['extension'] ?? 'tpl');\n        $this->engine    = new Engine(rtrim($this->viewPath, '\/\\\\'), $this->extension);\n\n        $this->configure();\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function render(string $view, ?array $options = null, ?bool $saveData = null): string\n    {\n        $view = str_replace([$this->viewPath, ' '], '', $view);\n\n        $this->renderVars['start'] = microtime(true);\n\n        $this->renderVars['view']    = $view;\n        $this->renderVars['options'] = $options ?? [];\n\n        $this->renderVars['file'] = str_replace('\/', DS, rtrim($this->viewPath, '\/\\\\') . DS . ltrim($this->renderVars['view'], '\/\\\\'));\n\n        return $this->engine->render($this->renderVars['view'], $this->data);\n    }\n\n    \/**\n     * Configure le moteur de template\n     *\/\n    private function configure(): void\n    {\n        if (isset($this->config['configure']) && is_callable($this->config['configure'])) {\n            $newInstance = $this->config['configure']($this->engine);\n            if ($newInstance instanceof Engine) {\n                $this->engine = $newInstance;\n            }\n        }\n\n        $this->engine->addFolder('partials', VIEW_PATH . 'partials', true);\n        $this->engine->addFolder('layouts', LAYOUT_PATH, true);\n\n        $this->engine->loadExtension(new Asset(WEBROOT));\n\n        $functions = (array) ($this->config['functions'] ?? []);\n\n        foreach ($functions as $name => $callable) {\n            if (is_callable($callable)) {\n                $this->engine->registerFunction($name, $callable);\n            }\n        }\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,null,0,null,null,null,null,null,null,null,0,null,0,null,0,0,null,0,null,0,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,0,null,0,null,0,null,null,null,0,null,null,null,null,null]},{"name":"src\\View\\Adapters\\SmartyAdapter.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\View\\Adapters;\n\nuse Smarty;\n\nclass SmartyAdapter extends AbstractAdapter\n{\n    \/**\n     * Instance Smarty\n     *\n     * @var Smarty\n     *\/\n    private $engine;\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function __construct(array $config, string $viewPath = VIEW_PATH)\n    {\n        parent::__construct($config, $viewPath);\n\n        $this->engine = new Smarty();\n\n        $this->configure();\n    }\n\n    \/**\n     * Active la mise en cache des pages\n     *\/\n    public function enableCache(): self\n    {\n        $this->engine->setCaching(Smarty::CACHING_LIFETIME_SAVED);\n\n        return $this;\n    }\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function render(string $view, ?array $options = null, ?bool $saveData = null): string\n    {\n        $view = str_replace([$this->viewPath, ' '], '', $view);\n        if (empty(pathinfo($view, PATHINFO_EXTENSION))) {\n            $view .= '.' . str_replace('.', '', $this->config['extension'] ?? 'tpl');\n        }\n\n        $this->renderVars['start']   = microtime(true);\n        $this->renderVars['view']    = $view;\n        $this->renderVars['options'] = $options ?? [];\n        $this->renderVars['file']    = str_replace('\/', DS, rtrim($this->viewPath, '\/\\\\') . DS . ltrim($this->renderVars['view'], '\/\\\\'));\n\n        $layout = $this->layout;\n        if (! empty($layout)) {\n            if (empty(pathinfo($layout, PATHINFO_EXTENSION))) {\n                $layout .= '.tpl';\n            }\n            $view = 'extends:[layouts]' . $layout . '|' . $view;\n        }\n\n        $this->engine->assign($this->data);\n\n        \/\/ Doit-on mettre en cache?\n        if (! empty($this->renderVars['options']['cache_name']) || ! empty($this->renderVars['options']['cache'])) {\n            $this->enableCache();\n            $this->engine->setCacheLifetime(60 * $this->renderVars['options']['cache'] ?? 60);\n            $this->engine->setCompileId($this->renderVars['options']['cache_name'] ?? null);\n        }\n\n        return $this->engine->fetch(\n            $view,\n            $this->renderVars['options']['cache_id'] ?? null,\n            $this->renderVars['options']['cache_name'] ?? ($this->renderVars['options']['compile_id'] ?? null),\n            $this->renderVars['options']['parent'] ?? null,\n        );\n    }\n\n    \/**\n     * Configure le moteur de template\n     *\/\n    private function configure(): void\n    {\n        if (isset($this->config['configure']) && is_callable($this->config['configure'])) {\n            $newInstance = $this->config['configure']($this->engine);\n            if ($newInstance instanceof Smarty) {\n                $this->engine = $newInstance;\n            }\n        }\n\n        $this->engine->setTemplateDir([\n            $this->viewPath,\n            'partials' => VIEW_PATH . 'partials',\n            'layouts'  => LAYOUT_PATH,\n        ]);\n\n        $this->engine->addPluginsDir([\n            SYST_PATH . 'Helpers',\n            HELPER_PATH,\n        ]);\n\n        $config = array_merge([\n            'config_dir'    => CONFIG_PATH,\n            'cache_dir'     => VIEW_CACHE_PATH . 'smarty' . DIRECTORY_SEPARATOR . 'cache',\n            'compile_dir'   => VIEW_CACHE_PATH . 'smarty' . DIRECTORY_SEPARATOR . 'compile',\n            'caching'       => Smarty::CACHING_OFF,\n            'compile_check' => on_dev(),\n        ], $this->config);\n\n        foreach ($config as $key => $value) {\n            if (property_exists($this->engine, $key)) {\n                $this->engine->{$key} = $value;\n            }\n        }\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,0,0,0,0,null,0,null,null,0,null,0,null,null,0,null,null,null,0,0,0,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,null,null,null,0,null,null,null,null,null,null,null,0,null,null,null,0,null,null,null,null,null]},{"name":"src\\View\\Adapters\\TwigAdapter.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\View\\Adapters;\n\nuse Twig\\Environment;\nuse Twig\\Loader\\FilesystemLoader;\nuse Twig\\TwigFilter;\nuse Twig\\TwigFunction;\n\nclass TwigAdapter extends AbstractAdapter\n{\n    \/**\n     * Instance Twig\n     *\n     * @var Environment\n     *\/\n    private $engine;\n\n    \/**\n     * {@inheritDoc}\n     *\/\n    public function __construct(array $config, string $viewPath = VIEW_PATH)\n    {\n        parent::__construct($config, $viewPath);\n\n        $loader = new FilesystemLoader([\n            $this->viewPath,\n            VIEW_PATH . 'partials',\n            LAYOUT_PATH,\n        ]);\n        $this->engine = new Environment($loader);\n\n        $this->configure();\n    }\n\n    \/**\n     * Rend une vue en associant le layout si celui ci est defini\n     *\n     * @param string|null $template\n     * @param mixed       $cache_id\n     * @param mixed       $compile_id\n     * @param mixed       $parent\n     *\/\n    public function render(string $view, ?array $options = null, ?bool $saveData = null): string\n    {\n        $view = str_replace([$this->viewPath, ' '], '', $view);\n        if (empty(pathinfo($view, PATHINFO_EXTENSION))) {\n            $view .= '.' . str_replace('.', '', $this->config['extension'] ?? 'twig');\n        }\n\n        $this->renderVars['start'] = microtime(true);\n\n        $this->renderVars['view']    = $view;\n        $this->renderVars['options'] = $options ?? [];\n\n        $this->renderVars['file'] = str_replace('\/', DS, rtrim($this->viewPath, '\/\\\\') . DS . ltrim($this->renderVars['view'], '\/\\\\'));\n\n        return $this->engine->render($this->renderVars['view'], $this->data);\n    }\n\n    \/**\n     * Configure le moteur de template\n     *\/\n    private function configure(): void\n    {\n        if (isset($this->config['configure']) && is_callable($this->config['configure'])) {\n            $newInstance = $this->config['configure']($this->engine);\n            if ($newInstance instanceof Environment) {\n                $this->engine = $newInstance;\n            }\n        }\n\n        $autoReload = $this->config['auto_reload'] ?: 'auto';\n        if ('auto' === $autoReload) {\n            $autoReload = on_dev();\n        }\n        if (true === $autoReload) {\n            $this->engine->enableAutoReload();\n        } else {\n            $this->engine->disableAutoReload();\n        }\n\n        $debug = $this->config['debug'] ?: 'auto';\n        if ('auto' === $debug) {\n            $debug = on_dev();\n        }\n        if (true === $debug) {\n            $this->engine->enableDebug();\n        } else {\n            $this->engine->disableDebug();\n        }\n\n        $strictVariables = $this->config['strict_variables'] ?: 'auto';\n        if ('auto' === $strictVariables) {\n            $strictVariables = on_dev();\n        }\n        if (true === $strictVariables) {\n            $this->engine->enableStrictVariables();\n        } else {\n            $this->engine->disableStrictVariables();\n        }\n\n        $this->engine->setCharset($this->config['charset'] ?: config('app.charset'));\n\n        $this->engine->setCache($this->config['cache_dir'] ?: VIEW_CACHE_PATH . 'twig');\n\n        \/\/ Ajout des variables globals\n        $globals = (array) ($this->config['globals'] ?? []);\n\n        foreach ($globals as $name => $global) {\n            $this->engine->addGlobal($name, $global);\n        }\n\n        \/\/ Ajout des filtres\n        $filters = (array) ($this->config['filters'] ?? []);\n\n        foreach ($filters as $filter) {\n            if ($filter instanceof TwigFilter) {\n                $this->engine->addFilter($filter);\n            }\n        }\n\n        \/\/ Ajout des fonctions\n        $functions = (array) ($this->config['functions'] ?? []);\n\n        foreach ($functions as $function) {\n            if ($function instanceof TwigFunction) {\n                $this->engine->addFunction($function);\n            }\n        }\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,0,0,null,0,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,0,null,0,0,null,0,null,0,null,null,null,null,null,null,null,null,0,null,0,null,null,null,0,null,0,null,null,0,null,0,null,null,0,null,0,null,null,0,null,0,null,null,0,null,0,null,null,0,null,0,null,null,0,null,0,null,null,0,null,null,0,null,null,null,0,null,null,null,0,null,null,null,null,0,null,null,null,0,null,null,null,null,null]},{"name":"src\\View\\View.php","source":"<?php\n\n\/**\n * This file is part of Blitz PHP framework.\n *\n * (c) 2022 Dimitri Sitchet Tomkeu <devcode.dst@gmail.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n *\/\n\nnamespace BlitzPHP\\View;\n\nuse BlitzPHP\\Exceptions\\ConfigException;\nuse BlitzPHP\\View\\Adapters\\BladeAdapter;\nuse BlitzPHP\\View\\Adapters\\LatteAdapter;\nuse BlitzPHP\\View\\Adapters\\NativeAdapter;\nuse BlitzPHP\\View\\Adapters\\PlatesAdapter;\nuse BlitzPHP\\View\\Adapters\\SmartyAdapter;\nuse BlitzPHP\\View\\Adapters\\TwigAdapter;\n\nclass View\n{\n    \/**\n     * Views configuration\n     *\n     * @var array\n     *\/\n    private $config;\n\n    \/**\n     * @var RendererInterface\n     *\/\n    private $adapter;\n\n    \/**\n     * Liste des adapters pris en comptes\n     *\n     * @var array\n     *\/\n    public static $validAdapters = [\n        'native' => NativeAdapter::class,\n        'blade'  => BladeAdapter::class,\n        'latte'  => LatteAdapter::class,\n        'plates' => PlatesAdapter::class,\n        'smarty' => SmartyAdapter::class,\n        'twig'   => TwigAdapter::class,\n    ];\n\n    \/**\n     * Options de la vue\n     *\n     * @var array\n     *\/\n    private $options = [];\n\n    \/**\n     * La vue \u00e0 rendre\n     *\n     * @var string\n     *\/\n    private $view;\n\n    \/**\n     * Constructeur\n     *\/\n    public function __construct()\n    {\n        $this->config = config('view');\n\n        $this->setAdapter($this->config['active_adapter'] ?? 'native');\n    }\n\n    public function __toString()\n    {\n        return $this->get();\n    }\n\n    \/**\n     * Recupere et retourne le code html de la vue cr\u00e9\u00e9e\n     *\n     * @param bool|string $compress\n     *\/\n    public function get($compress = 'auto'): string\n    {\n        $output = $this->adapter->render($this->view, $this->options);\n\n        return $this->compressView($output, $compress);\n    }\n\n    \/**\n     * Affiche la vue generee au navigateur\n     *\/\n    public function render(): void\n    {\n        $compress = $this->config['compress_output'] ?? 'auto';\n\n        echo $this->get($compress);\n    }\n\n    \/**\n     * Modifier les options d'affichage\n     *\/\n    public function setOptions(?array $options = []): self\n    {\n        $this->options = (array) $options;\n\n        return $this;\n    }\n\n    \/**\n     * D\u00e9finir la vue \u00e0 afficher\n     *\/\n    public function display(string $view): self\n    {\n        $this->view = $view;\n\n        return $this;\n    }\n\n    \/**\n     * D\u00e9finit plusieurs \u00e9l\u00e9ments de donn\u00e9es de vue \u00e0 la fois.\n     *\/\n    public function addData(array $data = [], ?string $context = null): self\n    {\n        $this->adapter->addData($data, $context);\n\n        return $this;\n    }\n\n    \/**\n     * D\u00e9finit une seule donn\u00e9e de vue.\n     *\n     * @param mixed|null $value\n     *\/\n    public function setVar(string $name, $value = null, ?string $context = null): self\n    {\n        $this->adapter->setVar($name, $value, $context);\n\n        return $this;\n    }\n\n    \/**\n     * Remplacer toutes les donn\u00e9es de vue par de nouvelles donn\u00e9es\n     *\/\n    public function setData(array $data, ?string $context = null): self\n    {\n        $this->adapter->setData($data, $context);\n\n        return $this;\n    }\n\n    \/**\n     * Supprime toutes les donn\u00e9es de vue du syst\u00e8me.\n     *\/\n    public function resetData(): self\n    {\n        $this->adapter->resetData();\n\n        return $this;\n    }\n\n    \/**\n     * Definit le layout a utiliser par les vues\n     *\/\n    public function setLayout(string $layout): self\n    {\n        $this->adapter->setLayout($layout);\n\n        return $this;\n    }\n\n    \/**\n     * Defini l'adapteur \u00e0 utiliser\n     *\/\n    public function setAdapter(string $adapter, array $config = []): self\n    {\n        if (! array_key_exists($adapter, self::$validAdapters)) {\n            $adapter = 'native';\n        }\n        if (empty($this->config['adapters']) || ! is_array($this->config['adapters'])) {\n            $this->config['adapters'] = [];\n        }\n\n        $config = array_merge($this->config['adapters'][$adapter] ?? [], $config);\n        if (empty($config)) {\n            throw ConfigException::viewAdapterConfigNotFound($adapter);\n        }\n\n        $this->adapter = new self::$validAdapters[$adapter]($config, $this->config['view_base'] ?? VIEW_PATH);\n\n        return $this;\n    }\n\n    \/**\n     * Compresse le code html d'une vue\n     *\n     * @param bool|string $compress\n     *\/\n    private function compressView(string $output, $compress = 'auto'): string\n    {\n        if ($compress === 'auto') {\n            $compress = is_online();\n        }\n\n        return true === $compress ? trim(preg_replace('\/\\s+\/', ' ', $output)) : $output;\n    }\n}\n","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,0,null,0,null,null,null,null,null,null,null,null,0,null,null,0,null,null,0,null,0,null,null,0,null,0,null,null,null,null,null,null,null,null,null,null,0,null,null,0,null,null,null]}]}